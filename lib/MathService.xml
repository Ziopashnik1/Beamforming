<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MathService</name>
    </assembly>
    <members>
        <member name="M:MathService.AI.ART_1.Cluster`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathService.AI.ART_1.Cluster`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathService.AI.ART_1.Image`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathService.AI.ART_1.Image`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathService.AI.NeuralNetworks.MultilayerPerceptron">
            <summary>Многослойная полносвязная нейронная сеть прямого распространения</summary>
        </member>
        <member name="M:MathService.AI.NeuralNetworks.MultilayerPerceptron.ProcessLayer(System.Double[],System.Double[0:,0:],System.Double[],System.Double[],System.Double[])">
            <summary>Обработка одного слоя в алгоритме прямого распространения без функции активации</summary>
            <param name="Input">Массив значений на входе слоя</param>
            <param name="W">Массив матрицы коэффициентов передачи слоя</param>
            <param name="Output">Массив выходов слоя без применения к ним функции активации</param>
        </member>
        <member name="M:MathService.AI.NeuralNetworks.MultilayerPerceptron.DirectDistribution(System.Double[])">
            <summary>Алгоритм прямого распространения</summary>
            <param name="NetworkOutput">Массив выходных значений сети</param>
        </member>
        <member name="F:MathService.AI.NeuralNetworks.MultilayerPerceptron._Layers">
            <summary>Матрицы коэффициентов передачи слоёв (номер строки - номер нейрона; номер столбца - номер входа нейрона; последний столбец - смещение нейрона)</summary>
        </member>
        <member name="F:MathService.AI.NeuralNetworks.MultilayerPerceptron._Offsets">
            <summary>Массив смещений нейронов в слоях (первый индекс - номер слоя; второй - номер нейрона в слое)</summary>
        </member>
        <member name="F:MathService.AI.NeuralNetworks.MultilayerPerceptron._OffsetsWeights">
            <summary>Массив весовых коэффициентов смещений нейронов в слоях (первый индекс - номер слоя; второй - номер нейрона в слое)</summary>
        </member>
        <member name="F:MathService.AI.NeuralNetworks.MultilayerPerceptron._Inputs">
            <summary>Массив входных массивов солёв</summary>
        </member>
        <member name="F:MathService.AI.NeuralNetworks.MultilayerPerceptron._Outputs">
            <summary>Массив выходных массивов слоёв (содержащих значения выходов нейронов до применения к ним функции активации)</summary>
        </member>
        <member name="F:MathService.AI.NeuralNetworks.MultilayerPerceptron._Activation">
            <summary>Функция активации</summary>
        </member>
        <member name="F:MathService.AI.NeuralNetworks.MultilayerPerceptron._dActivation">
            <summary>Производная функции активации</summary>
        </member>
        <member name="P:MathService.AI.NeuralNetworks.MultilayerPerceptron.Activation">
            <summary>Функция активации</summary>
        </member>
        <member name="P:MathService.AI.NeuralNetworks.MultilayerPerceptron.dActivation">
            <summary>Производная функции активации</summary>
        </member>
        <member name="P:MathService.AI.NeuralNetworks.MultilayerPerceptron.InputsCount">
            <summary>Число входов сети</summary>
        </member>
        <member name="P:MathService.AI.NeuralNetworks.MultilayerPerceptron.OutputsCount">
            <summary>Число выходов сети</summary>
        </member>
        <member name="P:MathService.AI.NeuralNetworks.MultilayerPerceptron.LayersCount">
            <summary>Количество слоёв сети</summary>
        </member>
        <member name="M:MathService.AI.NeuralNetworks.MultilayerPerceptron.#ctor(System.Double[0:,0:][])">
            <summary>Инициализация новой многослойной нейронной сети</summary>
            <param name="Layers">Набор матриц коэффициентов передачи слоёв</param>
        </member>
        <member name="M:MathService.AI.NeuralNetworks.MultilayerPerceptron.ActivationFunc(System.Double[],System.Double[])">
            <summary>Применение функции активации к массиву выходных значений слоя с последующим копированием результата в ячейки входного массива следующего слоя</summary>
            <param name="PreviousOutputs">Массив значений выходов предыдущего слоя</param>
            <param name="NextInputs">Массив значений входов следующего слоя</param>
        </member>
        <member name="M:MathService.AI.NeuralNetworks.MultilayerPerceptron.Process(System.Double[],System.Double[])">
            <summary>Обработка входного воздействия</summary>
            <param name="NetworkInput">Массив входного воздействия</param>
            <param name="NetworkOutput">Выход сети</param>
        </member>
        <member name="M:MathService.AI.NeuralNetworks.MultilayerPerceptron.Process(System.Double[],System.Double[],System.Double[])">
            <summary>Обработка входного воздействия</summary>
            <param name="NetworkInput">Массив входного воздействия</param>
            <param name="NetworkOutput">Выход сети</param>
            <param name="ExpectedOutput">Массив значений, ожидаемых на выходе сети</param>
            <returns>Массив среднеквадратических отклонений по выходам сети</returns>
        </member>
        <member name="M:MathService.AI.NeuralNetworks.MultilayerPerceptron.ProcessWithTeach(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>Обработка входного воздействия с обучением</summary>
            <param name="NetworkInput">Массив входного воздействия</param>
            <param name="NetworkOutput">Выход сети</param>
            <param name="ExpectedOutput">Массив значений, ожидаемых на выходе сети</param>
            <param name="rho">Коэффициент скорости обучения (в интервале от 0 до 1)</param>
            <remarks>Если коэффициент скорости обучения равен 0, то алгоритм обратного распространения ошибки не выполняется</remarks>
            <returns>Массив среднеквадратических отклонений по выходам сети</returns>
        </member>
        <member name="T:MathService.BigInteger">
            <summary> Целочисленная арифметика с большими числами  </summary>
        </member>
        <member name="F:MathService.BigInteger.c_MaxLength">
            <summary>Максимальная длина числа в байтах</summary>
        </member>
        <member name="F:MathService.BigInteger.PrimesBelow2000">
            <summary>Простые числа до 2000</summary>
        </member>
        <member name="T:MathService.CommandProcessor.Argument">
            <summary>Аргумент команды</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Argument.Name">
            <summary>Имя аргумента</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Argument.Values">
            <summary>Массив значений аргумента</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Argument.Value">
            <summary>Значение аргумента</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Argument.Count">
            <summary>Количество значений аргумента</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Argument.Item(System.Int32)">
            <summary>Доступ к значениям аргумента по номеру</summary>
            <param name="i">Номер значения</param>
            <returns>Значение аргумента с указанным номером</returns>
        </member>
        <member name="M:MathService.CommandProcessor.Argument.#ctor(System.String,System.Char)">
            <summary>Аргумент команды</summary>
            <param name="ArgStr">Строковое описание аргумента</param>
            <param name="ValueSplitter">Разделитель имени аргумента и значения</param>
        </member>
        <member name="M:MathService.CommandProcessor.Argument.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление аргумента</returns>
        </member>
        <member name="T:MathService.CommandProcessor.Command">
            <summary>Команда</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Command.Name">
            <summary>Имя команды</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Command.Parameter">
            <summary>Параметр команды</summary>
        </member>
        <member name="P:MathService.CommandProcessor.Command.Argument">
            <summary>Массив аргументов команды</summary>
        </member>
        <member name="M:MathService.CommandProcessor.Command.#ctor(System.String,System.Char,System.Char,System.Char)">
            <summary>Команда</summary>
            <param name="CommandStr">Строковое представление команды</param>
            <param name="ParameterSplitter">Разделитель имени и параметра команды</param>
            <param name="ArgSplitter">Разделитель аргументов команды</param>
            <param name="ValueSplitter">Разделитель имени аргумента и его значения</param>
        </member>
        <member name="M:MathService.CommandProcessor.Command.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление команды</returns>
        </member>
        <member name="T:MathService.CommandProcessor.CommandEventArgs">
            <summary>Аргумент события обработки команды</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandEventArgs.Command">
            <summary>Обрабатываемая команда</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandEventArgs.Commands">
            <summary>Перечень команд сессии</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandEventArgs.Index">
            <summary>Индекс команды в перечне команд сессии</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandEventArgs.Handled">
            <summary>Признак того, что команда обработана</summary>
        </member>
        <member name="M:MathService.CommandProcessor.CommandEventArgs.ToString">
            <summary>Строковое представление</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="T:MathService.CommandProcessor.CommandHandlersList">
            <summary>Список обработчиков команды</summary>
        </member>
        <member name="M:MathService.CommandProcessor.CommandHandlersList.op_Addition(MathService.CommandProcessor.CommandHandlersList,System.Action{MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[]})">
            <summary>Оператор добалвения команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="handler">Добавляемый обработчик команды</param>
            <returns>Список с добавленным обработчиком команды</returns>
        </member>
        <member name="M:MathService.CommandProcessor.CommandHandlersList.op_Subtraction(MathService.CommandProcessor.CommandHandlersList,System.Action{MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[]})">
            <summary>Оператор удаления команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="handler">Удаляемый обработчик команды</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="M:MathService.CommandProcessor.CommandArgHandlersList.op_Addition(MathService.CommandProcessor.CommandArgHandlersList,System.Action{MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[],MathService.CommandProcessor.Argument})">
            <summary>Оператор добалвения команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="handler">Добавляемый обработчик команды</param>
            <returns>Список с добавленным обработчиком команды</returns>
        </member>
        <member name="M:MathService.CommandProcessor.CommandArgHandlersList.op_Subtraction(MathService.CommandProcessor.CommandArgHandlersList,System.Action{MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[],MathService.CommandProcessor.Argument})">
            <summary>Оператор удаления команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="handler">Удаляемый обработчик команды</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="T:MathService.CommandProcessor.CommandLineProcessor">
            <summary>Командный процессор</summary>
        </member>
        <member name="E:MathService.CommandProcessor.CommandLineProcessor.CommandProcess">
            <summary>Событие обработки команды</summary>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.OnCommandProcess(MathService.CommandProcessor.CommandEventArgs)">
            <summary>Обработка команды</summary>
            <param name="Arg">Аргумент, содержащий сведенья о команде</param>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.OnCommandProcess(MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[])">
            <summary>Обработка команды</summary>
            <param name="command">Обрабатываемая команда</param>
            <param name="index">Индекс команды в массиве команд сессии</param>
            <param name="commands">Массив команд сессии</param>
        </member>
        <member name="E:MathService.CommandProcessor.CommandLineProcessor.UnhandledCommand">
            <summary>Событие появления необработанной команды</summary>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.OnUnhandledCommand(MathService.CommandProcessor.CommandEventArgs)">
            <summary>Генерация события обнаружения необработанной команды</summary>
            <param name="Arg">Аргумент события, содержащий сведенья о команде</param>
        </member>
        <member name="F:MathService.CommandProcessor.CommandLineProcessor._CommandHandlers">
            <summary>Словарь списков обработчиков команд</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandLineProcessor.CommandSplitter">
            <summary>Разделитель команд в строке</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandLineProcessor.CommandParameterSplitter">
            <summary>Разделитель имени команды и её параметра</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandLineProcessor.ArgSplitter">
            <summary>Разделитель аргументов команды</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandLineProcessor.ValueSplitter">
            <summary>Разделитель имени аргумента и его значения</summary>
        </member>
        <member name="P:MathService.CommandProcessor.CommandLineProcessor.Item(System.String)">
            <summary>Доступ к списку обработчиков команды по её имени</summary>
            <param name="CommandName">Имя команды</param>
            <returns>Список обработчиков команды</returns>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.#ctor(System.Char,System.Char,System.Char,System.Char)">
            <summary>Командный процессор</summary>
            <param name="CommandSplitter">Разделитель команд в строке</param>
            <param name="CommandParameterSplitter">Разделитель имени команды и её параметра</param>
            <param name="ArgSplitter">Разделитель аргументов</param>
            <param name="ValueSplitter">Разделитель имени аргумента и его значения</param>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.Process(System.String[])">
            <summary>Обработать команду</summary>
            <param name="CommandLine">Командная строка</param>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.AddCommandHandler(System.String,System.Action{MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[]})">
            <summary>Добавить обработчик команды</summary>
            <param name="CommandName">Имя команды</param>
            <param name="CommandHandler">ДОбавляемый обработчик команды</param>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.RemoveCommandHandler(System.String,System.Action{MathService.CommandProcessor.Command,System.Int32,MathService.CommandProcessor.Command[]})">
            <summary>Удалить обработчик команды</summary>
            <param name="CommandName">Имя команды</param>
            <param name="CommandHandler">Удаляемый обработчик команды</param>
            <returns>Истина, если удалось обработчик команды удалить</returns>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.ClaerCommandHandlers(System.String)">
            <summary>Очистить список обработчиков команды</summary>
            <param name="CommandName">Имя команды</param>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.ClaerCommandHandlers">
            <summary>Очистить все обработчики команд</summary>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.GetRegistredCommands">
            <summary>Получить перечисление имён команд с зарегистрированными обработчиками</summary>
            <returns>Перечисление имён команд, имеющих свои обработчики</returns>
        </member>
        <member name="M:MathService.CommandProcessor.CommandLineProcessor.IsRegistredCommand(System.String)">
            <summary>Проверка - имеет ли команда обработчики</summary>
            <param name="CommandName">Проверяемая команда</param>
            <returns>Истина, если указаны обработчики команды</returns>
        </member>
        <member name="T:MathService.CommandProcessor.TestCommandLineProcessor">
            <summary>Пример использования класса команданого процессора</summary>
        </member>
        <member name="P:MathService.CommandProcessor.TestCommandLineProcessor.Work">
            <summary>Флаг обработки запросов пользователя</summary>
        </member>
        <member name="P:MathService.CommandProcessor.TestCommandLineProcessor.Prompt">
            <summary>Приглашение командной строки</summary>
        </member>
        <member name="M:MathService.CommandProcessor.TestCommandLineProcessor.Test">
            <summary>Точка входа в пример</summary>
        </member>
        <member name="M:MathService.CommandProcessor.TestCommandLineProcessor.UnknownCommandInformator(System.Object,MathService.CommandProcessor.CommandEventArgs)">
            <summary>Обработчик необработанных команд</summary>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент, содержащий информацию о необработанной команде</param>
        </member>
        <member name="M:MathService.CommandProcessor.TestCommandLineProcessor.ExecuteCommand(System.Object,MathService.CommandProcessor.CommandEventArgs)">
            <summary>Обработчик команды</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргумент, содержащий информацию о команде</param>
        </member>
        <member name="M:MathService.CommandProcessor.TestCommandLineProcessor.SetArgument(MathService.CommandProcessor.Argument)">
            <summary>Метод установки значения команды Set</summary>
            <param name="SetArg">Аргумент команды Set</param>
        </member>
        <member name="M:MathService.Data.DataLength.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathService.Data.DataLength.ToString(System.String)">
            <inheritdoc />
        </member>
        <member name="M:MathService.Data.DataLength.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="T:MathService.Data.PropertyLink`2">
            <summary>Связь между свойствами</summary>
            <typeparam name="TSource">Тип объекта-источника данных</typeparam>
            <typeparam name="TDestination">Тип объекта-приёмника данных</typeparam>
        </member>
        <member name="F:MathService.Data.PropertyLink`2._Source">
            <summary>
            Источник данных
            </summary>
        </member>
        <member name="F:MathService.Data.PropertyLink`2._Destination">
            <summary>
            Приёмник данных
            </summary>
        </member>
        <member name="F:MathService.Data.PropertyLink`2._SourcePropertyDescriptor">
            <summary>
            Дескриптор свойства источника данных
            </summary>
        </member>
        <member name="F:MathService.Data.PropertyLink`2._DestinationPropertyDescriptor">
            <summary>
            Дескриптор свойства приёмника данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.Source">
            <summary>
            Источник данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.Destination">
            <summary>
            Приёмник данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.SourceProperty">
            <summary>
            Дескриптор свойства источника данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.DestinationProperty">
            <summary>
            Дескриптор свйоства примника данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.SourceType">
            <summary>
            Источник данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.DestinationType">
            <summary>
            Приёмник данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.SourcePropertyType">
            <summary>
            Тип свйоства источника данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.DestinationPropertyType">
            <summary>
            Тип свойства приёмника данных
            </summary>
        </member>
        <member name="P:MathService.Data.PropertyLink`2.Enable">
            <summary>
            Активатор связи
            </summary>
        </member>
        <member name="M:MathService.Data.PropertyLink`2.#ctor(`0,System.String,`1,System.String,System.Boolean)">
            <summary>
            Новая связь между свойством источника и приёмника данных
            </summary>
            <param name="Source">Источник данных</param>
            <param name="SourcePropertyName">Имя свойства источника данных</param>
            <param name="Destination">Приёмник данных</param>
            <param name="DestinationPropertyName">Имя свойства приёмника данных</param>
            <param name="Enable">Признак активности связи (по умолчанию = true)</param>
        </member>
        <member name="M:MathService.Data.PropertyLink`2.SourcePropertyChanged(System.Object,System.EventArgs)">
            <summary>
            Обработчик события изменения свойства источника данных
            </summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="T:MathService.DifferencialEquations.Numerical.ArgumentFunction">
            <summary>Функция определения аргумента</summary>
            <param name="t">Параметр</param>
            <returns>Вектор аргумента уравнения</returns>
        </member>
        <member name="T:MathService.DifferencialEquations.Numerical.Eyler">
            <summary>
            Метод Рунге-Кутты
            </summary>
        </member>
        <member name="P:MathService.DifferencialEquations.Numerical.Eyler.N">
            <summary>
            Размерность системы
            </summary>
        </member>
        <member name="P:MathService.DifferencialEquations.Numerical.Eyler.Y">
            <summary>
            Искомые решения
            </summary>
        </member>
        <member name="P:MathService.DifferencialEquations.Numerical.Eyler.t">
            <summary>
            Текущее время
            </summary>
        </member>
        <member name="M:MathService.DifferencialEquations.Numerical.Eyler.#ctor(System.Int32,MathService.DifferencialEquations.Numerical.DifferencialEquationsSystem,MathService.DifferencialEquations.Numerical.ArgumentFunction)">
            <summary>
            Метод Рунге-Кутты
            </summary>
            <param name="N">Размерность</param>
            <param name="System">Решаемая система</param>
            <param name="X">Производящая функция аргумента</param>
        </member>
        <member name="M:MathService.DifferencialEquations.Numerical.Eyler.Initialize(System.Double,System.Double[])">
            <summary>
            Начальные условия
            </summary>
            <param name="t0">Начальное время</param>
            <param name="Y0">Начальные условия</param>
        </member>
        <member name="M:MathService.DifferencialEquations.Numerical.Eyler.NextStep(System.Double)">
            <summary>
            Рассчёт решения
            </summary>
            <param name="dt">Шаг</param>
        </member>
        <member name="T:MathService.DifferencialEquations.Numerical.DifferencialEquationsSystem">
            <summary> Система дифференциальных уравнений</summary>
            <param name="X">Аргумент</param>
            <param name="Y">Значения функции</param>
            <returns>Значения производных</returns>
        </member>
        <member name="T:MathService.DifferencialEquations.Numerical.RungeKutta">
            <summary>
            Метод Рунге-Кутты
            </summary>
        </member>
        <member name="P:MathService.DifferencialEquations.Numerical.RungeKutta.N">
            <summary>
            Размерность системы
            </summary>
        </member>
        <member name="P:MathService.DifferencialEquations.Numerical.RungeKutta.Y">
            <summary>
            Искомые решения
            </summary>
        </member>
        <member name="P:MathService.DifferencialEquations.Numerical.RungeKutta.t">
            <summary>
            Текущее время
            </summary>
        </member>
        <member name="M:MathService.DifferencialEquations.Numerical.RungeKutta.#ctor(System.Int32,MathService.DifferencialEquations.Numerical.DifferencialEquationsSystem,MathService.DifferencialEquations.Numerical.ArgumentFunction)">
            <summary>
            Метод Рунге-Кутты
            </summary>
            <param name="N">Размерность</param>
            <param name="System">Решаемая система</param>
            <param name="X">Производящая функция аргумента</param>
        </member>
        <member name="M:MathService.DifferencialEquations.Numerical.RungeKutta.Initialize(System.Double,System.Double[])">
            <summary>
            Начальные условия
            </summary>
            <param name="t0">Начальное время</param>
            <param name="Y0">Начальные условия</param>
        </member>
        <member name="M:MathService.DifferencialEquations.Numerical.RungeKutta.NextStep(System.Double)">
            <summary>
            Рассчёт решения
            </summary>
            <param name="dt">Шаг</param>
        </member>
        <member name="T:MathService.DSP.Filters.AllPassFilter">
            <summary>Всепропускающий фильльт</summary>
        </member>
        <member name="T:MathService.DSP.Filters.CombFilter">
            <summary>Гребенчатый фильтр</summary>
        </member>
        <member name="M:MathService.DSP.Filters.CombFilter.#ctor(System.Int32)">
            <summary>Новый гребенчатый фильтр</summary>
            <param name="D">Задержка</param>
        </member>
        <member name="T:MathService.DSP.Filters.HighPassRC">
            <summary>Цифровой ФВЧ на основе C-R цепочки с билинейным преобразованием</summary>
        </member>
        <member name="M:MathService.DSP.Filters.HighPassRC.#ctor(System.Double,System.Double)">
            <summary>Инициализация нового цифрового ФВЧ на основе CR-цепочики с билинейным преобразованием</summary>
            <param name="f0">Частота среза</param>
            <param name="dt">Период дискретизации</param>
        </member>
        <member name="T:MathService.DSP.Filters.LowPassRC">
            <summary>Цифровой ФНЧ на основе R-C цепочки с билинейным преобразованием</summary>
        </member>
        <member name="M:MathService.DSP.Filters.LowPassRC.#ctor(System.Double,System.Double)">
            <summary>Инициализация нового цифрового ФНЧ на основе RC-цепочики с билинейным преобразованием</summary>
            <param name="f0">Частота среза</param>
            <param name="dt">Период дискретизации</param>
        </member>
        <member name="T:MathService.DSP.Filters.DigitalFilter">
            <summary>Цифровой фильтр</summary>
        </member>
        <member name="M:MathService.DSP.Filters.DigitalFilter.ToAnalogFrequency(System.Double,System.Double)">
            <summary>Преобразование частоты цифрового фильтра в частоту аналогового прототипа</summary>
            <param name="DigitalFrequency">Значение на оси частот цифрового фильтра</param>
            <param name="dt">Период дискретизации</param>
            <returns>Значение на оси частот аналогового прототипа</returns>
        </member>
        <member name="F:MathService.DSP.Filters.DigitalFilter.State">
            <summary>Вектор состояния</summary>
        </member>
        <member name="P:MathService.DSP.Filters.DigitalFilter.Order">
            <summary>Порядок фильтра</summary>
        </member>
        <member name="M:MathService.DSP.Filters.DigitalFilter.#ctor(System.Int32)">
            <summary>Инициализация нового цифрового фильтра</summary>
            <param name="Order">Порядок фильтра</param>
        </member>
        <member name="M:MathService.DSP.Filters.DigitalFilter.Process(System.Double,System.Double[])">
            <summary>Обработать очередной отсчёт цифрового сигнала</summary>
            <param name="sample">Обрабатываемый отсчёт цифрового сигнала</param>
            <param name="state">Вектор состояния фильтра</param>
            <returns>Значение сигнала на выходе фильтра после обработки отсчёта</returns>
        </member>
        <member name="M:MathService.DSP.Filters.DigitalFilter.Process(System.Double)">
            <summary>Обработать отсчёт цифрового сигнала</summary>
            <param name="sample">Обрабатываемый отсчёт цифрового сигнала</param>
            <returns>Значение сигнала на выходе фильтра после обработки отсчёта</returns>
        </member>
        <member name="M:MathService.DSP.Filters.DigitalFilter.Reset">
            <summary>Сбросить состояние фильтра</summary>
        </member>
        <member name="T:MathService.DSP.Filters.FIR">
            <summary>Фильтр с конечной импульсной характеристикой</summary>
        </member>
        <member name="F:MathService.DSP.Filters.FIR._ImpulseResponse">
            <summary>Импульсная характеристика</summary>
        </member>
        <member name="P:MathService.DSP.Filters.FIR.ImpulseResponse">
            <summary>Импульсная характеристика</summary>
        </member>
        <member name="M:MathService.DSP.Filters.FIR.#ctor(System.Double[])">
            <summary>Инициализация нового цифрового фильтра с конечной импульсной характеристикой</summary>
            <param name="ImpulseResponse">Отсчёты импульсной характеристики фильтра</param>
        </member>
        <member name="T:MathService.DSP.Filters.IIR">
            <summary>Фильтр с бесконечной импульсной характеристикой</summary>
        </member>
        <member name="F:MathService.DSP.Filters.IIR._B">
            <summary>Массив кооэффициентов полинома числителя</summary>
        </member>
        <member name="F:MathService.DSP.Filters.IIR._A">
            <summary>Массив коэффициентов полинома знаменателя</summary>
        </member>
        <member name="P:MathService.DSP.Filters.IIR.B">
            <summary>Массив кооэффициентов полинома числителя</summary>
        </member>
        <member name="P:MathService.DSP.Filters.IIR.A">
            <summary>Массив коэффициентов полинома знаменателя</summary>
        </member>
        <member name="M:MathService.DSP.Filters.IIR.#ctor(System.Double[],System.Double[])">
            <summary>Инициализация нового цифрового фильтра с бесконечной импульсной характеристикой</summary>
            <param name="B">Массив кооэффициентов полинома числителя</param>
            <param name="A">Массив коэффициентов полинома знаменателя</param>
        </member>
        <member name="T:MathService.DSP.Filters.ExponetialLowPassRC">
            <summary>Цифровой ФНЧ на основе R-C цепочки</summary>
        </member>
        <member name="M:MathService.DSP.Filters.ExponetialLowPassRC.#ctor(System.Double,System.Double)">
            <summary>Инициализация нового цифрового ФНЧ на основе RC-цепочики</summary>
            <param name="f0">Частота среза</param>
            <param name="dt">Период дискретизации</param>
        </member>
        <member name="M:MathService.DSP.Fourier.fft.FFT(MathService.Complex[])">
            <summary>
            Быстрое комплексное одномерное преобразование Фурье
            </summary>
            <param name="x">Вектор комплексных значений, преобразуемый в спектр</param>
            <remarks>
            Размер массива N может быть произвольным числом (составным или простым). 
            Составной N будут обработаны с использованием вариативного алгоритма Кули-Тьюки с кешированием.
            Массивы, размер которых соответствует малому простому числу преобразуются с помощью жестко сода
            (по аналогии с кодом FFTW, но без оптимизации низкого уровня), большое простое число элементов 
            обрабатывается с помощью алгоритма Блустейна.
            
            Быстрые преобразования для гладких N (только простые множители 2, 3, 5), самый быстрый для степеней 2. 
            При N имеющих простые множители большие, чем эти, но порядка меньше, чем N, вычисления 
            будут примерно в 4 раза медленнее, чем для близких высоко составных N. 
            Когда N является простым, скорость будет в 6 раз меньше.
            
            Алгоритмическая сложность O(N*logN) для любых N
            </remarks>
        </member>
        <member name="M:MathService.DSP.Fourier.fft.FFT_Complex_Inverse(MathService.Complex[])">
            <summary>
            Быстрое обратное комплексное одномерное преобразование Фурье
            </summary>
            <param name="y">Массив значений спектра</param>
        </member>
        <member name="M:MathService.DSP.Fourier.fft.FFT(System.Double[])">
            <summary>
            Быстрое одномерное вещественное преобразование Фурье
            </summary>
            <param name="x">Массив входных значений</param>
            <value>Массив комплексных значений спектра</value>
        </member>
        <member name="T:MathService.DSP.Fourier.DoubleArray_FT">
            <summary>
            
            </summary>
        </member>
        <member name="T:MathService.DSP.Fourier.FFT">
            <summary>Быстрое преобразование Фурье</summary>
        </member>
        <member name="M:MathService.DSP.Fourier.FFT.FastFourierTransform(System.Double[])">
            <summary>Прямое преобразование отсчётов функции в спектр</summary>
            <param name="Values">Массив отсчётов функции</param>
        </member>
        <member name="M:MathService.DSP.Fourier.FFT.FastFourierTransform(MathService.Complex[])">
            <summary>Прямое преобразование отсчётов функции в спектр</summary>
            <param name="Values">Массив отсчётов функции</param>
        </member>
        <member name="M:MathService.DSP.Fourier.FFT.FastFurierInverse(MathService.Complex[])">
            <summary>Обратное преобразование отсчётов спектра в отсчёты сигнала</summary>
            <param name="Spectrum">Массив отсчётов спектра</param>
        </member>
        <member name="M:MathService.DSP.Fourier.FFT.FFT_int(System.Int32[],System.Boolean)">
            <summary>
            Целочисленное преобразование Фурье
            </summary>
            <param name="a">Массив целых чисел</param>
            <param name="invert">Обратное преобразование</param>
        </member>
        <member name="T:MathService.DSP.Fourier.FT">
            <summary>Класс преобразования Фурье</summary>
        </member>
        <member name="M:MathService.DSP.Fourier.FT.FourierTransform(System.Double[],System.Boolean)">
            <summary>Прямое преобразование отсчётов функции в спектр</summary>
            <param name="Values">Массив отсчётов функции</param>
            <param name="IsInverse">Обратное преобразование</param>
        </member>
        <member name="M:MathService.DSP.Fourier.FT.FourierTransform(System.Double[],System.Boolean,System.Action{System.Double})">
            <summary>Прямое преобразование отсчётов функции в спектр</summary>
            <param name="Values">Массив отсчётов функции</param>
            <param name="IsInverse">Обратное преобразование</param>
            <param name="progress">Метод информирования о прогрессе операции</param>
        </member>
        <member name="M:MathService.DSP.Fourier.FT.FourierTransform(MathService.Complex[],System.Boolean)">
            <summary>Прямое преобразование отсчётов функции в спектр</summary>
            <param name="Values">Массив отсчётов функции</param>
            <param name="Inverse">Обратное преобразование</param>
        </member>
        <member name="M:MathService.DSP.Fourier.FT.FourierTransform(MathService.Complex[],System.Boolean,System.Action{System.Double})">
            <summary>Прямое преобразование отсчётов функции в спектр</summary>
            <param name="Values">Массив отсчётов функции</param>
            <param name="Inverse">Обратное преобразование</param>
        </member>
        <member name="T:MathService.Evulations.AdditionEvulation`1">
            <summary>Вычисление суммы двух вычислений</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathService.Evulations.AdditionEvulation`1.#ctor">
            <summary>Инициализация нового вычисления суммы двух вычислений</summary>
        </member>
        <member name="M:MathService.Evulations.AdditionEvulation`1.#ctor(MathService.Evulations.Evulation{`0},MathService.Evulations.Evulation{`0})">
            <summary>Инициализация нового вычисления суммы двух вычислений</summary>
            <param name="a">Вычисление первого слогаемого</param>
            <param name="b">Вычисление второго слогаемого</param>
        </member>
        <member name="T:MathService.Evulations.BinaryFunctionOperationEvulation`1">
            <summary>Вычисление бинарной опирации между двумя вычислениями</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="P:MathService.Evulations.BinaryFunctionOperationEvulation`1.A">
            <summary>Первый операнд вычисления</summary>
        </member>
        <member name="P:MathService.Evulations.BinaryFunctionOperationEvulation`1.B">
            <summary>Второй операнд вычисления</summary>
        </member>
        <member name="P:MathService.Evulations.BinaryFunctionOperationEvulation`1.Operation">
            <summary>Метод вычисления значения вычисления</summary>
        </member>
        <member name="M:MathService.Evulations.BinaryFunctionOperationEvulation`1.#ctor">
            <summary>Инициализация нового бинарного вычисления</summary>
        </member>
        <member name="M:MathService.Evulations.BinaryFunctionOperationEvulation`1.#ctor(System.Func{`0,`0,`0})">
            <summary>Инициализация нового бинарного вычисления</summary>
            <param name="Operation">Метод вычисления результата вычисления на основе результатов вычисления значений операндов</param>
        </member>
        <member name="M:MathService.Evulations.BinaryFunctionOperationEvulation`1.#ctor(System.Func{`0,`0,`0},MathService.Evulations.Evulation{`0},MathService.Evulations.Evulation{`0})">
            <summary>Инициализация нового бинарного вычисления</summary>
            <param name="Operation">Метод вычисления результата вычисления на основе результатов вычисления значений операндов</param>
            <param name="A">Первый операнд вычисления</param>
            <param name="B">Второй операнд вычисления</param>
        </member>
        <member name="M:MathService.Evulations.BinaryFunctionOperationEvulation`1.GetValue">
            <inheritdoc />
        </member>
        <member name="M:MathService.Evulations.BinaryFunctionOperationEvulation`1.GetExpression">
            <inheritdoc />
        </member>
        <member name="T:MathService.Evulations.BinaryFunctionOperatorEvulation`1">
            <summary>Вычисление функционального бинарного оператора между двумя вычислениями</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathService.Evulations.BinaryFunctionOperatorEvulation`1.GetOperatorFunction(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.BinaryExpression})">
            <summary>Метод получения функции, расчитывающей значение оператора для двух известных значений вычислений</summary>
            <param name="OP">Функция, преобразующая два выражения в бинарный оператор, позволящий расчитать значение операции между двумя значениями операндов</param>
            <returns>Метод вычисления значения оператора на основе значений двух его операндов</returns>
        </member>
        <member name="F:MathService.Evulations.BinaryFunctionOperatorEvulation`1._Operator">
            <summary>Функция объекдинения двух выражений в бинарный оператор расчёта значения</summary>
        </member>
        <member name="M:MathService.Evulations.BinaryFunctionOperatorEvulation`1.#ctor(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.BinaryExpression})">
            <summary>Инициализация нового функционального бинарного оператора вычисления</summary>
            <param name="Operator">Функция, определяющая как объекдинить два выражения операндов в бинарный оператор</param>
        </member>
        <member name="M:MathService.Evulations.BinaryFunctionOperatorEvulation`1.#ctor(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.BinaryExpression},MathService.Evulations.Evulation{`0},MathService.Evulations.Evulation{`0})">
            <summary>Инициализация нового функционального бинарного оператора на основе функции генерации бинарного оператора и двух вычислений операндов</summary>
            <param name="Operator">Функция, определяющая как объекдинить два выражения операндов в бинарный оператор</param>
            <param name="a">Вычисление первого операнда</param>
            <param name="b">Вычисление аоторого операнда</param>
        </member>
        <member name="M:MathService.Evulations.BinaryFunctionOperatorEvulation`1.GetExpression">
            <inheritdoc />
        </member>
        <member name="T:MathService.Evulations.ConvertEvulation`2">
            <summary>Вычисление преобразования типов</summary>
            <typeparam name="TInput">Тип входного значения</typeparam>
            <typeparam name="TOutput">Тип выходного значения</typeparam>
        </member>
        <member name="P:MathService.Evulations.ConvertEvulation`2.InputEvulation">
            <summary>Вычисление входного значения</summary>
        </member>
        <member name="P:MathService.Evulations.ConvertEvulation`2.Converter">
            <summary>Функция-преобразователь типов входного в выходное значение</summary>
        </member>
        <member name="M:MathService.Evulations.ConvertEvulation`2.#ctor">
            <summary>Инициализация нового вычисления преобразования типов</summary>
        </member>
        <member name="M:MathService.Evulations.ConvertEvulation`2.#ctor(System.Func{`0,`1})">
            <summary>Инициализация нового вычисления преобразования типов</summary>
            <param name="Converter">Метод преобразования входного значения в выходное</param>
        </member>
        <member name="M:MathService.Evulations.ConvertEvulation`2.#ctor(MathService.Evulations.Evulation{`0},System.Func{`0,`1})">
            <summary>Инициализация нового вычисления преобразования типов</summary>
            <param name="InputEvulation">Вычисление входного значения</param>
            <param name="Converter">Метод преобразования входного значения в выходное</param>
        </member>
        <member name="M:MathService.Evulations.ConvertEvulation`2.GetValue">
            <inheritdoc />
        </member>
        <member name="M:MathService.Evulations.ConvertEvulation`2.GetExpression">
            <inheritdoc />
        </member>
        <member name="T:MathService.Evulations.DivideEvulation`1">
            <summary>Вычисление деления двух вычислений</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathService.Evulations.DivideEvulation`1.#ctor">
            <summary>Инициализация нового вычисления деления</summary>
        </member>
        <member name="M:MathService.Evulations.DivideEvulation`1.#ctor(MathService.Evulations.Evulation{`0},MathService.Evulations.Evulation{`0})">
            <summary>Инициализация нового вычисления деления</summary>
            <param name="a">Вычисление делимого</param>
            <param name="b">Вычисление делителя</param>
        </member>
        <member name="T:MathService.Evulations.Evulation">
            <summary>Вычисление</summary>
        </member>
        <member name="M:MathService.Evulations.Evulation.GetExpression">
            <summary>Получить выражение вычисления</summary>
            <returns>Возвращает выражение, соответствующее данному вычислению</returns>
        </member>
        <member name="M:MathService.Evulations.Evulation.op_Implicit(MathService.Evulations.Evulation)~System.Linq.Expressions.Expression">
            <summary>Оператор неявного преобразования вычисления в выражение</summary>
            <param name="evulation">Преобразвуемое вычисление</param>
        </member>
        <member name="T:MathService.Evulations.Evulation`1">
            <summary>Вычисление с результатом типа <typeparamref name="T"/></summary>
            <typeparam name="T">Тип результата вычисления</typeparam>
        </member>
        <member name="M:MathService.Evulations.Evulation`1.GetValue">
            <summary>Получить значение</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.Evulations.Evulation`1.GetExpression">
            <summary>Получить выражение вычисления</summary>
            <returns>Выражение, определяющие вычисление</returns>
        </member>
        <member name="M:MathService.Evulations.Evulation`1.op_Implicit(MathService.Evulations.Evulation{`0})~`0">
            <summary>Оператор неявного преобразования вычисления в выражение</summary>
            <param name="evulation">Преобразвуемое вычисление</param>
        </member>
        <member name="M:MathService.Evulations.Evulation`1.op_Addition(MathService.Evulations.Evulation{`0},MathService.Evulations.Evulation{`0})">
            <summary>Оператор сложения двух вычислений</summary>
            <param name="x">Первое слогаемое</param>
            <param name="y">Второе слогаемое</param>
            <returns>Вычисление суммы двух вычислений</returns>
        </member>
        <member name="M:MathService.Evulations.Evulation`1.op_Subtraction(MathService.Evulations.Evulation{`0},MathService.Evulations.Evulation{`0})">
            <summary>Вычисление разности двух вычислений</summary>
            <param name="x">Уменьшаемое</param>
            <param name="y">Вычитаемое</param>
            <returns>Вычисление разности двух вычислений</returns>
        </member>
        <member name="M:MathService.Evulations.Evulation`1.op_UnaryNegation(MathService.Evulations.Evulation{`0})">
            <summary>Оператор получения отрицательного значения на основе вычисления</summary>
            <param name="x">Вычисление значения оператора</param>
            <returns>Оператор получения отрицательного значения</returns>
        </member>
        <member name="M:MathService.Evulations.Evulation`1.op_Multiply(MathService.Evulations.Evulation{`0},MathService.Evulations.Evulation{`0})">
            <summary>Вычисление произведения двух вычислений</summary>
            <param name="x">Первый сомножитель</param>
            <param name="y">Второй сомножитель</param>
            <returns>Вычисление произведения двух вычислений</returns>
        </member>
        <member name="M:MathService.Evulations.Evulation`1.op_Division(MathService.Evulations.Evulation{`0},MathService.Evulations.Evulation{`0})">
            <summary>Вычисление частного двух вычислений</summary>
            <param name="x">Делимое</param>
            <param name="y">Делитель</param>
            <returns>Вычисление частного двух вычислений</returns>
        </member>
        <member name="T:MathService.Evulations.FieldValueEvulation`2">
            <summary>Вычисление значения поля объекта</summary>
            <typeparam name="TObject">Тип объекта, поле которого надо получить</typeparam>
            <typeparam name="TValue">Тип значения поля</typeparam>
        </member>
        <member name="M:MathService.Evulations.FieldValueEvulation`2.#ctor(System.String)">
            <summary>Инициализация нового вычисления значения поля объекта</summary>
            <param name="PropertyName">Имя поля</param>
        </member>
        <member name="M:MathService.Evulations.FieldValueEvulation`2.#ctor(MathService.Evulations.Evulation{`0},System.String)">
            <summary>Инициализация нового вычисления поля объекта</summary>
            <param name="obj">Вычисление объекта, поле которого надо получить</param>
            <param name="FieldName">Имя поля объекта</param>
        </member>
        <member name="T:MathService.Evulations.FunctionEvulation`1">
            <summary>Вычисление функции без переменных</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MathService.Evulations.FunctionEvulation`1.Function">
            <summary>Вычисляемая функция</summary>
        </member>
        <member name="M:MathService.Evulations.FunctionEvulation`1.#ctor">
            <summary>Инициализация нового вычисления функции</summary>
        </member>
        <member name="M:MathService.Evulations.FunctionEvulation`1.#ctor(System.Func{`0})">
            <summary>Инициализация нового вычисления функции</summary>
            <param name="Function">Вычисляемая функция</param>
        </member>
        <member name="M:MathService.Evulations.FunctionEvulation`1.GetValue">
            <inheritdoc />
        </member>
        <member name="M:MathService.Evulations.FunctionEvulation`1.GetExpression">
            <inheritdoc />
        </member>
        <member name="M:MathService.Evulations.FunctionEvulation`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathService.Evulations.FunctionEvulation`1.op_Implicit(System.Func{`0})~MathService.Evulations.FunctionEvulation{`0}">
            <summary>Оператор неявного преобразования типа функции к типу вычисления функции</summary>
            <param name="Function">Оборачиваемая функция</param>
        </member>
        <member name="T:MathService.Evulations.NamedFunctionEvulation`1">
            <summary>Именованное вычисление функции</summary>
            <typeparam name="T">Тип значения функции</typeparam>
        </member>
        <member name="P:MathService.Evulations.NamedFunctionEvulation`1.Name">
            <summary>Имя функции</summary>
        </member>
        <member name="M:MathService.Evulations.NamedFunctionEvulation`1.#ctor">
            <summary>Инициализация нового вычисления значения функции</summary>
        </member>
        <member name="M:MathService.Evulations.NamedFunctionEvulation`1.#ctor(System.Func{`0})">
            <summary>Инициализация нового вычисления значения функции</summary>
            <param name="Function">Вычисляемая функция</param>
        </member>
        <member name="M:MathService.Evulations.NamedFunctionEvulation`1.#ctor(System.Func{`0},System.String)">
            <summary>Инициализация нового вычисления значения функции</summary>
            <param name="Function">Вычисляемая функция</param>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathService.Evulations.NamedFunctionEvulation`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathService.Evulations.MultiplyEvulation`1">
            <summary>Вычисление произведения двух вычислений</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathService.Evulations.MultiplyEvulation`1.#ctor">
            <summary>Инициализация нового вычисления произведения</summary>
        </member>
        <member name="M:MathService.Evulations.MultiplyEvulation`1.#ctor(MathService.Evulations.Evulation{`0},MathService.Evulations.Evulation{`0})">
            <summary>Инициализация нового вычисления произведения</summary>
            <param name="a">Вычисление первого сомножителя</param>
            <param name="b">Вычисление второго сомножителя</param>
        </member>
        <member name="T:MathService.Evulations.NegateOperatorEvulation`1">
            <summary>Вычисление отрицания значения</summary>
            <typeparam name="T">Тип значения параметра</typeparam>
        </member>
        <member name="M:MathService.Evulations.NegateOperatorEvulation`1.#ctor">
            <summary>Инициализация нового вычисления отризацания</summary>
        </member>
        <member name="M:MathService.Evulations.NegateOperatorEvulation`1.#ctor(MathService.Evulations.Evulation{`0})">
            <summary>Инициализация нового вычисления отрицания</summary>
            <param name="value">Вычисление значения операнда</param>
        </member>
        <member name="T:MathService.Evulations.PropertyValueEvulation`2">
            <summary>Вычисление значения свойства объекта</summary>
            <typeparam name="TObject">Тип объекта, свойство которого надо получить</typeparam>
            <typeparam name="TValue">Тип значения свойства</typeparam>
        </member>
        <member name="M:MathService.Evulations.PropertyValueEvulation`2.#ctor(System.String)">
            <summary>Инициализация нового вычисления значения свойства объекта</summary>
            <param name="PropertyName">Имя свойства</param>
        </member>
        <member name="M:MathService.Evulations.PropertyValueEvulation`2.#ctor(MathService.Evulations.Evulation{`0},System.String)">
            <summary>Инициализация нового вычисления свйоства объекта</summary>
            <param name="obj">Вычисление объекта, свойство которого надо получить</param>
            <param name="PropertyName">Имя свойства объекта</param>
        </member>
        <member name="T:MathService.Evulations.SubtractEvulation`1">
            <summary>Вычисление разности двух вычислений</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathService.Evulations.SubtractEvulation`1.#ctor">
            <summary>Инициализация нового вычисления разности</summary>
        </member>
        <member name="M:MathService.Evulations.SubtractEvulation`1.#ctor(MathService.Evulations.Evulation{`0},MathService.Evulations.Evulation{`0})">
            <summary>Инициализация нового вычисления разности</summary>
            <param name="a">Вычисление первого сомножителя</param>
            <param name="b">Вычисление второго сомножителя</param>
        </member>
        <member name="T:MathService.Evulations.UnaryOperatorEvulation`2">
            <summary>Вычисление операции с одним операндом</summary>
            <typeparam name="TObject">Тип значения операнда</typeparam>
            <typeparam name="TValue">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathService.Evulations.UnaryOperatorEvulation`2.GetOperation(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>Метод, генерирующий функция преобразования значения операнда в значение вычисления</summary>
            <param name="OP">Функция преобразования выражения, вычисляющего значение операнда, в выражение, определяющее значение вычисления</param>
            <returns></returns>
        </member>
        <member name="F:MathService.Evulations.UnaryOperatorEvulation`2._Operator">
            <summary>Функция преобразования выражения операнда в выражение вычисления над этим операндом</summary>
        </member>
        <member name="M:MathService.Evulations.UnaryOperatorEvulation`2.#ctor(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>Инициализация нового унарного вычисления</summary>
            <param name="Operator">ОПератор преобразования выражения операнда в выражение вычисления</param>
        </member>
        <member name="M:MathService.Evulations.UnaryOperatorEvulation`2.#ctor(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression},MathService.Evulations.Evulation{`0})">
            <summary>Инициализация нового унарного вычисления</summary>
            <param name="Operator">Оператор преобразования выражения операнда в выражение вычисления</param>
            <param name="value">Вычисление операнда</param>
        </member>
        <member name="M:MathService.Evulations.UnaryOperatorEvulation`2.GetExpression">
            <inheritdoc />
        </member>
        <member name="T:MathService.Evulations.ValueEvulation`1">
            <summary>Вычисление конкретного значения</summary>
            <typeparam name="T">Тип возвращаемого значения</typeparam>
        </member>
        <member name="P:MathService.Evulations.ValueEvulation`1.Value">
            <summary>Возвращаемое значение</summary>
        </member>
        <member name="M:MathService.Evulations.ValueEvulation`1.#ctor">
            <summary>Инициализация нового вычисления конкретного значения</summary>
        </member>
        <member name="M:MathService.Evulations.ValueEvulation`1.#ctor(`0)">
            <summary>Инициализация нового вычисления конкретного значения</summary>
            <param name="value">Возвращаемое значение</param>
        </member>
        <member name="M:MathService.Evulations.ValueEvulation`1.GetValue">
            <inheritdoc />
        </member>
        <member name="M:MathService.Evulations.ValueEvulation`1.GetExpression">
            <inheritdoc />
        </member>
        <member name="M:MathService.Evulations.ValueEvulation`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathService.Evulations.ValueEvulation`1.op_Implicit(`0)~MathService.Evulations.ValueEvulation{`0}">
            <summary>ОПератор неявного преобразования типа значения в тип вычисления этого значения</summary>
            <param name="Value">Оборачиваемое значение</param>
        </member>
        <member name="T:MathService.Evulations.NamedValueEvulation`1">
            <summary>Именованное вычисление конкретного значения</summary>
            <typeparam name="T">Тип возвращаемого значения</typeparam>
        </member>
        <member name="P:MathService.Evulations.NamedValueEvulation`1.Name">
            <summary>Имя вычисления</summary>
        </member>
        <member name="P:MathService.Evulations.NamedValueEvulation`1.IsParameter">
            <summary>Признак того, что данное вычисление является именованным параметром</summary>
        </member>
        <member name="M:MathService.Evulations.NamedValueEvulation`1.#ctor">
            <summary>Инициализация нового именованного вычисления конкретного значения</summary>
        </member>
        <member name="M:MathService.Evulations.NamedValueEvulation`1.#ctor(`0)">
            <summary>Инициализация нового именованного вычисления конкретного значения</summary>
            <param name="value">Возвращаемое значение</param>
        </member>
        <member name="M:MathService.Evulations.NamedValueEvulation`1.#ctor(`0,System.String)">
            <summary>Инициализация нового именованного вычисления конкретного значения</summary>
            <param name="value">Возвращаемое значение</param>
            <param name="name">Имя вычисления</param>
        </member>
        <member name="M:MathService.Evulations.NamedValueEvulation`1.GetExpression">
            <summary>Если вычисление является параметром, то возвращается выражение параметра, иначе возвращается вычисление значения</summary>
            <returns>Выражение, соответствующее данному вычислению</returns>
        </member>
        <member name="M:MathService.Evulations.NamedValueEvulation`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathService.ExpressionCreator`1">
            <example>
            internal class DirectCreator : ICreator&lt;Foo&gt;
            {
              public Foo Create(Dictionary&lt;string, object&gt; props)
                {
                    return new Foo
                    {
                        Name = props.GetValue&lt;string&gt;("Name"),
                        Value = props.GetValue&gt;int&lt;("Value")
                    };
                }
            }
            </example>
        </member>
        <member name="M:MathService.Extentions.Expressions.ExpressionExtentions.Substitute(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.LambdaExpression)">
            <exception cref="T:System.FormatException">Количество аргументов подстановки не равно 1, или во входном выражении отсутсвуте подставляемый параметр</exception>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.isSogl(System.Char)">
            <summary>Проверяет, является ли символ согласным</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.isGlas(System.Char)">
            <summary>Проверяет, является ли символ гласным</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.isSpecSign(System.Char)">
            <summary>Проверяет, является ли символ специальным (в данном контексте - разделителем)</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.GetSymbType(System.Char)">
            <summary>Возвращает тип символа: согласный, гласный, разделитель, неопределен</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.isSlogMore(MathService.Extentions.String.WordWrap.SymbType[],System.Int32)">
            <summary>Определяет, можно ли сделать перенос в массиве "с" в промежутке от start до len</summary>
            <param name="c"></param><param name="Start"></param><returns></returns>
            <remarks>
            Как я понимаю используется вместе с предыдущей функцией, т.е. сперва с помощью GetSymbType получить 
            из слова массив SymbType и дальше с помощью данной функции проверить, можно ли в нем сделать перенос
            </remarks>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.SetHyph(System.String,System.Int32)">
            <summary>Фактически, она и проделывает всю работу</summary>
            <param name="pc">Входной масив символов</param>
            <param name="MaxSize">Максимальный размер</param>
            <returns>Строка с расставленными знаками переноса</returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.Red_GlasMore(System.String,System.Int32)">
            <summary>
            На вход функции подается указатель на строку и позиция символа, с которого начинается чтение. 
            Дальше функция проверяет, есть ли в данной строке гласная буква
            </summary>
            <param name="p"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.Red_SlogMore(System.String,System.Int32)">
            <summary>
            Аналогично предыдущей функции, но для согласных
            </summary>
            <param name="p"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.MayBeHyph(System.String,System.Int32)">
            <summary>
            На вход подается указатель на строку и позиция, с которого начинается чтение. 
            Функция проверяет, можно ли сделать в данной строке перенос
            </summary>
            <param name="p"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:MathService.Extentions.String.WordWrap.SetHyphString(System.String)">
            <summary>На вход ей подается просто некая строка, дальше она ее обрабатывает и возвращает строку с переносами</summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:MathService.Functions.PSO.Swarm1D.Minimize(System.Func{System.Double,System.Double},MathService.Interval,System.Int32,System.Double@,System.Double@)">
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="T:MathService.Functions.PSO.Swarm2D">
            <summary>Рой двумерных частиц</summary>
        </member>
        <member name="F:MathService.Functions.PSO.Swarm2D.w">
            <summary>Вес инерции</summary>
        </member>
        <member name="F:MathService.Functions.PSO.Swarm2D.c1">
            <summary>Коэффициент локального веса</summary>
        </member>
        <member name="F:MathService.Functions.PSO.Swarm2D.c2">
            <summary>Коэффициент глобального веса</summary>
        </member>
        <member name="T:MathService.Functions.PSO.Swarm2D.Particle2D">
            <summary>Частица</summary>
        </member>
        <member name="F:MathService.Functions.PSO.Swarm2D._ParticleCount">
            <summary>Размер роя</summary>
        </member>
        <member name="T:MathService.Functions.FunctionsExtentions">
            <summary>Класс методов-расширений для функций</summary>
        </member>
        <member name="T:MathService.Functions.FunctionsExtentions.FuncValue">
            <summary>Структура значения функции {Аргумент - значение}</summary>
        </member>
        <member name="F:MathService.Functions.FunctionsExtentions.FuncValue.Argument">
            <summary>Аргумент функции</summary>
        </member>
        <member name="F:MathService.Functions.FunctionsExtentions.FuncValue.Value">
            <summary>Значение функции</summary>
        </member>
        <member name="M:MathService.Functions.FunctionsExtentions.FuncValue.#ctor(System.Double,System.Double)">
            <summary>Инициализация новой пары аргумент-значение функции</summary>
            <param name="arg">Аргумент функции</param>
            <param name="value">Значение функции</param>
        </member>
        <member name="T:MathService.Functions.FunctionsExtentions.FuncMinMaxValue">
            <summary>Структура, содержащая максимальное и минимальное значение функции</summary>
        </member>
        <member name="F:MathService.Functions.FunctionsExtentions.FuncMinMaxValue.Min">
            <summary>Минимальное значение функции</summary>
        </member>
        <member name="F:MathService.Functions.FunctionsExtentions.FuncMinMaxValue.Max">
            <summary>Максимальное значение функции</summary>
        </member>
        <member name="M:MathService.Functions.FunctionsExtentions.FuncMinMaxValue.#ctor(MathService.Functions.FunctionsExtentions.FuncValue,MathService.Functions.FunctionsExtentions.FuncValue)">
            <summary>Инициализация нового максимального и минимального значения функции</summary>
            <param name="min">Минимум функции</param>
            <param name="max">Максимум функции</param>
        </member>
        <member name="M:MathService.Functions.FunctionsExtentions.GetValues(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Получить массив значений функции в указанном интервале с указанным шагом</summary>
            <param name="f">Фунция, Массив значений которой требуется получить</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">КОнец интервала</param>
            <param name="dx">Шаг сетки дискретизации</param>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:MathService.Functions.FunctionsExtentions.GetMinMax(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Определить минимум и максимум на интервале</summary>
            <param name="f">Функция, минимум и максимум которой требуется определить</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <param name="dx">Шаг сетки разбиения</param>
            <returns>Структура, содержащая минимум и максимум функции</returns>
        </member>
        <member name="M:MathService.Functions.FunctionsExtentions.GetMinValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Определить минимум функции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <param name="dx">Шаг</param>
            <returns>Минимум функции</returns>
        </member>
        <member name="M:MathService.Functions.FunctionsExtentions.GetMaxValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Определить максимум функции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <param name="dx">Шаг</param>
            <returns>Максимум функции</returns>
        </member>
        <member name="T:MathService.GCWacher">
            <summary>Наблюдатель за сборщиком мусора</summary>
        </member>
        <member name="E:MathService.GCWacher.__Approaches">
            <summary>Событие запуска процесса сборки мусора</summary>
        </member>
        <member name="E:MathService.GCWacher.Approaches">
            <summary>Событие запуска процесса сборки мусора</summary>
        </member>
        <member name="E:MathService.GCWacher.__Complite">
            <summary>Событие завершения процесса сборки мусора</summary>
        </member>
        <member name="E:MathService.GCWacher.Complite">
            <summary>Событие завершения процесса сборки мусора</summary>
        </member>
        <member name="M:MathService.GCWacher.OnApproaches">
            <summary>Генерация осбытия начала сборки мусора</summary>
        </member>
        <member name="M:MathService.GCWacher.OnComplite">
            <summary>Генерация осбытия окончания сборки мусора</summary>
        </member>
        <member name="F:MathService.GCWacher.__GCWacher">
            <summary>Объект-наблюдатель за сборщиком мусора</summary>
        </member>
        <member name="F:MathService.GCWacher.__SyncRoot">
            <summary>Объект синхронизации потоков управления наблюдателем</summary>
        </member>
        <member name="F:MathService.GCWacher._WatcherThread">
            <summary>Поток наблюдения с борщиком мусора</summary>
        </member>
        <member name="F:MathService.GCWacher.__Enabled">
            <summary>Признак активности наблюдателя</summary>
        </member>
        <member name="M:MathService.GCWacher.#ctor">
            <summary>Скрытая инициализация объекта-наблюдателя</summary>
        </member>
        <member name="M:MathService.GCWacher.Start">
            <summary>Запуск процесса наблюдения</summary>
        </member>
        <member name="M:MathService.GCWacher.Stop">
            <summary>Остановка процесса наблюдения</summary>
        </member>
        <member name="M:MathService.GCWacher.Watch">
            <summary>Проесс наблюдения</summary>
        </member>
        <member name="T:MathService.Geolocation.GPS">
            <summary>Класс сервисных функций работы с координатами</summary>
        </member>
        <member name="F:MathService.Geolocation.GPS.MeridianLength">
            <summary>Длина окружности меридиана (в метрах)</summary>
        </member>
        <member name="F:MathService.Geolocation.GPS.Meridian1DegreeLength">
            <summary>Длина дуги меридиана в 1 градус (в метрах)</summary>
        </member>
        <member name="F:MathService.Geolocation.GPS.Meridian1MinuteLength">
            <summary>Длина дуги меридиана в 1 минуту (в метрах)</summary>
        </member>
        <member name="F:MathService.Geolocation.GPS.Meridian1SecondLength">
            <summary>Длина дуги меридиана в 1 секунду (в метрах)</summary>
        </member>
        <member name="F:MathService.Geolocation.GPS.Meridian1RadianLength">
            <summary>Длина дуги меридиана в 1 радиан (в метрах)</summary>
        </member>
        <member name="F:MathService.Geolocation.GPS.ParallelEquatorLength">
            <summary>Длина окружности параллели на экваторе (в метрах)</summary>
        </member>
        <member name="F:MathService.Geolocation.GPS.ParallelEquator1DegreeLength">
            <summary>Длина дуги параллели на экваторе в 1 градус (в метрах)</summary>
        </member>
        <member name="F:MathService.Geolocation.GPS.ParallelEquator1MinuteLength">
            <summary>Длина дуги параллели на экваторе в 1 минуту (в метрах)</summary>
        </member>
        <member name="F:MathService.Geolocation.GPS.ParallelEquator1SecondLength">
            <summary>Длина дуги параллели на экваторе в 1 секунду (в метрах)</summary>
        </member>
        <member name="F:MathService.Geolocation.GPS.ParallelEquator1RadianLength">
            <summary>Длина дуги параллели на экваторе в 1 радиан (в метрах)</summary>
        </member>
        <member name="F:MathService.Geolocation.GPS.EarthRadius">
            <summary>Радиус Земли в метрах</summary>
        </member>
        <member name="M:MathService.Geolocation.GPS.LengthBetween(System.Double,System.Double,System.Double,System.Double)">
            <summary>Вычисление расстояния между двумя точками на поверхности земли, заданными своими координатами</summary>
            <param name="latitude1">Широта первой точки в градусах</param>
            <param name="longitude1">Долгота первой точки в градусах</param>
            <param name="latitude2">Широта второй точки в градусах</param>
            <param name="longitude2">Долгота второй точки в градусах</param>
            <returns>Длина дуги на поверхности Земли, начинающейся в первой точке и заканчивающейся во второй точке</returns>
        </member>
        <member name="M:MathService.Geolocation.GPS.EquirectangularApproximation_LengthBetween(System.Double,System.Double,System.Double,System.Double)">
            <summary>Вычисление расстояния между двумя точками на поверхности земли (в равнопромежуточной проекции), заданными своими координатами</summary>
            <param name="latitude1">Широта первой точки в градусах</param>
            <param name="longitude1">Долгота первой точки в градусах</param>
            <param name="latitude2">Широта второй точки в градусах</param>
            <param name="longitude2">Долгота второй точки в градусах</param>
            <returns>Расстояние между двумя точками</returns>
            <remarks>Алгоритм требуем меньше вычислительных ресурсов, но даёт большую погрешность</remarks>
        </member>
        <member name="M:MathService.Geolocation.GPS.Heading(System.Double,System.Double,System.Double,System.Double)">
            <summary>Определение курса по координатам начальной и конечной точки</summary>
            <param name="latitude1">Широта первой иходной точки</param>
            <param name="longitude1">Долгота первой иходной точки</param>
            <param name="latitude2">Широта второй иходной точки</param>
            <param name="longitude2">Долгота второй иходной точки</param>
            <returns>Курс в градусах</returns>
        </member>
        <member name="M:MathService.Geolocation.GPS.HalfWayPoint(System.Double,System.Double,System.Double,System.Double)">
            <summary>Определение точки на середине отрезка, заданного двумя точками</summary>
            <param name="latitude1">Широта первой иходной точки</param>
            <param name="longitude1">Долгота первой иходной точки</param>
            <param name="latitude2">Широта второй иходной точки</param>
            <param name="longitude2">Долгота второй иходной точки</param>
            <returns>Точка в середине отрезка</returns>
        </member>
        <member name="M:MathService.Geolocation.GPS.DestinationPoint(System.Double,System.Double,System.Double,System.Double)">
            <summary>Определение точки места назначения по исходной точке, курсу и расстоянию</summary>
            <param name="latitude">Широта исходной точки</param>
            <param name="longitude">Долгота исхоной точки</param>
            <param name="heading">Курс на точкуу назначения</param>
            <param name="distance">Пройденная дистанция в метрах</param>
            <returns>Точка назначения</returns>
        </member>
        <member name="M:MathService.Geolocation.GPS.DestinationPoint(System.Double,System.Double,System.Double,System.Double,System.Double@)">
            <summary>Определение точки места назначения по исходной точке, курсу и расстоянию</summary>
            <param name="latitude">Широта исходной точки</param>
            <param name="longitude">Долгота исхоной точки</param>
            <param name="heading">Курс на точкуу назначения</param>
            <param name="distance">Пройденная дистанция в метрах</param>
            <param name="final_heading">Курс из точки назначения на исходную точку</param>
            <returns>Точка назначения</returns>
        </member>
        <member name="M:MathService.Geolocation.GPS.Intersection(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Определение точки персечения двух курсов, каждый из которых задан исходной точкой</summary>
            <param name="latitude1">Широта первой иходной точки</param>
            <param name="longitude1">Долгота первой иходной точки</param>
            <param name="heading1">Курс из первой иходной точки</param>
            <param name="latitude2">Широта второй иходной точки</param>
            <param name="longitude2">Долгота второй иходной точки</param>
            <param name="heading2">Курс второй исходной точки</param>
            <returns>Точка пересечения двух курсов</returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.AsGraphNode``2(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,``0,``1},System.Boolean)">
            <summary>Преобразование к типу вершины графа</summary>
            <typeparam name="TValue">Тап значения вершины</typeparam>
            <typeparam name="TWeight">Тип веса связи</typeparam>
            <param name="value">Значение вершины</param>
            <param name="GetChields">Метод выделения дочерних узлов</param>
            <param name="GetWeight">Метод определения веса связи между узлами</param>
            <param name="Buffered">Буферизация узлов и связей</param>
            <returns>Узел графа</returns>
            <example>
            <code>
            var M = new[,]
                   { /* 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14*/
            /*  0 */   {0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  1 */   {1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  2 */   {1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  3 */   {0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0},
            /*  4 */   {0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0},
            /*  5 */   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
            /*  6 */   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1},
            /*  7 */   {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  8 */   {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  9 */   {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 10 */   {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 11 */   {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 12 */   {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 13 */   {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 14 */   {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
                   };
            var node = new { M, i = 0 };
            var root = node.AsGraphNode(r => Enumerable.Range(0, r.M.GetLength(1)).Select(i => new { M, i }),
                         (from, to) => from.M[to.i, from.i]);
            var tree = root.AsGraphNode(root => root.Links.Where(link => link.Weight == 1)
                                                          .Select(link => link.Node),
                                        (from, to) => to.Value.i - from.Value.i);
            var rouht = tree.GetWaveRoute();
            
            </code>
            </example>
        </member>
        <member name="M:MathService.Graphs.GraphEx.AsGraphNode``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Boolean)">
            <summary>Преобразование к виду графа</summary>
            <typeparam name="TVAlue">Тип преобразуемого объекта</typeparam>
            <param name="value">Преобразуемый объект</param>
            <param name="GetChields">Метод извлечения дочерних узлов из каждого узла графа</param>
            <param name="Buffered">Флаг необходимости проведения буфферизации</param>
            <returns></returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.BypassInDepth``2(MathService.Graphs.IGraphNode{``0,``1})">
            <summary>Метод перебора вершин графа путём обхода "в глубину". Обход на основе стека дочерних узлов.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <typeparam name="TWeight">Тип связи узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.BypassInDepth``1(MathService.Graphs.IGraphNode{``0})">
            <summary>Метод перебора вершин графа путём обхода "в глубину". Обход на основе стека дочерних узлов.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.BaypassInWidth``2(MathService.Graphs.IGraphNode{``0,``1})">
            <summary>Метод перебора вершин графа путём обхода "в ширину". Обход на основе очереди дочерних узлов.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <typeparam name="TWeight">Тип связи узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.BaypassInWidth``1(MathService.Graphs.IGraphNode{``0},System.Boolean)">
            <summary>Метод перебора вершин графа путём обхода "в ширину". Обход на основе очереди дочерних узлов.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <param name="TakeRoot">Перечислять корень дерева?</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.BaypassInWidth``1(MathService.Graphs.IGraphNode{``0},System.Func{MathService.Graphs.IGraphNode{``0},System.Int32},System.Boolean)">
            <summary>Метод перебора вершин графа путём обхода "в ширину". Обход на основе очереди дочерних узлов с указанием функции хеширования.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <param name="hash">Функция хеширования элементов</param>
            <param name="TakeRoot">Перечислять корень дерева?</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.FindRouteInDepth``2(MathService.Graphs.IGraphNode{``0,``1},System.Predicate{``0})">
            <summary>МЕтод поиска пути в графе путём обхода вершин "в глубину"</summary>
            <typeparam name="TValue">Тип вершины графа</typeparam>
            <typeparam name="TWeight">Тип связи вершин графа</typeparam>
            <param name="RootNode">Начальный элемент поиска пути</param>
            <param name="FindPredicate">Метод определения окончания поиска, как успешного</param>
            <returns>Маршрут в графе</returns>
        </member>
        <member name="M:MathService.Graphs.GraphEx.GetWaveRoute``2(MathService.Graphs.IGraphNode{``0,``1})">
            <summary>Метод поиска всех путей из указанной вершины до всех доступных вершин графа методом фронта волны</summary>
            <typeparam name="TValue">Тип вершины графа</typeparam>
            <typeparam name="TWeight">Тип связи вершин графа</typeparam>
            <param name="Root">Начальный элемент поиска пути</param>
            <returns>Массив найденных путей</returns>
        </member>
        <member name="T:MathService.Graphs.IGraphLink`2">
            <summary>Связь узла</summary>
            <typeparam name="TValue">Тип значения узла</typeparam>
            <typeparam name="TWeight">Тип нагрузки на связь</typeparam>
        </member>
        <member name="P:MathService.Graphs.IGraphLink`2.Node">
            <summary>Связанный узел</summary>
        </member>
        <member name="P:MathService.Graphs.IGraphLink`2.Weight">
            <summary>Нагрузка на связь</summary>
        </member>
        <member name="T:MathService.Graphs.IGraphNode`2">
            <summary>Узел графа</summary>
            <typeparam name="TValue">Тип значения узла</typeparam>
            <typeparam name="TWeight">Тип нагрузки на связь</typeparam>
        </member>
        <member name="P:MathService.Graphs.IGraphNode`2.Links">
            <summary>Связи узла</summary>
        </member>
        <member name="P:MathService.Graphs.IGraphNode`2.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathService.Graphs.IGraphNode`1.Childs">
            <summary>Связи узла</summary>
        </member>
        <member name="P:MathService.Graphs.IGraphNode`1.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathService.Graphs.LambdaGraphNode`2.Links">
            <inheritdoc />
        </member>
        <member name="P:MathService.Graphs.LambdaGraphNode`1.Childs">
            <summary>Связи узла</summary>
        </member>
        <member name="P:MathService.Graphs.LambdaGraphNode`1.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="M:MathService.Graphs.LambdaGraphNode`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathService.Graphs.LambdaGraphNode`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathService.Graphs.LambdaGraphNode`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathService.Graphs.LambdaGraphNode`1.Equals(MathService.Graphs.LambdaGraphNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:MathService.Graphs.LambdaGraphNode`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathService.Graphs.LambdaGraphNode`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.IndexOf(MathService.Graphs.TreeListNode{`0})">
            <summary>
            Определяет индекс заданного элемента коллекции <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <returns>
            Индекс <paramref name="item"/> если он найден в списке; в противном случае его значение равно -1.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.IndexOf(`0)">
            <summary>Определяет индекс заданного элемента коллекции <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <returns>Индекс <paramref name="item"/> если он найден в списке; в противном случае его значение равно -1.</returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Insert(System.Int32,MathService.Graphs.TreeListNode{`0})">
            <summary>Вставляет элемент в список <see cref="T:System.Collections.Generic.IList`1"/> по указанному индексу.</summary>
            <param name="index">Индекс (с нуля), по которому следует вставить параметр <paramref name="item"/>.</param><param name="item">Объект, вставляемый в <see cref="T:System.Collections.Generic.IList`1"/>.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Insert(System.Int32,`0)">
            <summary>Вставляет элемент в список <see cref="T:System.Collections.Generic.IList`1"/> по указанному индексу.</summary>
            <param name="index">Индекс (с нуля), по которому следует вставить параметр <paramref name="item"/>.</param><param name="item">Объект, вставляемый в <see cref="T:System.Collections.Generic.IList`1"/>.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.RemoveAt(System.Int32)">
            <summary>Удаляет элемент <see cref="T:System.Collections.Generic.IList`1"/> по указанному индексу.</summary>
            <param name="index">Индекс (с нуля) удаляемого элемента.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathService.Graphs.TreeListNode`1.System#Collections#Generic#IList{TValue}#Item(System.Int32)">
            <summary>Получает или задает элемент по указанному индексу.</summary>
            <returns>Элемент с указанным индексом.</returns>
            <param name="index">Индекс (с нуля) элемента, который необходимо получить или задать.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Свойство задано, и объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.System#Collections#Generic#ICollection{TValue}#Add(`0)">
            <summary>Добавляет элемент в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <param name="item">Объект, добавляемый в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Clear">
            <summary>Удаляет все элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Contains(`0)">
            <summary>Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.</summary>
            <returns>Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.</returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.CopyTo(`0[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.</param><param name="index">Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> меньше 0.</exception><exception cref="T:System.ArgumentException">Массив <paramref name="array"/> является многомерным.-или-
                            Значение индекса массива <paramref name="index"/> больше или равно длине массива <paramref name="array"/>.-или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="index"/> и до конца массива назначения <paramref name="array"/>.-или-Тип <paramref name="TValue"/> не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Remove(`0)">
            <summary>Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathService.Graphs.TreeListNode`1.System#Collections#Generic#ICollection{TValue}#Count">
            <summary>Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <returns>Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.</returns>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Contains(MathService.Graphs.TreeListNode{`0})">
            <summary>Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.</summary>
            <returns>
            Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.CopyTo(MathService.Graphs.TreeListNode{`0}[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.</param><param name="index">Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> меньше 0.</exception><exception cref="T:System.ArgumentException">Массив <paramref name="array"/> является многомерным.-или-
                            Значение индекса массива <paramref name="index"/> больше или равно длине массива <paramref name="array"/>.-или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="index"/> и до конца массива назначения <paramref name="array"/>.-или-Тип <paramref name="T"/> не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.</exception>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.Remove(MathService.Graphs.TreeListNode{`0})">
            <summary>Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathService.Graphs.TreeListNode`1.System#Collections#Generic#ICollection{MathService#Graphs#TreeListNode{TValue}}#Count">
            <summary>Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <returns>Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.</returns>
        </member>
        <member name="P:MathService.Graphs.TreeListNode`1.IsReadOnly">
            <summary>Получает значение, указывающее, доступен ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> только для чтения.</summary>
            <returns>Значение true, если интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения, в противном случае — значение false.</returns>
        </member>
        <member name="M:MathService.Graphs.TreeListNode`1.System#Collections#Generic#IEnumerable{TValue}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции</summary>
            <returns>Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.</returns>
        </member>
        <member name="T:MathService.Interpolation.BezierCurve">
            <summary><see cref="!:http://ru.wikipedia.org/wiki/Кривая_Безье">Кривая Безье</see></summary>
        </member>
        <member name="M:MathService.Interpolation.BezierCurve.BinomCoefficient(System.Int32,System.Int32)">
            <summary>
            Биномиальный коэффициент (1+x)^n из <paramref name="n"/> по <paramref name="k"/>
            <see cref="!:http://ru.wikipedia.org/wiki/Биномиальный_коэффициент">Википедия:Биномиальный коэффициент</see>>
            </summary>
            <param name="n">Степень <see cref="!:http://ru.wikipedia.org/wiki/Бином_Ньютона">бинома Ньютона</see>></param>
            <param name="k">Номер коэффициента</param>
            <returns>Коэффициент разложения Бинома Ньютона (1+x)^n</returns>
        </member>
        <member name="M:MathService.Interpolation.BezierCurve.GetBernshteynPolynom(System.Int32,System.Int32)">
            <summary>Получить <see cref="!:http://ru.wikipedia.org/wiki/Многочлен_Бернштейна">Полином Бернштейна</see>></summary>
            <param name="k">Номер многочлена</param>
            <param name="n">Степень</param>
            <returns></returns>
        </member>
        <member name="F:MathService.Interpolation.BezierCurve._Points">
            <summary>Набор точек аппроксимации</summary>
        </member>
        <member name="F:MathService.Interpolation.BezierCurve._BernshteynPolynoms">
            <summary><see cref="!:http://ru.wikipedia.org/wiki/Многочлен_Бернштейна">Полином Бернштейна</see>></summary>        
        </member>
        <member name="M:MathService.Interpolation.BezierCurve.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Новая <see cref="!:http://ru.wikipedia.org/wiki/Кривая_Безье">кривая Безье</see></summary>
            <param name="X">Список координато точек x</param>
            <param name="Y">Список кординат точек y</param>
        </member>
        <member name="M:MathService.Interpolation.BezierCurve.#ctor(System.Collections.Generic.IEnumerable{MathService.Complex})">
            <summary>Новая <see cref="!:http://ru.wikipedia.org/wiki/Кривая_Безье">кривая Безье</see></summary>
            <param name="Points">Набор точек в виде <see cref="T:MathService.Complex">комплексных чисел</see></param>
        </member>
        <member name="M:MathService.Interpolation.BezierCurve.#ctor(System.Collections.Generic.IEnumerable{MathService.Vectors.Vector2D})">
            <summary>Новая <see cref="!:http://ru.wikipedia.org/wiki/Кривая_Безье">кривая Безье</see></summary>
            <param name="Points">Набор точек</param>
        </member>
        <member name="M:MathService.Interpolation.BezierCurve.Initialize(System.Collections.Generic.IEnumerable{MathService.Vectors.Vector2D})">
            <summary>Инициализировать кривую Безье</summary>
            <param name="Points">Набор точек</param>
        </member>
        <member name="T:MathService.Interpolation.CubicSpline">
            <summary>Интерполирование функций естественными кубическими сплайнами</summary>
            <remarks>Разработчик: Назар Андриенко Email: nuzikprogrammer@gmail.com</remarks>
        </member>
        <member name="T:MathService.Interpolation.CubicSpline.SplineState">
            <summary>Структура, описывающая сплайн на каждом сегменте сетки</summary>
        </member>
        <member name="F:MathService.Interpolation.CubicSpline._SplinStates">
            <summary>Сплайн</summary>
        </member>
        <member name="M:MathService.Interpolation.CubicSpline.Initialize(System.Double[],System.Double[])">
            <summary>Инициализация сплайна</summary>
            <param name="X">Массив аргументов</param><param name="Y">Массив значений</param>
            <exception cref="T:System.ArgumentException">Возникает в случае, если размерности массивов не равны</exception>
        </member>
        <member name="T:MathService.Interpolation.IInterpolator">
            <summary>Интерфейс интерполяции</summary>
        </member>
        <member name="M:MathService.Interpolation.IInterpolator.Value(System.Double)">
            <summary>Получить значение</summary>
            <param name="x">Переменная</param>
            <returns>Значение</returns>
        </member>
        <member name="T:MathService.IoC.ServiceManager">
            <summary>Менеджер сервисов</summary>
        </member>
        <member name="T:MathService.IoC.ServiceRegistrationMode">
            <summary>Режим регистрации сервиса</summary>
        </member>
        <member name="F:MathService.IoC.ServiceRegistrationMode.Singleton">
            <summary>Режим регистрации единого объекта для всех вызовов</summary>
        </member>
        <member name="F:MathService.IoC.ServiceRegistrationMode.SingleCall">
            <summary>Режим регистрации, при котором для каждого вызова будет создан новый экземпляр сервиса</summary>
        </member>
        <member name="F:MathService.IoC.ServiceRegistrationMode.SingleThread">
            <summary>Режим регистрации, при котором для каждого потока будет создан единый экземпляр сервиса</summary>
        </member>
        <member name="T:MathService.IO.Compression.Zip">
            <summary>Класс zip-архива для работы с файлами zip-архивов (упаковка/распаковка)</summary>
        </member>
        <member name="F:MathService.IO.Compression.Zip._ArchiveEntries">
            <summary>Список элементов архива</summary>
        </member>
        <member name="F:MathService.IO.Compression.Zip._FileName">
            <summary>Имя файла архива</summary>
        </member>
        <member name="F:MathService.IO.Compression.Zip._ArchiveStream">
            <summary>Поток данных файла архива</summary>
        </member>
        <member name="F:MathService.IO.Compression.Zip._Comment">
            <summary>Комментарий архива</summary>
        </member>
        <member name="F:MathService.IO.Compression.Zip._Access">
            <summary>Метод доступа к архиву</summary>
        </member>
        <member name="F:MathService.IO.Compression.Zip.__CrcTable">
            <summary>Статическая таблица контрольной суммы CRC32</summary>
        </member>
        <member name="F:MathService.IO.Compression.Zip.__DefaultEncoding">
            <summary>Строковый кодировщик по умолчанию</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.EncodeUTF8">
            <summary>Истина, если используется кодировка UTF8 в имени файла и комментарии; ложь, если кодировка по-умолчанию(CP 437)</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.ForceCompress">
            <summary>Принудительно использолвать сжатие, даже если алгоритм увеличевает размер файла</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Comment">
            <summary>Коментарий архива</summary>
        </member>
        <member name="M:MathService.IO.Compression.Zip.#cctor">
            <summary>Инициализация типа</summary>
            <remarks>Создаёт табилцу CRC32</remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Create(System.String,System.String)">
            <summary>Создание нового архива в указанном файле</summary>
            <param name="FileName">Полный путь к файлу архива</param>
            <param name="Comment">Комментарий</param>
            <returns>Архив</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Create(System.IO.Stream,System.String)">
            <summary>Создать новый архиватор в потоке данных</summary>
            <param name="Stream">Поток с данными архива</param>
            <param name="Comment">Комментарий</param>
            <returns>Архив</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Open(System.String,System.IO.FileAccess)">
            <summary>Открытие файла архива из файла</summary>
            <param name="FileName">Полный путь к файлу</param>
            <param name="Access">Режим доступа к файлу</param>
            <returns>Архив</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.OpenAsync(System.String,System.IO.FileAccess)">
            <summary>Открытие файла архива из файла</summary>
            <param name="FileName">Полный путь к файлу</param>
            <param name="Access">Режим доступа к файлу</param>
            <returns>Архив</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Open(System.IO.Stream,System.IO.FileAccess)">
            <summary>Открытие архива из потока</summary>
            <param name="Stream">Открытый поток с содержимым zip-архива и возможностью навигации</param>
            <param name="Access">Режим доступа к потоку</param>
            <returns>Архивр</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.OpenAsync(System.IO.Stream,System.IO.FileAccess)">
            <summary>Открытие архива из потока</summary>
            <param name="Stream">Открытый поток с содержимым zip-архива и возможностью навигации</param>
            <param name="Access">Режим доступа к потоку</param>
            <returns>Архивр</returns>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Item(System.String)">
            <summary>Запись архива по указанному имени</summary><param name="Name">Имя записи архива</param>
            <returns>Запись архива, если она присутствует в архиве, и null в противном случае</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.#ctor(System.IO.Stream,System.String,System.IO.FileAccess)">
            <summary>Создать на основе потока</summary>
        </member>
        <member name="M:MathService.IO.Compression.Zip.FileExists(System.String)">
            <summary>Проверка существования файла в архиве</summary><param name="FileName">Имя проверяемого файла</param>
            <returns>Истина, если файл существует в архиве</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Add(System.String,System.String,System.String,System.Boolean)">
            <summary>Добавить файл в архив</summary>
            <param name="SourceFileName">Полный путь к добавляемому файлу</param>
            <param name="FileNameInZip">Имя и путь к файлу в архиве</param>
            <param name="Comment">Коментарий</param>
            <param name="Compressed">Добавлять сжатым</param>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Add(System.IO.Stream,System.String,System.DateTime,System.String,System.Boolean)">
            <summary>Добавить потоковое содержимое в архив</summary>
            <param name="Source">Поток-источник данных файла в архиве</param>
            <param name="FileNameInZip">Путь к файлу внутри архива</param>
            <param name="ModificationTime">Время модификации файла в архиве</param>
            <param name="Comment">Комментарий к файлу</param>
            <param name="Compressed">Добавлять сжатым</param>
        </member>
        <member name="M:MathService.IO.Compression.Zip.AddAsync(System.IO.Stream,System.String,System.DateTime,System.Boolean,System.String)">
            <summary>Добавить потоковое содержимое в архив</summary>
            <param name="Source">Поток-источник данных файла в архиве</param>
            <param name="FileNameInZip">Путь к файлу внутри архива</param>
            <param name="ModificationTime">Время модификации файла в архиве</param>
            <param name="Compressed">Метод сжатия</param>
            <param name="Comment">Комментарий к файлу</param>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Close">
            <summary>При необходимости обновляет главный каталог архива и закрывает архив</summary>
            <remarks>Этот шег необходим, если отсутствует явное управление ресурсами через интерфейс <see cref="T:System.IDisposable"/></remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.CloseAsync">
            <summary>При необходимости обновляет главный каталог архива и закрывает архив</summary>
            <remarks>Этот шег необходим, если отсутствует явное управление ресурсами через интерфейс <see cref="T:System.IDisposable"/></remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.GetFileOffset(System.UInt32)">
            <summary>Определение смещения файла по информации из заголовка</summary>
            <param name="HeaderOffset">Смещение заголовка</param>
            <returns>Смещение файла по логическому заголовку</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.GetFileOffsetAsync(System.UInt32)">
            <summary>Определение смещения файла по информации из заголовка</summary>
            <param name="HeaderOffset">Смещение заголовка</param>
            <returns>Смещение файла по логическому заголовку</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.WriteLocalHeader(MathService.IO.Compression.Zip.Entry)">
            <summary>Запись логического заголовка</summary>
            <param name="entry">Элемент архива</param>
            <remarks>
            Заголовок файла:
               Сигнатура логического заголовка         4 байта == 0x04034b50
               версия содержимого                      2 байта
               Бит флага общего назначения             2 байта
               Метод сжатия                            2 байта
               Время последнего изменения файла        2 байта
               ДАта последнего изменения файла         2 байта
               32-битная контрольная сумма             4 байта
               Сжатый размер                           4 байта
               Исходный размер                         4 байта
               Длина имени файла                       2 байта
               Длина поля с дополнительной информацией 2 байта
            </remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.WriteLocalHeaderAsync(MathService.IO.Compression.Zip.Entry)">
            <summary>Запись логического заголовка</summary>
            <param name="entry">Элемент архива</param>
            <remarks>
            Заголовок файла:
               Сигнатура логического заголовка         4 байта == 0x04034b50
               версия содержимого                      2 байта
               Бит флага общего назначения             2 байта
               Метод сжатия                            2 байта
               Время последнего изменения файла        2 байта
               ДАта последнего изменения файла         2 байта
               32-битная контрольная сумма             4 байта
               Сжатый размер                           4 байта
               Исходный размер                         4 байта
               Длина имени файла                       2 байта
               Длина поля с дополнительной информацией 2 байта
            </remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.WriteCentralDirRecord(MathService.IO.Compression.Zip.Entry)">
            <summary>Запись индекса архива</summary>
            <param name="entry">Элемент архива</param>
            <remarks>
            Заголовок индекса архива:
                Сигнатура заголовка(индекса) архива             4 байта == 0x02014b50
                Версия                                          2 байта
                Версия для извлечения                           2 байта
                Битовый флаг общего назначения                  2 байта
                Метод сжания                                    2 байта
                Время последнего изменения файла                2 байта
                Дата последнего изменения файла                 2 байта
                32-битная контрольная сумма                     4 байта
                Сжатый размер                                   4 байта
                Несжатый размер                                 4 байта
                Длина имени файла                               2 байта
                Длина поля доп.данных                           2 байта
                Длина комментария файла                         2 байта
                Номер тома                                      2 байта
                Внутренние файловые атрибуты                    2 байта
                Внешние файловые атрибуты                       4 байта
                Относительное смещение от логического заголовка 4 байта
            
                Имя файла указанная длина
                Поле с доп.информацией указанная длина
                Комментарий                                     указанная длина
            </remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.WriteCentralDirRecordAsync(MathService.IO.Compression.Zip.Entry)">
            <summary>Запись индекса архива</summary>
            <param name="entry">Элемент архива</param>
            <remarks>
            Заголовок индекса архива:
                Сигнатура заголовка(индекса) архива            4 байта == 0x02014b50
                Версия                                          2 байта
                Версия для извлечения                           2 байта
                Битовый флаг общего назначения                  2 байта
                Метод сжания                                    2 байта
                Время последнего изменения файла                2 байта
                Дата последнего изменения файла                 2 байта
                32-битная контрольная сумма                     4 байта
                Сжатый размер                                   4 байта
                Несжатый размер                                 4 байта
                Длина имени файла                               2 байта
                Длина поля доп.данных                           2 байта
                Длина комментария файла                         2 байта
                Номер тома                                      2 байта
                Внутренние файловые атрибуты                    2 байта
                Внешние файловые атрибуты                       4 байта
                Относительное смещение от логического заголовка 4 байта
            
                Имя файла указанная длина
                Поле с доп.информацией указанная длина
                Комментарий                                     указанная длина
            </remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.WriteEndRecord(System.UInt32,System.UInt32)">
            <summary>Запись окончания файла</summary>
            <param name="Size">Размер</param>
            <param name="Offset">Смещение</param>
            <remarks>
            Завершение индекса архива:
             Сигнатура завершения архива                     4 байт  (0x06054b50)
             Номер тома                                      2 байт
             Номер тома с началом индекса архива             2 байт
             Общее число записей в индексе в этом томе       2 байт
             Общее число записей в индексе                   2 байт
             Размер индекса                                  4 байт
             Смещение наччала индекса с учётом номера тома   4 байт
             Длина комментария архива                        2 байт
             Комментарий архива                              Указанная длина
            </remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.WriteEndRecordAsync(System.UInt32,System.UInt32)">
            <summary>Запись окончания файла</summary>
            <param name="Size">Размер</param>
            <param name="Offset">Смещениеи</param>
            <remarks>
            Завершение индекса архива:
             Сигнатура завершения архива                     4 байт  (0x06054b50)
             Номер тома                                      2 байт
             Номер тома с началом индекса архива             2 байт
             Общее число записей в индексе в этом томе       2 байт
             Общее число записей в индексе                   2 байт
             Размер индекса                                  4 байт
             Смещение наччала индекса с учётом номера тома   4 байт
             Длина комментария архива                        2 байт
             Комментарий архива                              Указанная длина
            </remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Store(MathService.IO.Compression.Zip.Entry,System.IO.Stream)">
            <summary>Копирование данных из файла-источника в элемент архива</summary>
            <param name="entry">Элемент архива</param>
            <param name="Source">Источник</param>
        </member>
        <member name="M:MathService.IO.Compression.Zip.StoreAsync(MathService.IO.Compression.Zip.Entry,System.IO.Stream)">
            <summary>Копирование данных из файла-источника в элемент архива</summary>
            <param name="entry">Элемент архива</param>
            <param name="Source">Источник</param>
        </member>
        <member name="M:MathService.IO.Compression.Zip.DateTimeToDosTime(System.DateTime)">
            <summary>Преобразование даты и времени в MS-DOS-формат</summary>
            <param name="time">Упаковываемое время</param>
            <returns>4 байта структуры времени</returns>
            <remarks>
            DOS-формат времени и даты:
              MS-DOS-формат даты. ДАта упаковывается в следующий формат. Описание битов 
                  0-4 День масяца (1–31) 
                  5-8 Месяц (1 = Январь, 2 = февраль, и.т.д.) 
                  9-15 Год. Отсчитывается от 1980 (прибавить к значению 1980 для получения корректного результата) 
              MS-DOS-формат времени. Время упаковывается в следующий формат. Описание битов 
                  0-4 Секунды, делёные на 2 
                  5-10 Минуты (0–59) 
                  11-15 Часы (0–23 - в 24-часовом формате) 
            </remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.DosTimeToDateTime(System.UInt32)">
            <summary>Преобразование времени из формата MS-DOS</summary>
            <param name="dos_time">Структура времени в формате MS-DOS</param>
            <returns>Восстановленное время</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.UpdateCrcAndSizes(MathService.IO.Compression.Zip.Entry)">
            <summary>Обновление контрольной суммы и длин</summary>
            <param name="entry">Элемент архива</param>
            <remarks>
            CRC32 алгоритм
            "Магическое число" алгоритма CRC - 0xdebb20e3.  
            The proper CRC pre and post conditioning
            is used, meaning that the CRC register is
            pre-conditioned with all ones (начальное значение
            0xffffffff) and the value is post-conditioned by
            taking the one's complement of the CRC residual.
            Если третий бит флага общего назначения установлен, это
            полу равно нулу в локальном заголовке и корректное значение
            расположено в дескрипторе данных и в главном индексе
            </remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.UpdateCrcAndSizesAsync(MathService.IO.Compression.Zip.Entry)">
            <summary>Обновление контрольной суммы и длин</summary>
            <param name="entry">Элемент архива</param>
            <remarks>
            CRC32 алгоритм
            "Магическое число" алгоритма CRC - 0xdebb20e3.  
            The proper CRC pre and post conditioning
            is used, meaning that the CRC register is
            pre-conditioned with all ones (начальное значение
            0xffffffff) and the value is post-conditioned by
            taking the one's complement of the CRC residual.
            Если третий бит флага общего назначения установлен, это
            полу равно нулу в локальном заголовке и корректное значение
            расположено в дескрипторе данных и в главном индексе
            </remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.NormalizedFileName(System.String)">
            <summary>Нормализация имени файл для размещения его в архиве</summary>
            <param name="FileName">Имя файла для нормализации</param>
            <returns>Имя файла, в котором проведена замена '\' -> '/', удалена буква диска, удалены начальная и конечная '/'</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Initialize">
            <summary>Чтение окончания индекса файла</summary>
            <returns>Истина, если чтение прошло успешно</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.InitializeAsync">
            <summary>Чтение окончания индекса файла</summary>
            <returns>Истина, если чтение прошло успешно</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.Compression.Zip.System#Collections#Generic#IEnumerable{MathService#IO#Compression#Zip#Entry}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.Compression.Zip.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathService.IO.Compression.Zip.Entry">
            <summary>Элемент архива</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Entry.Compressed">
            <summary>Метод сжатия</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Entry.FileNameInZip">
            <summary>Полный путь к файлу в архиве</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Entry.FileSize">
            <summary>Исходный размер</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Entry.CompressedSize">
            <summary>Размер после сжатия</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Entry.HeaderOffset">
            <summary>Смещеине заголовка в файле архива</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Entry.FileOffset">
            <summary>Смещеине файла внутри файла архива</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Entry.HeaderSize">
            <summary>Размер заголовка</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Entry.Crc32">
            <summary>32-битрая контрольная сумма файла</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Entry.ModifyTime">
            <summary>Время последнего изменения файла</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Entry.Comment">
            <summary>Пользовательский комментарий к файлу</summary>
        </member>
        <member name="P:MathService.IO.Compression.Zip.Entry.EncodeUTF8">
            <summary>Истина, если используется кодировка UTF8 в имени файла и комментарии{ get; set; } ложь, если кодировка по-умолчанию(CP 437)</summary>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Entry.GetStream">
            <summary>Получить поток данных архивной записи</summary>
            <returns>Поток данных архивной записи</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Entry.ExtractTo(System.String,System.Boolean)">
            <summary>Извлечение содержимого архива в файл</summary>
            <param name="FileName">Имя файла на диске для извлечения</param>
            <param name="Rewrite">Перезаписывать существующие файлы</param>
            <returns>Истина, если файл распакован успешно</returns>
            <remarks>Unique compression methods are Store and Deflate</remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Entry.ExtractToAsync(System.String,System.Boolean)">
            <summary>Извлечение содержимого архива в файл</summary>
            <param name="FileName">Имя файла на диске для извлечения</param>
            <param name="Rewrite">Перезаписывать существующие файлы</param>
            <returns>Истина, если файл распакован успешно</returns>
            <remarks>Unique compression methods are Store and Deflate</remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Entry.ExtractTo(System.IO.Stream)">
            <summary>Извлечение элемента архива в поток</summary>
            <param name="Destination">Поток для извлечения</param>
            <returns>Истина, если извлечение прошло успешно</returns>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Entry.ExtractToAsync(System.IO.Stream)">
            <summary>Извлечение элемента архива в поток</summary>
            <param name="Destination">Поток для извлечения</param>
            <returns>Истина, если извлечение прошло успешно</returns>
            <remarks>Unique compression methods are Store and Deflate</remarks>
        </member>
        <member name="M:MathService.IO.Compression.Zip.Entry.ToString">
            <returns>Имя файла в архиве</returns>
        </member>
        <member name="P:MathService.IO.Compression.Zip.ArchiveStream.CanRead">
            <inheritdoc />
        </member>
        <member name="P:MathService.IO.Compression.Zip.ArchiveStream.CanSeek">
            <inheritdoc />
        </member>
        <member name="P:MathService.IO.Compression.Zip.ArchiveStream.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:MathService.IO.Compression.Zip.ArchiveStream.Length">
            <inheritdoc />
        </member>
        <member name="P:MathService.IO.Compression.Zip.ArchiveStream.Position">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.Compression.Zip.ArchiveStream.Flush">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.Compression.Zip.ArchiveStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.Compression.Zip.ArchiveStream.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.Compression.Zip.ArchiveStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.Compression.Zip.ArchiveStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.Compression.Zip.ArchiveStream.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:MathService.IO.LegacyStream">
            <summary>Поток данных, смещённый относительно исходного и ограниченный по размеру</summary>
        </member>
        <member name="F:MathService.IO.LegacyStream._BaseStream">
            <summary>Поток-источник данных</summary>
        </member>
        <member name="F:MathService.IO.LegacyStream._DataOffset">
            <summary>Смещение потока относительного исходного</summary>
        </member>
        <member name="F:MathService.IO.LegacyStream._DataLength">
            <summary>Количество байт данных в потоке</summary>
        </member>
        <member name="F:MathService.IO.LegacyStream._CanExpand">
            <summary>Возможность растягивать исходный поток</summary>
        </member>
        <member name="P:MathService.IO.LegacyStream.BaseStream">
            <summary>Поток-источник данных</summary>
        </member>
        <member name="P:MathService.IO.LegacyStream.DataOffset">
            <summary>Смещение потока относительного исходного</summary>
            <exception cref="T:System.ArgumentOutOfRangeException" accessor="set">Если передано значение меньше нуля.</exception>
        </member>
        <member name="P:MathService.IO.LegacyStream.CanRead">
            <inheritdoc />
        </member>
        <member name="P:MathService.IO.LegacyStream.CanSeek">
            <inheritdoc />
        </member>
        <member name="P:MathService.IO.LegacyStream.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:MathService.IO.LegacyStream.CanExpand">
            <summary>Возможность растягивать исходный поток</summary>
        </member>
        <member name="P:MathService.IO.LegacyStream.Length">
            <inheritdoc />
        </member>
        <member name="P:MathService.IO.LegacyStream.Position">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.LegacyStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.LegacyStream.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.LegacyStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.LegacyStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.LegacyStream.Flush">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.LegacyStream.ReadByte">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.LegacyStream.WriteByte(System.Byte)">
            <inheritdoc />
        </member>
        <member name="M:MathService.IO.LegacyStream.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:MathService.JSON.JSONObjectCreatorBase">
            <summary>Базовый класс генераторов JSON объектов</summary>
        </member>
        <member name="M:MathService.JSON.JSONObjectCreatorBase.Create(System.Object)">
            <summary>Создать объект JSON</summary>
            <param name="obj">Объект-прототип, на основе которого генерируется JSON-объекта</param>
            <returns>Объект JSON</returns>
        </member>
        <member name="T:MathService.JSON.JSONObjectCreator`1">
            <summary>Генератор JSON-объекта по объекту-прототипу</summary>
            <typeparam name="T">ТИп объкета-прототипа</typeparam>
        </member>
        <member name="F:MathService.JSON.JSONObjectCreator`1._Obj">
            <summary>Объект-прототип</summary>
        </member>
        <member name="F:MathService.JSON.JSONObjectCreator`1._FieldsDescriptions">
            <summary>Список именованных методов получения JSON-объектов - полей из объекта-прототипа</summary>
        </member>
        <member name="M:MathService.JSON.JSONObjectCreator`1.#ctor(`0)">
            <summary>Инициализация нового генератора JSON-объектов</summary>
            <param name="obj"></param>
        </member>
        <member name="M:MathService.JSON.JSONObjectCreator`1.AddField(System.String,System.Func{`0,System.Object})">
            <summary>Добавить новый метод определения поля JSON-объекта из объекта-прототипа</summary>
            <param name="Name">Имя поля</param>
            <param name="Field">Метод получения JSON-объекта поля</param>
            <returns>Генератор JSON-объектов с добавленным методом</returns>
        </member>
        <member name="M:MathService.JSON.JSONObjectCreator`1.Create">
            <summary>Создать JSON-объект из исходного объекта-прототипа</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.JSON.JSONObjectCreator`1.Create(System.Object)">
            <summary>Создать JSON-объект из указанного объекта-прототипа</summary>
            <param name="obj">Объект-прототип</param>
            <returns>JSON-объект</returns>
        </member>
        <member name="M:MathService.JSON.JSONObjectCreator`1.Create(`0)">
            <summary>Создать JSON-объект из указанного объекта-прототипа</summary>
            <param name="obj">Объект-прототип</param>
            <returns>JSON-объект</returns>
        </member>
        <member name="M:MathService.JSON.JSONObjectCreator`1.op_Implicit(MathService.JSON.JSONObjectCreator{`0})~MathService.JSON.JSONObject">
            <summary>Оператор неявного приведения типа объекта-генератора к типу JSON-объекта</summary>
            <param name="creator">Объект-генератор</param>
        </member>
        <member name="T:MathService.JSON.JSONObject">
            <summary>Парсер структуры JSON</summary>
        </member>
        <member name="F:MathService.JSON.JSONObject._Name">
            <summary>Имя структуры</summary>
        </member>
        <member name="F:MathService.JSON.JSONObject._Data">
            <summary>Значение структуры</summary>
        </member>
        <member name="F:MathService.JSON.JSONObject._Fields">
            <summary>Словарь полей структуры по ключу-имени поля</summary>
        </member>
        <member name="P:MathService.JSON.JSONObject.Name">
            <summary>Имя структуры</summary>
        </member>
        <member name="P:MathService.JSON.JSONObject.Data">
            <summary>Значение структуры</summary>
        </member>
        <member name="P:MathService.JSON.JSONObject.IsComplex">
            <summary>Признак того, что структура является сложной - со вложенными полями</summary>
        </member>
        <member name="P:MathService.JSON.JSONObject.Fields">
            <summary>Перечисление имён полей структуры</summary>
        </member>
        <member name="P:MathService.JSON.JSONObject.Item(System.String)">
            <summary>Перечисление полей структуры по указанному имени</summary>
            <param name="Field">Имя поля структуры</param>
            <returns>Вложенные поля с указаным именем</returns>
        </member>
        <member name="M:MathService.JSON.JSONObject.#ctor(System.String)">
            <summary>Инициализация новой структуры JSON из строкового представления</summary>
            <param name="str">Строковое представление структуры JSON</param>
        </member>
        <member name="M:MathService.JSON.JSONObject.#ctor(System.String,System.String)">
            <summary>Инициализация новой структуры JSON из строкового представления с указанием имени</summary>
            <param name="Name">Имя структуры</param>
            <param name="str">Строковое представление структуры JSON</param>
        </member>
        <member name="M:MathService.JSON.JSONObject.ToInt(System.Nullable{System.Int32})">
            <summary>Преобразование значения структуры к целому числу</summary>
            <param name="Default">Значение по умолчанию</param>
            <returns>Целочисленное значение структуры, либо значение по умолчанию, если преобразование невозможно</returns>
        </member>
        <member name="M:MathService.JSON.JSONObject.ToDouble(System.Nullable{System.Double})">
            <summary>Преобразование значения структуры к вещественному числу</summary>
            <param name="Default">Значение по умолчанию</param>
            <returns>Вещественное значение структуры, либо значение по умолчанию, если преобразование невозможно</returns>
        </member>
        <member name="M:MathService.JSON.JSONObject.ToBool(System.Nullable{System.Boolean})">
            <summary>Преобразование значения структуры к логическому значению</summary>
            <param name="Default">Значение по умолчанию</param>
            <returns>Логическое значение структуры, либо значение по умолчанию, если преобразование невозможно</returns>
        </member>
        <member name="M:MathService.JSON.JSONObject.ToString">
            <summary>Строковое представление структуры</summary>
            <returns>Строковое представление структуры</returns>
        </member>
        <member name="M:MathService.JSON.JSONObject.op_Implicit(MathService.JSON.JSONObject)~System.String">
            <summary>Оператор неявного приведения структуры JSON к строковому значению</summary>
            <param name="json">Структура JSON</param>
        </member>
        <member name="M:MathService.JSON.JSONObject.GetText(System.String,System.Int32@,System.String,System.String)">
            <summary>
            Выделение подстроки, ограниченной шаблоном начала и шаблоном окончания строки начиная с указанного смещения
            </summary>
            <param name="Str">Входная строка</param>
            <param name="Offset">
            Смещение во входной строке начала поиска - в конце работы метода соответствует месту окончания поиска
            </param>
            <param name="Open">Шаблон начала подстроки</param>
            <param name="Close">Шаблон окончания подстроки</param>
            <returns>Подстрока, заключённая между указанными шаблонами начала и окончания</returns>
            <exception cref="T:System.FormatException">
            Если шаблон завершения строки на нейден, либо если количество шаблонов начала строки превышает 
            количество шаблонов окончания во входной строке
            </exception>
        </member>
        <member name="P:MathService.LambdaDictionary`2.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:MathService.LambdaDictionary`2.Count">
            <inheritdoc />
        </member>
        <member name="P:MathService.LambdaDictionary`2.Keys">
            <inheritdoc />
        </member>
        <member name="P:MathService.LambdaDictionary`2.Values">
            <inheritdoc />
        </member>
        <member name="P:MathService.LambdaDictionary`2.Item(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathService.LambdaDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathService.LambdaDictionary`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:MathService.LambdaDictionary`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:MathService.LambdaDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathService.LambdaDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathService.LambdaDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathService.LambdaDictionary`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathService.LambdaDictionary`2.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathService.LambdaDictionary`2.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="M:MathService.LambdaDictionary`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathService.LambdaDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathService.LambdaEqualityComparer`1.Equals(`0,`0)">
            <summary>Определяет, равны ли два указанных объекта.</summary>
            <returns>Значение true, если указанные объекты равны; в противном случае — значение false.</returns>
            <param name="x">Первый сравниваемый объект типа <typeparam name="T"/>.</param>
            <param name="y">Второй сравниваемый объект типа <typeparam name="T"/>.</param>
        </member>
        <member name="M:MathService.LambdaEqualityComparer`1.GetHashCode(`0)">
            <summary>Возвращает хэш-код указанного объекта.</summary>
            <returns>Хэш-код указанного объекта.</returns>
            <param name="obj">Объект <see cref="T:System.Object"/>, для которого должен быть возвращен хэш-код.</param>
            <exception cref="T:System.ArgumentNullException">Тип <paramref name="obj"/> является ссылочным типом, значением <paramref name="obj"/> является null.</exception>
        </member>
        <member name="T:MathService.LambdaKeyedCollection`2">
            <summary>Коллекция, ключи которой определяются указанным методом на основе значений элементов</summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения элемента</typeparam>
        </member>
        <member name="F:MathService.LambdaKeyedCollection`2._KeyExtractor">
            <summary>Метод определения ключа элемента</summary>
        </member>
        <member name="M:MathService.LambdaKeyedCollection`2.#ctor(System.Func{`1,`0})">
            <summary>Инициализация новой коллекции, ключи которой определяются на основе значений элементов</summary>
            <param name="KeyExtractor">Метод определения ключа элемента</param>
        </member>
        <member name="M:MathService.LambdaKeyedCollection`2.#ctor(System.Func{`1,`0},System.Collections.Generic.IEnumerable{`1})">
            <summary>Инициализация новой коллекции, ключи которой определяются на основе значений элементов</summary>
            <param name="KeyExtractor">Метод определения ключа элемента</param>
            <param name="Values">Коллекция элементов</param>
        </member>
        <member name="M:MathService.LambdaKeyedCollection`2.GetKeyForItem(`1)">
            <inheritdoc />
        </member>
        <member name="M:MathService.LamdaComparer`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:MathService.LamdaComparer`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:MathService.MathParser.BlockTerm">
            <summary>Элемент мат.выражения - блок со скобками</summary>
        </member>
        <member name="F:MathService.MathParser.BlockTerm._OpenBracket">
            <summary>Строковое значение открывающейся скобки</summary>
        </member>
        <member name="F:MathService.MathParser.BlockTerm._CloseBracket">
            <summary>Строковое значение закрывающейся скобки</summary>
        </member>
        <member name="F:MathService.MathParser.BlockTerm._Terms">
            <summary>Массив элементов подвыражения</summary>
        </member>
        <member name="P:MathService.MathParser.BlockTerm.OpenBracket">
            <summary>Строковое значение открывающейся скобки</summary>
        </member>
        <member name="P:MathService.MathParser.BlockTerm.CloseBracket">
            <summary>Строковое значение закрывающейся скобки</summary>
        </member>
        <member name="P:MathService.MathParser.BlockTerm.Terms">
            <summary>Массив элементов подвыражения</summary>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.#ctor(System.String)">
            <summary>Новый блок математического выражения</summary>
            <param name="Str">Строковое значение блока</param>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.#ctor(System.String,System.String,System.String)">
            <summary>Новый блок выражения</summary>
            <param name="OpenBracket">Открывающаяся скобка</param>
            <param name="Str">Строковое значение блока</param>
            <param name="CloseBracket">Закрывающаяся скобка</param>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.GetNumberString(System.String,System.Int32@)">
            <summary>Получить цифровую строку</summary>
            <param name="Str">Исследуемая строка</param>
            <param name="pos">Исходная позиция в строке</param>
            <returns>Строка цифрового значения</returns>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.GetNameString(System.String,System.Int32@)">
            <summary>Получить имя из строки</summary>
            <param name="Str">Исходная строка</param>
            <param name="pos">Положение в строке</param>
            <returns>Строка имени</returns>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.GetTerms(System.String)">
            <summary>Получить список элементов математического выражения из строки</summary>
            <param name="Str">Строковое представление математического выражения</param>
            <returns>Массив элементов математического выражения</returns>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.ToString">
            <summary>Преборазование в строковое представление</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathService.MathParser.BlockTerm.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Получить корень поддерева выражений</summary>
            <param name="Parser">Парсер выражения</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Корень поддерева</returns>
        </member>
        <member name="T:MathService.MathParser.Bracket">
            <summary>Скобки</summary>
        </member>
        <member name="P:MathService.MathParser.Bracket.NewRound">
            <summary>Круглые скобки</summary>
        </member>
        <member name="P:MathService.MathParser.Bracket.NewRect">
            <summary>Квадратные скобки</summary>
        </member>
        <member name="P:MathService.MathParser.Bracket.NewFigur">
            <summary>Фигурные скобки</summary>
        </member>
        <member name="P:MathService.MathParser.Bracket.Start">
            <summary>Открывающая скобка</summary>
        </member>
        <member name="P:MathService.MathParser.Bracket.Stop">
            <summary>Закрывающая скобка</summary>
        </member>
        <member name="M:MathService.MathParser.Bracket.#ctor(System.String,System.String)">
            <summary>Скобки</summary>
            <param name="Start">Строка открывающей скобки</param>
            <param name="Stop">Строка закрывающей скобки</param>
        </member>
        <member name="M:MathService.MathParser.Bracket.Equals(MathService.MathParser.Bracket)">
            <summary>Проверка на эквивалентность другим скобкам</summary>
            <param name="other">Проверяемые на эквивалентность скобки</param>
            <returns>Истина, если проверяемые скобки эквивалентны данным</returns>
        </member>
        <member name="M:MathService.MathParser.Bracket.Equals(System.Object)">
            <summary>Проверка на эквивалентность</summary>
            <param name="obj">Проверяемый объект</param>
            <returns>Истина, если объект - скобки и вид скобок совпадает</returns>
        </member>
        <member name="M:MathService.MathParser.Bracket.GetHashCode">
            <summary>Получить хэш-код</summary>
            <returns>Хэш-код</returns>
        </member>
        <member name="M:MathService.MathParser.Bracket.Clone">
            <summary>Клонирование скобок</summary>
            <returns>Клон скобок</returns>
        </member>
        <member name="M:MathService.MathParser.Bracket.ToString">
            <summary>Строковое представление скобок</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathService.MathParser.Bracket.Suround(System.String)">
            <summary>Разместить текст в скобках</summary>
            <param name="str">Размещаемый текст</param>
            <returns>Текст в скобках</returns>
        </member>
        <member name="T:MathService.MathParser.CharTerm">
            <summary>Символьный элемент математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.CharTerm.Value">
            <summary>Символьное значение элемента</summary>
        </member>
        <member name="M:MathService.MathParser.CharTerm.#ctor(System.Char)">
            <summary>Новый символьный элемент</summary>
            <param name="c">Символьное значение элемента</param>
        </member>
        <member name="M:MathService.MathParser.CharTerm.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Получить поддерево</summary>
            <param name="Parser">Парсер мат.выражения</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Результат вызова метода Parser.GetOperatorNode(Value)</returns>
        </member>
        <member name="M:MathService.MathParser.DifferentialOperator.#ctor">
            <inheritdoc />
        </member>
        <member name="M:MathService.MathParser.DifferentialOperator.GetValue(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <inheritdoc />
        </member>
        <member name="M:MathService.MathParser.DifferentialOperator.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <inheritdoc />
        </member>
        <member name="M:MathService.MathParser.DifferentialOperator.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <inheritdoc />
        </member>
        <member name="T:MathService.MathParser.FunctionalsCollection">
            <summary>Коллекция функционалов</summary>
        </member>
        <member name="F:MathService.MathParser.FunctionalsCollection._Operators">
            <summary>Список функционалов</summary>
        </member>
        <member name="F:MathService.MathParser.FunctionalsCollection._Expression">
            <summary>Ссылка на математическое выражение, с которым связана поллекция</summary>
        </member>
        <member name="P:MathService.MathParser.FunctionalsCollection.Count">
            <summary>Количество функционалов в коллекции</summary>
        </member>
        <member name="M:MathService.MathParser.FunctionalsCollection.#ctor(MathService.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции функционалов</summary>
            <param name="Expression">Математическое выражение, на которое ссылается коллекция</param>
        </member>
        <member name="M:MathService.MathParser.FunctionalsCollection.Add(MathService.MathParser.Functional)">
            <summary>Добавить функционал в коллекцию</summary>
            <param name="Operator">Добавляемый функционал</param>
            <returns>Истина, если добавление прошло успешно</returns>
        </member>
        <member name="M:MathService.MathParser.FunctionalsCollection.System#Collections#Generic#IEnumerable{MathService#MathParser#Functional}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            An enumerator that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathService.MathParser.FunctionalsCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.MathParser.FunctionalsCollection.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.MathParser.Functional">
            <summary>Функционал</summary>
        </member>
        <member name="M:MathService.MathParser.Functional.#ctor(System.String)">
            <summary>Инициализация нового функционала</summary>
            <param name="Name">Имя функционала</param>
        </member>
        <member name="M:MathService.MathParser.Functional.GetValue">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="M:MathService.MathParser.Functional.GetValue(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Метод определения значения</summary>
            <param name="ParametersExpression">Выражение параметров</param>
            <param name="Function">Ядро функционала</param>
            <returns>Численное значение вычисленного выражения</returns>
        </member>
        <member name="M:MathService.MathParser.Functional.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="M:MathService.MathParser.Functional.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Function">Выражение ядра функции</param>
            <param name="Parameters">Массив параметров</param>
            <param name="ParametersExpression">Выражение параметров</param>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="M:MathService.MathParser.Functional.Initialize(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Инициализация оператора</summary>
            <param name="Parameters">Блок параметров</param>
            <param name="Function">Блок ядра функции</param>
            <param name="Parser">Парсер мат.выражения</param>
            <param name="Expression">Внешнее мат.выражение</param>
        </member>
        <member name="T:MathService.MathParser.FunctionalTerm">
            <summary>Блок определения функции</summary>
        </member>
        <member name="P:MathService.MathParser.FunctionalTerm.Parameters">
            <summary>Параметры оператора</summary>
        </member>
        <member name="M:MathService.MathParser.FunctionalTerm.#ctor(MathService.MathParser.FunctionTerm,MathService.MathParser.BlockTerm)">
            <summary>Инициализация блока комплексного оператора</summary>
            <param name="Header">Заголовок блока</param>
            <param name="Body">Тело блока</param>
        </member>
        <member name="M:MathService.MathParser.FunctionalTerm.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Получить поддерево комплексного оператора</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел комплексного оператора</returns>
        </member>
        <member name="M:MathService.MathParser.FunctionalTerm.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление элемента</returns>
        </member>
        <member name="T:MathService.MathParser.ConstantsCollection">
            <summary>Коллекция констант</summary>
        </member>
        <member name="F:MathService.MathParser.ConstantsCollection._Expression">
            <summary>Ссылка на выражение</summary>
        </member>
        <member name="F:MathService.MathParser.ConstantsCollection._Items">
            <summary>Элементы коллекци</summary>
        </member>
        <member name="P:MathService.MathParser.ConstantsCollection.Count">
            <summary>Количество элементов коллекции</summary>
        </member>
        <member name="P:MathService.MathParser.ConstantsCollection.Item(System.String)">
            <summary>Итератор констант по имени</summary>
            <param name="Name">Имя константы</param>
            <returns>Константа с указанным именем</returns>
        </member>
        <member name="M:MathService.MathParser.ConstantsCollection.#ctor(MathService.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции констант</summary>
            <param name="Expression">Математическое выражение, которому принадлежит коллекция</param>
        </member>
        <member name="M:MathService.MathParser.ConstantsCollection.Add(MathService.MathParser.ExpressionVariabel)">
            <summary>Добавить элемент в коллекцию</summary>
            <param name="Constant">Добавляемое значение, как константа</param>
        </member>
        <member name="M:MathService.MathParser.ConstantsCollection.GetNames">
            <summary>Получить имена констант колеекции</summary>
            <returns>Перечисление имён констант колеекции</returns>
        </member>
        <member name="M:MathService.MathParser.ConstantsCollection.System#Collections#Generic#IEnumerable{MathService#MathParser#ExpressionVariabel}#GetEnumerator">
            <summary>Получить перечислитеь констант коллекци</summary>
            <returns>Перечислитель констант</returns>
        </member>
        <member name="M:MathService.MathParser.ConstantsCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитеь констант коллекци</summary>
            <returns>Перечислитель констант</returns>
        </member>
        <member name="T:MathService.MathParser.EventExpressionVariable">
            <summary>Событийная переменная</summary>
            <remarks>Переменная математического выражения, значение которой определяется через генерацию события</remarks>
        </member>
        <member name="E:MathService.MathParser.EventExpressionVariable.Call">
            <summary>Событие запроса значения переменной</summary>
        </member>
        <member name="M:MathService.MathParser.EventExpressionVariable.OnCall(System.EventArgs{System.Double})">
            <summary>Метод генерации события</summary>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="F:MathService.MathParser.EventExpressionVariable._EventArg">
            <summary>Аргумент события</summary>
        </member>
        <member name="F:MathService.MathParser.EventExpressionVariable._ClearAtCall">
            <summary>Флаг предварительной очистки значения аргумента события</summary>
        </member>
        <member name="P:MathService.MathParser.EventExpressionVariable.Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="P:MathService.MathParser.EventExpressionVariable.IsPrecomputable">
            <summary>Признак предвычислимости всегда = false</summary>
        </member>
        <member name="P:MathService.MathParser.EventExpressionVariable.ClearAtCall">
            <summary>Флаг предварительной очистки значения аргумента события</summary>
        </member>
        <member name="M:MathService.MathParser.EventExpressionVariable.#ctor">
            <summary>Инициализация новой событийной переменной</summary>
        </member>
        <member name="M:MathService.MathParser.EventExpressionVariable.#ctor(System.String)">
            <summary>Инициализация новой событийной переменной</summary>
            <param name="Name">Имя переменной</param>
        </member>
        <member name="M:MathService.MathParser.EventExpressionVariable.GetValue">
            <summary>Получение значения переменной</summary>
            <returns>Значение переменой</returns>
        </member>
        <member name="M:MathService.MathParser.EventExpressionVariable.Clone">
            <summary>Метод клонирования событийной переменной</summary>
            <returns>Клонированная событийная переменная</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionFunction">
            <summary>функция в структуре математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionFunction.Delegate">
            <summary>Делегат функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionFunction.Arguments">
            <summary>Массив имён аргументов</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionFunction.#ctor(System.String,System.String[])">
            <summary>Инициализация новой функции структуры математического выражения по сигнатуре</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">списко имён аргументов</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionFunction.GetValue(System.Double[])">
            <summary>Метод получения значения функции по массиву значений её аргументов</summary>
            <param name="arguments">Массив аргументов функции</param>
            <returns>Значение функции</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionFunction.IsEqualSignature(System.String,System.Int32)">
            <summary>Проверка на эквивалентность сигнатуре</summary>
            <param name="sName">Имя функции</param>
            <param name="ArgumentsCount">Количество аргументов</param>
            <returns>Истина, если сигнатура соответствует функции</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionFunction.IsEqualSignature(System.String,System.String[])">
            <summary>Проверка на эквивалентность сигнатуре</summary>
            <param name="sName">Имя функции</param>
            <param name="Arguments">Массив имён аргументов</param>
            <returns>Истина, если сигнатура соответствует функции</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionFunction.GetValue">
            <summary>Метод получения значения функции. В общем виде не поддерживается.</summary>
            <returns>Значение функции</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionFunction.Clone">
            <summary>Клонирование функции</summary>
            <returns>Клон функции</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionItem">
            <summary>Элемент математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionItem.Name">
            <summary>Имя</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionItem.#ctor">
            <summary>Инициализация нового элемента математического выражения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionItem.#ctor(System.String)">
            <summary>Инициализация нового элемента математического выражения</summary><param name="Name">Имя элемента</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionItem.GetValue">
            <summary>Метод определения значения</summary><returns>Численное значение элемента выражения</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionOperator">
            <summary>Оператор</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionOperator.GetValue">
            <summary>Получить значение</summary>
            <returns>Значение оператора</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode">
            <summary>Узел дерева выражений, реализующий оператор сложения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.#ctor">
            <summary>Новый оператор сложения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Compute">
            <summary>Вычисление узла</summary>
            <returns>Сумма поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Linq.Expression.Add()</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Linq.Expression.Add()</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Полный клон узла с клонами поддеревьев</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.AndOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор ленивого И</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AndOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора ленивого И</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AndOperatorNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AndOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию И</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AndOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию И</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.AndOperatorNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.CharNode">
            <summary>Символьный узел дерева математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.CharNode.Value">
            <summary>Значение символа узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.CharNode.#ctor">
            <summary>Инициализация нового строкового узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.CharNode.#ctor(System.Char)">
            <summary>Инициализация нового строкового узла</summary>
            <param name="value">Значение узла</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.CharNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.CharNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.CharNode.op_Implicit(System.Char)~MathService.MathParser.ExpressionTrees.Nodes.CharNode">
            <summary>Оператор неявного преобразования строки к типу строкового узла</summary>
            <param name="value">Строковое значение</param>
            <returns>Символьный узел</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.CharNode.op_Implicit(MathService.MathParser.ExpressionTrees.Nodes.CharNode)~System.Char">
            <summary>Оператор неявного преобразования строкового узла к символьному типу</summary>
            <param name="node">Символьный узел</param>
            <returns>Значение Символьного узла</returns>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Name">
            <summary>Имя узла</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode._ParametersExpression">
            <summary>Выражение параметров</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode._CoreExpression">
            <summary>Выражение ядра функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Parameters">
            <summary>Выражение параметров</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Core">
            <summary>Выражение ядра функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Operator">
            <summary>Оператор</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Parameters">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.ToString">
            <summary>Преобразование узла в строку</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionalNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode">
            <summary>Узел дерева мат.выражения, реализующий скобки с возможностью вычисления</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode._Bracket">
            <summary>Скобки</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Bracket">
            <summary>Скобки</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.#ctor(MathService.MathParser.Bracket,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Вычислимыый блочный узел дерева</summary>
            <param name="bracket">Скобки</param>
            <param name="Node">Узел-содержимое</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Compute">
            <summary>Вычислить значение узла</summary>
            <returns>Значение вложенного узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Компиляция содержимого узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла с параметрами</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Компиляция вложенного узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Clone">
            <summary>Клон узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ComputedNode">
            <summary>Вычислимый узел дерева математического выражения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ComputedNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Parameters">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode">
            <summary>Узел дерева, хранящий константное значение</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode._Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.IsPrecomputable">
            <summary>Флаг возможности получения значения без выччисления. Всегда = true</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.Value">
            <summary>Значение узла. Не поддерживает присвоение</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.#ctor">
            <summary>Инициализация константного узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.#ctor(System.Double)">
            <summary>Инициализация константного узла</summary>
            <param name="Value">Значение узла</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.#ctor(System.Int32)">
            <summary>Инициализация константного узла</summary>
            <param name="Value">Значение узла</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Parameters">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ConstValueNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор деления</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.#ctor">
            <summary>Инициализация узла оператора деления</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Значение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла с параметрами</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Clone">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор равенства</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.GetAbsMethodCall(System.Linq.Expressions.Expression)">
            <summary>Получить выражение вызова метода определения модуля числа из класса Math</summary>
            <param name="x">Параметр выражения</param>
            <returns>Выражение Linq.Expression, Вызывающее метод Math.Abs с параметром x</returns>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.__Epsilon">
            <summary>Точность вычисления равенства для чисел с плавающей точкой</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Epsilon">
            <summary>Точность вычисления равенства для чисел с плавающей точкой</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора равенства</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора равенства</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод сравнения</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Равенство</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Равенство</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode">
            <summary>Узел дерева вычислений</summary>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator">
            <summary>Перечислитель предков узла</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.Node">
            <summary>Исходный узел</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.Item(System.Int32)">
            <summary>Итератор предков узла, где узел с индексом 0 - первый предок узла</summary>
            <param name="i">Номер предка</param>
            <returns>Предок указанного поколения</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Новый итератор предков узла</summary>
            <param name="Node">Обрабатываемый узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.System#Collections#Generic#IEnumerable{MathService#MathParser#ExpressionTrees#Nodes#ExpressionTreeNode}#GetEnumerator">
            <summary>Получить перечислитель предков узла</summary>
            <returns>Перечислитель предков узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитель</summary>
            <returns>Перечислитель</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.GetParrentsEnumerable">
            <summary>Метод получения перечисления предков узла</summary>
            <returns>Перечисление предков узла</returns>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode._Left">
            <summary>Узел левого поддерева</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode._Right">
            <summary> Узел правого поддерева</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsPrecomputable">
            <summary>Признак возможности получения тревиального значения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsRoot">
            <summary>Является ли узел дерева корнем?</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsLeftSubtree">
            <summary>Признак - является ли текущий узел левым поддеревом</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsRightSubtree">
            <summary>Признак - является ли текущий узел правым поддеревом</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Parent">
            <summary>Ссылка на предка узла</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Left">
            <summary>Левое поддерево</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Right">
            <summary>Правое поддерево</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.RightNodes">
            <summary>Перечисление правых узлов правого поддерева включая корень</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.LeftNodes">
            <summary>Перечисление левых узлов левого поддерева включая корень</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Parents">
            <summary>Перечислитель предков узла</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Root">
            <summary>Ссылка на корень дерева</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Depth">
            <summary>Глубина положения узла в дереве</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.LastLeftChild">
            <summary>Самый левый дочерний узел, либо текущий</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.LastRightChild">
            <summary>Самый правый дочерний узел, либо текущий</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Item(System.String)">
            <summary>Доступ к элементам узла по указанному пути</summary>
            <param name="Path">Путь к элементам узла Пример:.\.\l\r\r\l  ..\l\r\r</param>
            <returns>Элемент узла, выбранный по указанному пути</returns>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Item(System.Func{MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode})">
            <summary>Доступ к дочерним элементам узла с помощью метода выбора</summary>
            <param name="ChildSelector">Метод выбора элементов узла</param>
            <returns>Перечисление дочерних элементов по указанному методу</returns>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Item(System.Func{MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode})">
            <summary> Итератор элементов узла методом выборки</summary>
            <param name="Selector">Метод выбборки узлов относительно текущего</param>
            <returns>Перечисление узлов по указанному методу</returns>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Path">
            <summary>Путь к узлу</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Bypassing(MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType)">
            <summary>Метод обхода дерева</summary>
            <param name="type">Тип обхода дерева</param>
            <returns>Перечисление элементов дерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetChilds">
            <summary>Перечисление дочерних элементов дерева</summary>
            <returns>Перечисление дочерних элементов дерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.SwapToChild(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Поменять узел местами с дочерним</summary>
            <param name="Parent">Материнский узел</param>
            <param name="Child">Дочерний узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Swap(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Подменить узел А узлом В</summary>
            <param name="A">Замещаемый узел</param>
            <param name="B">Подменяемый узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.SwapTo(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Заменить узел на указанный</summary>
            <param name="Node">Ухел, на который производится замена</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Remove">
            <summary>Удалить узел с перекоммутацией ссылок</summary>
            <returns>Если удаляется корень, то левое поддерево, иначе ссылка не предка узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetNextLeft">
            <summary>Получить следующий узел слева</summary>
            <returns>Узел слева от текущего</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetNextRight">
            <summary>Получить следующий узел справа</summary>
            <returns>Узел справа от текущего</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetVariables">
            <summary>Перечисление переменных, известных данному узлу дерева</summary>
            <returns>Перечисление всех известных данному узлу дерева переменных</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetFunctions">
            <summary>Перечисление функций, известных данному узлу дерева</summary>
            <returns>Перечисление всех известных данному узлу дерева функций</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetFunctionals">
            <summary>Перечисление функционалов, известных данному узлу дерева</summary>
            <returns>Перечисление всех известных данному узлу дерева функционалов</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Dispose">
            <summary>Уничтожить узел рекурентно с поддеревьями</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ToString">
            <summary>Преобразование узла в строку</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.System#ICloneable#Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.op_Implicit(System.String)~MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode">
            <summary>Оператор неявного преобразования строки в узел дерева</summary>
            <param name="value">Строковое значение</param>
            <returns>Строковый узел дерева</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode">
            <summary>Узел дерева выражения, содержащий сведенья об аргументе функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.ArgumentNode">
            <summary>Узел аргумента</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.ArgumentName">
            <summary>Узел имени аргумента</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.#ctor">
            <summary>Инициализация узла дерева информации об аргументе функции</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.#ctor(System.String,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация узла дерева информации об аргументе функции</summary>
            <param name="Name">Имя</param>
            <param name="Expression">Узел выражения аргумента</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.StringNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация узла дерева информации об аргументе функции</summary>
            <param name="Name">Имя</param>
            <param name="Expression">Выражение узла</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Compute">
            <summary>Метод вычисления значения узла</summary>
            <returns>Значение аргумента</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Compile">
            <summary>Компиляция узла аргумента</summary>
            <returns>Скомпилированное выражение</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла аргумента с учётом списка параметров</summary>
            <param name="Parameters">Массив параметров процесса компиляции</param>
            <returns>Скомпилированное значение узла аргумента дерева выражения</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode">
            <summary>Узел дерева мат.выражения, хранящий данные об аргументе функции</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.EnumArguments(MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode)">
            <summary>Перечисление аргументов начиная с указанного</summary>
            <param name="Node">Первый узел аргумента</param>
            <returns>Перечисление пар имени-корня дерева аргумента</returns>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.ArgumentSubtree">
            <summary>Значение аргумента - правое поддерево</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.ArgumentName">
            <summary>Имя аргумента - левое поддерево</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.#ctor">
            <summary>Инициализация узла-аргумента</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.#ctor(System.String,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация узла-аргумента</summary>
            <param name="Name">Имя аргумента</param>
            <param name="Node">Узел поддерева аргумента</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode)">
            <summary>Инициализация узла-аргумента</summary>
            <param name="Node">Узел поддерева аргумента</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Значение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Compile">
            <summary>Компиляция узла аргумента</summary>
            <returns>Скомпилированное выражение корня поддерева аргумента</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла аргумента</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Скомпилированное выражение корня поддерева аргумента</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клонирование узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode">
            <summary>Узел дерева выражения, содержащий функцию</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Name">
            <summary>Имя функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.ArgumentsNames">
            <summary>Массив имён аргументов функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Arguments">
            <summary>Перечисление аргументов функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Function">
            <summary>Функция узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor">
            <summary>Инициализация нового функционального узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor(System.String)">
            <summary>Инициализация нового функционального узла</summary>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.StringNode)">
            <summary>Инициализация нового функционального узла</summary>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor(MathService.MathParser.FunctionTerm,MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Инициализация нового функционального узла</summary>
            <param name="Term">Выражение функции</param>
            <param name="Parser">Парсер выражения</param>
            <param name="Expression">Математическое выражение</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Значение функции</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.GetFunctionArgumentNodes(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Получить перечисление аргументов функции</summary>
            <param name="FunctionNode">Узел функции</param>
            <returns>Перечисление аргументов функции</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.FunctionNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор больше</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора больше</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора больше</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод сравнения</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>1 - если x больше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Больше</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Больше</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор меньше</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора меньше</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора меньше</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод сравнения</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>1 - если x меньше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Меньше</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Меньше</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.LogicOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий логическую операцию</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее логику оператора</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее логику оператора</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор умножения "*"</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора произведения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора произведения</summary>
            <param name="Left">Левое поддерево произведения</param>
            <param name="Right">Правое поддерево произведения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Произведение значений корней правого и левого поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор отрицания</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора меньше</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора меньше</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод отрицания</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>1 - если x меньше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.ComparerSingle(System.Double)">
            <summary>Метод отрицания</summary>
            <param name="x">Значение</param>
            <returns>1 - если x меньше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию отрицания НЕ</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию отрицания НЕ</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.NotOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode">
            <summary>Узел деерва мат.выражения, реализующий оператор</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.IsPrecomputable">
            <summary>Оператор является предвычислимым если предвычислимы его правое и левое поддерево</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.Priority">
            <summary>Приоритет оператора</summary>
            <remarks>
            Чем выше приоритет, тем глубже в дереве должен находиться оператор
            Шакала базовых приоритетов:
             + - 0
             - - 5
             * - 10
             / - 15
             ^ - 20
            </remarks>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.Name">
            <summary>Ипя оператора</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.#ctor">
            <summary>Инициализация оператора</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.#ctor(System.String)">
            <summary>Инициализация оператора</summary>
            <param name="Name">Имя оператора</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.#ctor(System.String,System.Int32)">
            <summary>Инициализация оператора</summary>
            <param name="Name">Имя оператора</param>
            <param name="Priority">Приоритет оператора</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OperatorNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.OrOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор ленивого ИЛИ</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OrOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора ленивого ИЛИ</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OrOperatorNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OrOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию ИЛИ</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OrOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию ИЛИ</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.OrOperatorNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.PowerOperatorNode">
            <summary>Узел дерева математического выражения, реализующий оператор возведения в степень</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора возведения в степень</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Compute">
            <summary>Вычисление узла выражения</summary>
            <returns>Возведение значения корня левого поддерева в степень значения корня правого поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Compile">
            <summary>Компиляция выражения узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция выражения узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор выбора</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора выбора</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора выбора</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.SubstractionOperatorNode">
            <summary>Узел дерева выражения, релизующий оператор вычитания</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SubstractionOperatorNode.#ctor">
            <summary>Инициализация нового оператора вычитания</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SubstractionOperatorNode.Compute">
            <summary>Вычисление значение узла</summary>
            <returns>Значение разности значений правого и левого поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SubstractionOperatorNode.Compile">
            <summary>Компиляция выражения узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SubstractionOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция выражения узла</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
            <returns></returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.SubstractionOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ValueNode">
            <summary>Узел дерева мат.выражения, хранящий значение</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.ValueNode.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.ValueNode.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode">
            <summary>Узел дерева, хранящий переменную</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.IsPrecomputable">
            <summary>Признак возможности получения тревиального значения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Variable">
            <summary>Ссылка на переменную</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Name">
            <summary>Имя переменной</summary> 
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.#ctor(MathService.MathParser.ExpressionVariabel)">
            <summary>Новый узел переменной</summary>
            <param name="Variable">Переменная</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Parameters">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode">
            <summary>Узел дерева мат.выражения, реазлиующий оператор определения вариантов</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора определения вариантов</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора определения вариантов</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.IntervalNode">
            <summary>Узел интервального значения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.IntervalNode.Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.IntervalNode.Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.IntervalNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.IntervalNode.ToString">
            <summary>Преобразование узла в строку</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.ParsedNode">
            <summary>Узел дерева выражения стадии разбора</summary>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.Nodes.StringNode">
            <summary>Строковый узел дерева математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.Nodes.StringNode.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.StringNode.#ctor">
            <summary>Инициализация нового строкового узла</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.StringNode.#ctor(System.String)">
            <summary>Инициализация нового строкового узла</summary>
            <param name="value">Значение узла</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.StringNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.StringNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.StringNode.op_Implicit(System.String)~MathService.MathParser.ExpressionTrees.Nodes.StringNode">
            <summary>Оператор неявного преобразования строки к типу строкового узла</summary>
            <param name="value">Строковое значение</param>
            <returns>Строковый узел</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.Nodes.StringNode.op_Implicit(MathService.MathParser.ExpressionTrees.Nodes.StringNode)~System.String">
            <summary>Оператор неявного преобразования строкового узла к строковому типу</summary>
            <param name="node">Строковый узел</param>
            <returns>Значение строкового узла</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.ExpressionTree">
            <summary>Дерево выражения</summary>
        </member>
        <member name="T:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType">
            <summary>Метод обхода дерева</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType.LeftRightRoot">
            <summary>Левое поддерево, правое подерево, корень</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType.LeftRootRight">
            <summary>Левое поддерево, корень, правое поддерево</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RootLeftRight">
            <summary>Корень, левое поддерево, правое поддерево</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RightLeftRoot">
            <summary>Правое поддерево, левое поддерево, корень</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RightRootLeft">
            <summary>Правое поддерево, корень, левое поддерево</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RootRightLeft">
            <summary>Корень, правое поддерево, левое поддерево</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionTrees.ExpressionTree.Root">
            <summary>Корень</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.#ctor">
            <summary>Инициализация нового дерева математического выражения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.#ctor(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового дерева математического выражения</summary><param name="Root">Узел - корень дерева</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.Clear">
            <summary>Очистить дерево</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.Remove(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Удалить узел</summary><param name="Node">Удаляемый узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.Swap(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Заменить узел</summary><param name="OldNode">Исходный узел</param><param name="NewNode">Новый узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.MoveParentDown(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Переместить узел вниз</summary><param name="Node">Перемещаемый узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.Bypass(MathService.MathParser.ExpressionTrees.ExpressionTree.BypassingType)">
            <summary>Обойти дерево</summary><param name="type">Способ обхода</param><returns>Перечисление узлов дерева по указанному способу обхода</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.Dispose">
            <summary>Уничтожить дерево</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.ToString">
            <summary>Возвращает объект <see cref="T:System.String"/>, который представляет текущий объект <see cref="T:System.Object"/>.</summary>
            <returns>Объект <see cref="T:System.String"/>, представляющий текущий объект <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.Clone">
            <summary>Клонировать дерево</summary><returns>Клон дерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.System#ICloneable#Clone">
            <summary>Клонировать дерево</summary><returns>Клон дерева</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionTrees.ExpressionTree.GetEnumerator">
            <summary>Получить перечислитель узлов дерева по методу ЛКП</summary><returns>Перечислитель узлов дерева по методу ЛКП</returns>
        </member>
        <member name="T:MathService.MathParser.ExpressionParser">
            <summary>Парсер математических выражений</summary>
        </member>
        <member name="E:MathService.MathParser.ExpressionParser.NewNodeAdded">
            <summary>Событие возникает при добавлении нового узла в дерево выражения</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnNewNodeAdded(System.EventArgs{MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode})">
            <summary>При добавлении нового узла в дерево выражения</summary>
            <param name="e">Аргумент события, содержащий добавляемй узел</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnNewNodeAdded(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode@)">
            <summary>Обработка очередного добавляемого в дерево узла</summary>
            <param name="NewNode">Новый добавляемый узел дерева выражения</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.ProcessNewNode(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode@)">
            <summary>Обработка нового узла дерева выражения</summary>
            <param name="NewNode">Новый добавляемый узел</param>
        </member>
        <member name="E:MathService.MathParser.ExpressionParser.StringPreprocessing">
            <summary>Событие предобработки входящей строки</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnStringPreprocessing(System.EventArgs{System.String})">
            <summary>Генерация события предобработки входящей строки</summary>
            <param name="args">Аргумент события, содержащий обрабатываемую строку</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnStringPreprocessing(System.String@)">
            <summary>Генерация события предобработки входящей строки</summary>
            <param name="StrExpression">Обрабатываемая строка</param>
        </member>
        <member name="T:MathService.MathParser.ExpressionParser.FindFunctionEventArgs">
            <summary>Аргумент события обнаружения функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.FindFunctionEventArgs.Name">
            <summary>Имя обнаруженой функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.FindFunctionEventArgs.Arguments">
            <summary>Массив имён аргументов функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.FindFunctionEventArgs.ArgumentCount">
            <summary>Количество аргументов функции</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.FindFunctionEventArgs.Function">
            <summary>Делегат функции, который надо использовать при её вычислении</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.FindFunctionEventArgs.#ctor(System.String,System.String[])">
            <summary>Инициализация аргумента события обнаружения функции</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Массив имён аргументов функции</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.FindFunctionEventArgs.SignatureEqual(System.String,System.Int32)">
            <summary>Проверка на совпадение сигнатуры функции по имени и числу переменных</summary>
            <param name="name">Имя проверяемой функции</param>
            <param name="ArgumentsCount">Число переменных</param>
            <returns></returns>
        </member>
        <member name="E:MathService.MathParser.ExpressionParser.FindFunction">
            <summary>Событие, возникающее в процессе разбора математического выражения при обнаружении функции</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnFindFunction(MathService.MathParser.ExpressionParser.FindFunctionEventArgs)">
            <summary>Обработчик события обнаружения функции в процессе разбора выражения</summary>
            <param name="Args">Аргументы события, содержащие имя функции, имена аргументов и делегат метода функции</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnFunctionFind(System.String,System.String[])">
            <summary>Обработчик события обнаружения функции в процессе разбора выражения</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Аргументы функции</param>
            <returns>Делегат функции</returns>
        </member>
        <member name="E:MathService.MathParser.ExpressionParser.VariableProcessing">
            <summary>Событие обработки переменных при разборе мат.выражений</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnVariableProcessing(System.EventArgs{MathService.MathParser.ExpressionVariabel})">
            <summary> Обработка обнаруженной переменной</summary>
            <param name="e">Обнаруженная переменная</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.OnVariableProcessing(MathService.MathParser.ExpressionVariabel)">
            <summary> Обработка обнаруженной переменной</summary>
            <param name="Variable">Обнаруженная переменная</param>
        </member>
        <member name="F:MathService.MathParser.ExpressionParser._ExcludeCharsSet">
            <summary>Множество запрещённых символов</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionParser._Constans">
            <summary>Словарь констант</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.ExcludeCharsSet">
            <summary>Множество запрещённых симовлов</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.ExpressionSeparator">
            <summary>Разделитель выражений (по умолчанию ';')</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.DecimalSeparator">
            <summary>Разделитель целой части и мантисы десятичного числа</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionParser.Constants">
            <summary>Константы</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.#ctor">
            <summary>Парсер математических выражений</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.StrPreprocessing(System.String@)">
            <summary>Предварительная обработка входного строкового выражения</summary>
            <param name="Str">Обрабатываемая строка</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.Parse(System.String)">
            <summary>Разобрать строку математического выражения</summary>
            <param name="StrExpression">Строковое представление математического выражения</param>
            <returns>Математическое выражение</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.ProcessVariables(MathService.MathParser.MathExpression)">
            <summary>Обработка переменных</summary>
            <param name="Expression">Обрабатываемое математическое выражение</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.ProcessFunctions(MathService.MathParser.MathExpression)">
            <summary>Обработка функций</summary>
            <param name="Expression">Обрабатываемое математическое выражение</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.GetOperatorNode(System.Char)">
            <summary>Метод определения узла дерева, реализующего оператор</summary>
            <param name="Name">Имя оператора</param>
            <returns>Узел дерева оператора</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.GetFunctional(System.String)">
            <summary>Метод определения функционала по имени</summary>
            <param name="Name">Имя функционала</param>
            <returns>Функционал</returns>
            <exception cref="T:System.NotSupportedException">Возникает для неопределённых имён функционалов</exception>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.GetRoot(MathService.MathParser.Term[],MathService.MathParser.MathExpression)">
            <summary>Метод излвечения корня дерева из последовательности элементов математического выражения</summary>
            <param name="Group">группа элементов математического выражения</param>
            <param name="MathExpression">Ссылка на математическое выражение</param>
            <returns>Корень дерева мат.выражения</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionParser.Combine(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Комбинация предыдущего и текущего узлов дерева</summary>
            <param name="Last">Предыдущий узел дерева (уже интегрированный в дерево)</param>
            <param name="Node">Текущий узел, который надо вставить в дерево</param>
        </member>
        <member name="T:MathService.MathParser.ExpressionVariabel">
            <summary>Переменная математического выражения</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionVariabel._Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="F:MathService.MathParser.ExpressionVariabel._IsConstant">
            <summary>Является ли константой?</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionVariabel.Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionVariabel.IsPrecomputable">
            <summary>Признак возможности предвычисления значения</summary>
        </member>
        <member name="P:MathService.MathParser.ExpressionVariabel.IsConstant">
            <summary>Является ли константой?</summary>
        </member>
        <member name="M:MathService.MathParser.ExpressionVariabel.GetValue">
            <summary>Метод извлечения значения</summary>
            <returns>Численное значение переменной</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionVariabel.#ctor(System.String)">
            <summary>Инициализация нового экземпляра переменной</summary>
            <param name="Name">Имя переменной</param>
        </member>
        <member name="M:MathService.MathParser.ExpressionVariabel.Clone">
            <summary>Клонирование переменной</summary>
            <returns>Новый экземпляр переменной с тем же имененм и тем же значением</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionVariabel.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление переменной</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionVariabel.op_Implicit(System.Double)~MathService.MathParser.ExpressionVariabel">
            <summary>Оператор неявного привидения вещественного числа к типу переменной</summary>
            <param name="x">Вещественное число</param>
            <returns>Безымянная переменная, хранящая указанное число</returns>
        </member>
        <member name="M:MathService.MathParser.ExpressionVariabel.op_Implicit(MathService.MathParser.ExpressionVariabel)~System.Double">
            <summary>Оператор неявного привидения к типу вещественного числа</summary>
            <param name="variable">Приводимая переменная</param>
            <returns>Значение переменной</returns>
        </member>
        <member name="T:MathService.MathParser.FunctionsCollection">
            <summary>Коллекция функций</summary>
        </member>
        <member name="F:MathService.MathParser.FunctionsCollection._MathExpression">
            <summary>Ссылка на математическое выражение</summary>
        </member>
        <member name="F:MathService.MathParser.FunctionsCollection._Functions">
            <summary>Список функций математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.FunctionsCollection.Names">
            <summary>Имена функций</summary>
        </member>
        <member name="P:MathService.MathParser.FunctionsCollection.Count">
            <summary>Количество используемых функций</summary>
        </member>
        <member name="P:MathService.MathParser.FunctionsCollection.Item(System.String,System.Int32)">
            <summary>Индексатор функций по имени и списку параметров</summary>
            <param name="Name">Имя функции</param>
            <param name="ArgumentsCount">Количество аргументов</param>
            <returns>Функция, удовлетворяющаяя заданой сигнатуре</returns>
        </member>
        <member name="P:MathService.MathParser.FunctionsCollection.Item(System.String,System.String[])">
            <summary>Индексатор функций по имени и списку параметров</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Список имён аргументов</param>
            <returns>Функция, удовлетворяющаяя заданой сигнатуре</returns>
        </member>
        <member name="M:MathService.MathParser.FunctionsCollection.#ctor(MathService.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции функций математического выражения</summary>
            <param name="MathExpression">Математическое выражение, на которое ссылается создаваемая коллекция</param>
        </member>
        <member name="M:MathService.MathParser.FunctionsCollection.Add(MathService.MathParser.ExpressionFunction)">
            <summary>Добавить функцию в коллекцию</summary>
            <param name="function">Функция</param>
            <returns>Истина, если функция была добавлена</returns>
        </member>
        <member name="M:MathService.MathParser.FunctionsCollection.System#Collections#Generic#IEnumerable{MathService#MathParser#ExpressionFunction}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:MathService.MathParser.FunctionsCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="T:MathService.MathParser.FunctionTerm">
            <summary>Функциональный элемент выражения</summary>
        </member>
        <member name="P:MathService.MathParser.FunctionTerm.Block">
            <summary>Блок со скобками</summary>
        </member>
        <member name="M:MathService.MathParser.FunctionTerm.#ctor(MathService.MathParser.StringTerm,MathService.MathParser.BlockTerm)">
            <summary>Новый функциональный элемент выражения</summary>
            <param name="StrTerm">Строковый элемент выражения</param>
            <param name="Block">Блок выражения</param>
        </member>
        <member name="M:MathService.MathParser.FunctionTerm.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Получить поддерево</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел функции</returns>
        </member>
        <member name="M:MathService.MathParser.FunctionTerm.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление элемента</returns>
        </member>
        <member name="T:MathService.MathParser.IntegralOperator">
            <summary>Комплексный оператор интегрирования</summary>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.#ctor">
            <summary>Создание нового комплексного интегритора интегрирования</summary>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.#ctor(System.String)">
            <summary>Создание нового комплексного интегритора интегрирования</summary>
            <param name="Name">Имя оператора</param>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.Initialize(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Инициализация оператора</summary>
            <param name="Parameters">Блок параметров</param>
            <param name="Function">Блок ядра функции</param>
            <param name="Parser">Парсер</param>
            <param name="Expression">Внешнее выражение</param>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.GetValue(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="T:MathService.MathParser.IntegralOperator.AdaptiveIntegralDelegate">
            <summary>Делегат адаптивного интегрирования</summary>
            <param name="d">Делегат интегрируемой функци</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Коненое значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.GetAdaptiveIntegral(System.Delegate,System.Double,System.Double,System.Double[])">
            <summary>Получить численное значение интеграла адаптивным методом</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Коненое значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="T:MathService.MathParser.IntegralOperator.IntegralDelegate">
            <summary>Получить численное значение интеграла методом трапеций</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Коненое значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <param name="dx">Шаг интерирования</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.GetIntegral(System.Delegate,System.Double,System.Double,System.Double[],System.Double)">
            <summary>Получить численное значение интеграла методом трапеций</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Коненое значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <param name="dx">Шаг интерирования</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="M:MathService.MathParser.IntegralOperator.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Function">Ядро функции</param>
            <param name="Parameters">Массив параметров</param>
            <param name="ParametersExpression">Выражение параметров</param>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="T:MathService.MathParser.LamdaExpressionVariable">
            <summary>Лямда-переменная</summary>
            <remarks>Значение переменной - результат вычисления лямда-функции</remarks>
        </member>
        <member name="F:MathService.MathParser.LamdaExpressionVariable._Value">
            <summary>Функция вычисления значения переменной</summary>
        </member>
        <member name="P:MathService.MathParser.LamdaExpressionVariable.IsPrecomputable">
            <summary>Признак отсутствия возможности предвычисления значения</summary>
        </member>
        <member name="M:MathService.MathParser.LamdaExpressionVariable.#ctor(System.Func{System.Double})">
            <summary>Инициализация нового экземпляра лямда-переменной</summary>
            <param name="Source">Лямда-функция получения значения переменной</param>
        </member>
        <member name="M:MathService.MathParser.LamdaExpressionVariable.#ctor(System.String,System.Func{System.Double})">
            <summary>Инициализация нового экземпляра лямда-переменной</summary>
            <param name="Name">Имя переменной</param>
            <param name="Source">Лямда-функция получения значения переменной</param>
        </member>
        <member name="M:MathService.MathParser.LamdaExpressionVariable.GetValue">
            <summary>Получить значение переменной</summary>
            <returns>Численное значение переменной</returns>
        </member>
        <member name="M:MathService.MathParser.LamdaExpressionVariable.Clone">
            <summary>Клонировать переменную</summary>
            <returns>Новый экземпляр лямда-переменной с тем же именем и клоном функции</returns>
        </member>
        <member name="T:MathService.MathParser.MathExpression">
            <summary>Математическое выражение</summary>
        </member>
        <member name="F:MathService.MathParser.MathExpression._ExpressionTree">
            <summary>Дерево математического выражения</summary>
        </member>
        <member name="F:MathService.MathParser.MathExpression._Variables">
            <summary>Коллекция переменных математического выражения</summary>
        </member>
        <member name="F:MathService.MathParser.MathExpression._Constants">
            <summary>Коллекция констант математического выражения</summary>
        </member>
        <member name="F:MathService.MathParser.MathExpression._Functions">
            <summary>Коллекция функций, учавствующих в выражении</summary>
        </member>
        <member name="F:MathService.MathParser.MathExpression._Functionals">
            <summary>Коллекция функционалов</summary>
        </member>
        <member name="F:MathService.MathParser.MathExpression._Name">
            <summary>Имя выражения</summary>
        </member>
        <member name="P:MathService.MathParser.MathExpression.Name">
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value"/> is <see langword="null" />.</exception>
            <exception cref="T:System.ArgumentException" accessor="set">Указано пустое имя функции</exception>
        </member>
        <member name="P:MathService.MathParser.MathExpression.IsPrecomputable">
            <summary>Является ли выражение предвычислимым?</summary>
        </member>
        <member name="P:MathService.MathParser.MathExpression.Tree">
            <summary>Дерево математического выражения</summary>
        </member>
        <member name="P:MathService.MathParser.MathExpression.Variable">
            <summary>Переменные, входящие в математическое выражение</summary>
        </member>
        <member name="P:MathService.MathParser.MathExpression.Constants">
            <summary>Константы, входящие в математическое выражение</summary>
        </member>
        <member name="P:MathService.MathParser.MathExpression.Functions">
            <summary>Коллекция функций, учавствующих в выражении</summary>
        </member>
        <member name="P:MathService.MathParser.MathExpression.Functionals">
            <summary>Коллекция функционалов</summary>
        </member>
        <member name="M:MathService.MathParser.MathExpression.#ctor(System.String)">
            <summary>Инициализация пустого математического выражения</summary>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathService.MathParser.MathExpression.#ctor(MathService.MathParser.ExpressionTrees.ExpressionTree,System.String)">
            <summary>Инициализация нового математического выражения</summary>
            <param name="Tree">Дерево математического выражения</param>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathService.MathParser.MathExpression.#ctor(System.String,MathService.MathParser.ExpressionParser)">
            <summary>Инициализация нового математического выражения</summary>
            <param name="StrExpression">Строковое представление выражения</param>
            <param name="Parser">Ссылка на парсер</param>
        </member>
        <member name="M:MathService.MathParser.MathExpression.System#IDisposable#Dispose">
            <summary>Уничтожить математическое выражение</summary>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compute">
            <summary>Вычисление математического выражения</summary>
            <returns>Значение выражения</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compute(System.Double[])">
            <summary>Вычисление математического выражения</summary>
            <returns>Значение выражения</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compile">
            <summary>Компиляция математического выражения в функцию без параметров</summary>
            <returns>Функция типа double func(void) без параметров</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compile1">
            <summary>Компиляция функции одной переменной</summary>
            <returns>Делегат функции одной переменной</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compile2">
            <summary>Компиляция функции двух переменных</summary>
            <returns>Делегат функции двух переменных</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compile3">
            <summary>Компиляция функции трёх переменных</summary>
            <returns>Делегат функции трёх переменных</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compile(System.String[])">
            <summary>Компиляция математического выражения в функцию указанного типа</summary>
            <param name="ArgumentName">Список имён параметров</param>
            <returns>Делегат скомпелированного выражения</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.CompileMultyParameters(System.String[])">
            <summary>Многопараметрическая компиляия мат.выражения</summary>
            <param name="ArgumentName">Массив имён компилируемых параметров</param>
            <returns>Делегат функции, принимающий на вход массив значений параметров</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Compile``1(System.String[])">
            <summary>Компиляция математического выражения в функцию указанного типа</summary>
            <typeparam name="TDelegate">Тип делегата функции</typeparam>
            <param name="ArgumentName">Список имён параметров</param>
            <returns>Делегат скомпелированного выражения</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.GetExpression(System.Linq.Expressions.ParameterExpression[]@,System.String[])">
            <summary>Получить Linq.Expression выражение, построенное на основе дерева выражений</summary>
            <param name="vars">Список входных переменных</param>
            <param name="ArgumentName">Список имён аргументов</param>
            <returns>Выражение типа Linq.Expression</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.GetExpression``1(System.Linq.Expressions.ParameterExpression[]@,System.String[])">
            <summary>Получить Linq.Expression выражение, построенное на основе дерева выражений</summary>
            <typeparam name="TDelegate">Тип делегата выражения</typeparam>
            <param name="vars">Список входных переменных</param>
            <param name="ArgumentName">Список имён аргументов</param>
            <returns>Выражение типа Linq.Expression</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.CheckConstatnsCollection(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Перенос констант из выражения источника в выражение приёмник</summary>
            <param name="Source">Выражение источник</param>
            <param name="Result">Выражение приёмник</param>
        </member>
        <member name="M:MathService.MathParser.MathExpression.Clone">
            <summary>Клонирование выражения</summary>
            <returns>Копия объектной модели выражения</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.System#ICloneable#Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.MathParser.MathExpression.CombineExpressions(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,MathService.MathParser.ExpressionTrees.Nodes.OperatorNode)">
            <summary>Комбинация двух выражений с использованием узла-оператора</summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
            <param name="node">Узел операции</param>
            <returns>Математическое выражение, в корне дерева которого лежит узел оператора. Поддеревья - корни первого и второго выражений</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Addition(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Оператор сложения двух выражений</summary>
            <param name="x">Первое слогаемое</param>
            <param name="y">Второе слогаемое</param>
            <returns>Выражение-сумма, корень которого - узел суммы. Поддеревья - корни выражений слогаемых</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Subtraction(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Оператор вычитания двух выражений</summary>
            <param name="x">Уменьшаемое</param>
            <param name="y">Вычитаемое</param>
            <returns>Выражение-разность, корень которого - узел разности. Поддеревья - корни выражений вычитаемого и уменьшаемого</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Multiply(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Оператор умножения двух выражений</summary>
            <param name="x">Первый сомножитель</param>
            <param name="y">Второй сомножитель</param>
            <returns>Выражение-произведения, корень которого - узел произведения. Поддеревья - корни выражений сомножителей</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Division(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Оператор деления двух выражений</summary>
            <param name="x">Делимое</param>
            <param name="y">Делитель</param>
            <returns>Выражение-частное, корень которого - узел деления. Поддеревья - корни выражений делимого и делителя</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_ExclusiveOr(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Оператор возведения в степень</summary>
            <param name="x">Основание</param>
            <param name="y">Показатель степени</param>
            <returns>Выражение-степень, корень которого - узел степени. Поддеревья - корни выражений Основания и показателя степени</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Implicit(MathService.MathParser.MathExpression)~MathService.MathParser.ExpressionTrees.ExpressionTree">
            <summary>Оператор неявного приведения типов математического выражения к типу дерева выражения</summary>
            <param name="Expression">Математическое выражение</param>
            <returns>Дерево математического выражения</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Implicit(MathService.MathParser.ExpressionTrees.ExpressionTree)~MathService.MathParser.MathExpression">
            <summary>Оператор неявного приведения типов дерева выражения к типу математического выражения</summary>
            <param name="Tree">Дерево математического выражения</param>
            <returns>Математическое выражение, содержащее указанное дерево</returns>
        </member>
        <member name="M:MathService.MathParser.MathExpression.op_Implicit(MathService.MathParser.MathExpression)~System.Func{System.Double}">
            <summary>Оператор неявного приведения типов математического выражения к типу делегата функции double Func(void)</summary>
            <param name="expr">Математическое выражения</param>
            <returns>Результат компиляции математического выражения</returns>
        </member>
        <member name="T:MathService.MathParser.NumberTerm">
            <summary>Числовой элемент математического выражения</summary>
        </member>
        <member name="F:MathService.MathParser.NumberTerm._IntValue">
            <summary>Численное значение элемента</summary>
        </member>
        <member name="P:MathService.MathParser.NumberTerm.Value">
            <summary>Численное значение элемента</summary>
        </member>
        <member name="M:MathService.MathParser.NumberTerm.#ctor(System.String)">
            <summary>Новый численный элемент мат.выражения</summary>
            <param name="Str">Строковое значение элемента</param>
        </member>
        <member name="M:MathService.MathParser.NumberTerm.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Извлеч поддерево</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел константного значения</returns>
        </member>
        <member name="M:MathService.MathParser.NumberTerm.TryAddFractionPart(MathService.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode@,MathService.MathParser.Term,System.Char,MathService.MathParser.Term)">
            <summary>Попытаться добавить дробное значение числа</summary>
            <param name="node">Узел выражения</param>
            <param name="SeparatorTerm">Блок разделитель</param>
            <param name="DecimalSeparator">Блок с целой частью числа</param>
            <param name="FrationPartTerm">Блок с дробной частью числа</param>
            <returns>Истина, если действие совершено успешно. Ложь, если в последующих блоках не содержится нужной информации</returns>
        </member>
        <member name="T:MathService.MathParser.StringTerm">
            <summary>Строковый элемент выражения</summary>
        </member>
        <member name="P:MathService.MathParser.StringTerm.Name">
            <summary>Имя строкового элемента</summary>
        </member>
        <member name="M:MathService.MathParser.StringTerm.#ctor(System.String)">
            <summary>Новый строковый элемент</summary>
            <param name="Name">Имя строкового элемента</param>
        </member>
        <member name="M:MathService.MathParser.StringTerm.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Поддерево элемента, состоящее из узла-переменной</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел дерева с переменной, полученной из Expression.Variable[Name]</returns>
        </member>
        <member name="T:MathService.MathParser.SummOperator">
            <summary>Оператор суммы</summary>
        </member>
        <member name="M:MathService.MathParser.SummOperator.#ctor">
            <summary>Инициализация нового оператора суммы</summary>
        </member>
        <member name="M:MathService.MathParser.SummOperator.#ctor(System.String)">
            <summary>Инициализация нового обператора суммы</summary>
            <param name="Name"></param>
        </member>
        <member name="M:MathService.MathParser.SummOperator.Initialize(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Инициализация оператора</summary>
            <param name="Parameters">Блок параметров</param>
            <param name="Function">Блок ядра функции</param>
            <param name="Parser">Парсер мат.выражения</param>
            <param name="Expression">Внешнее мат.выражение</param>
        </member>
        <member name="M:MathService.MathParser.SummOperator.GetValue(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="T:MathService.MathParser.SummOperator.SummDelegate">
            <summary>Метд суммирования</summary>
            <param name="d">Суммируемая функция - ядро</param>
            <param name="Min">Начало интервала</param>
            <param name="Max">Конец интервала</param>
            <param name="Parameters">Массив параметров функции</param>
            <returns>Значение суммы функции</returns>
        </member>
        <member name="M:MathService.MathParser.SummOperator.GetSumm(System.Delegate,System.Double,System.Double,System.Double[])">
            <summary>Получение значения суммы</summary>
            <param name="d">Суммируемая функция - ядро</param>
            <param name="Min">Начало интервала суммирования</param>
            <param name="Max">Конец интервала суммирования</param>
            <param name="Parameters">Массив параметров</param>
            <returns>Сумма функции</returns>
        </member>
        <member name="M:MathService.MathParser.SummOperator.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression)">
            <summary>Скомпилировать в выражение</summary>
            <param name="ParametersExpression">Выражение блока параметров</param>
            <param name="Function">Выражение блока ядра оператора - функции</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathService.MathParser.SummOperator.Compile(MathService.MathParser.MathExpression,MathService.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Function">Ядро функции</param>
            <param name="Parameters">Массив параметров</param>
            <param name="ParametersExpression">Выражение параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="T:MathService.MathParser.Term">
            <summary>Элемент математического выражения</summary>
        </member>
        <member name="F:MathService.MathParser.Term._Value">
            <summary>Строковое содержимое</summary>
        </member>
        <member name="M:MathService.MathParser.Term.#ctor(System.String)">
            <summary>Конструктор элемента математического выражения</summary>
            <param name="Value">Строковое содержимое</param>
        </member>
        <member name="M:MathService.MathParser.Term.GetSubTree(MathService.MathParser.ExpressionParser,MathService.MathParser.MathExpression)">
            <summary>Метод извлечения поддерева для данного элемента математического выражения</summary>
            <param name="Parser">Парсер математического выражения</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел дерева мат.выражения, являющийся поддеревом для данного элемента мат.выражения</returns>
        </member>
        <member name="M:MathService.MathParser.Term.ToString">
            <summary>Строковое представление элемента мат.выражения</summary>
            <returns>Строковое содержимое элемета мат.выражения</returns>
        </member>
        <member name="T:MathService.MathParser.VariabelsCollection">
            <summary>Коллекция переменных</summary>
        </member>
        <member name="F:MathService.MathParser.VariabelsCollection._Expression">
            <summary>Математическое выражение</summary>
        </member>
        <member name="P:MathService.MathParser.VariabelsCollection.Count">
            <summary>Количество переменных в коллекции</summary>
        </member>
        <member name="P:MathService.MathParser.VariabelsCollection.Item(System.String)">
            <summary>Итератор переменных коллекции</summary>
            <param name="Name">Имя переменной</param>
            <returns>Переменная с указанным именем</returns>
        </member>
        <member name="P:MathService.MathParser.VariabelsCollection.Item(System.Int32)">
            <summary>Итератор переменных коллекции</summary>
            <param name="i">Индекс переменной</param>
            <returns>Переменная с указанным индексом</returns>
        </member>
        <member name="P:MathService.MathParser.VariabelsCollection.Names">
            <summary>Перечисление всех имён переменных колеекции</summary>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.#ctor(MathService.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции переменных</summary>
            <param name="expression">Математическое выражение, которому принадлежит коллекция</param>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.Add(MathService.MathParser.ExpressionVariabel)">
            <summary>Добавить переменную в коллекцию</summary>
            <param name="Variable">Переменная</param>
            <returns>Истина, если переменная была добавлена</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.MoveToConstCollection(System.String)">
            <summary>Переместить переменную из коллекции переменных в коллекцию констант</summary>
            <param name="Variable">Перемещаемая переменная</param>
            <returns>Истина, если переменная была перемещена из коллекции переменных в коллекцию констант</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.MoveToConstCollection(MathService.MathParser.ExpressionVariabel)">
            <summary>Переместить переменную из коллекции переменных в коллекцию констант</summary>
            <param name="Variable">Перемещаемая переменная</param>
            <returns>Истина, если переменная была перемещена из коллекции переменных в коллекцию констант</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.Remove(MathService.MathParser.ExpressionVariabel)">
            <summary>Удаление переменной из коллекции</summary>
            <param name="Variable">Удаляемая переменная</param>
            <returns>Истина, если удаление прошло успешно</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.RemoveFromCollection(MathService.MathParser.ExpressionVariabel)">
            <summary>Удалить переменную из коллекции</summary>
            <param name="Variable">Удаляемая переменная</param>
            <returns>Истина, если переменная удалена успешно</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.ClearCollection">
            <summary>Очистить коллекцию переменных</summary>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.Exist(System.String)">
            <summary>Существует ли в коллекции переменная с указанным имененм</summary>
            <param name="Name">Искомое имя переменной</param>
            <returns>Истина, если в коллекции пристутствует переменная с указанным именем</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.Exist(MathService.MathParser.ExpressionVariabel)">
            <summary>Проверка на существование переменной в коллекции</summary>
            <param name="variable">Проверяемая переменная</param>
            <returns>Истина, если указанная переменная входит в коллекцию</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.Exist(System.Predicate{MathService.MathParser.ExpressionVariabel})">
            <summary>Существует ли переменная в коллекции с заданным критерием поиска</summary>
            <param name="exist">Критерий поиска переменной</param>
            <returns>Истина, если найдена переменная по указанному критерию</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.ExistInTree(System.String)">
            <summary>Существует ли узел переменной в дереве с указанным именем</summary>
            <param name="Name">Искомое имя переменной</param>
            <returns>Истина, если указанное имя переменной существует в дереве</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.ExistInTree(System.Func{MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode,System.Boolean})">
            <summary>Существует ли узел переменной в дереве</summary>
            <param name="exist">Критерий поиска</param>
            <returns>Истина, если найден узел по указанному критерию</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.GetTreeNodes(System.String)">
            <summary>Получить перечисление узлов переменных с указанным именем</summary>
            <param name="VariableName">Искомое имя переменной</param>
            <returns>Перечисление узлов с переменными с указанным именем</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.GetTreeNodes(System.Func{MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode,System.Boolean})">
            <summary>Получить перечисление узлов дерева с переменными</summary>
            <param name="selector">Метод выборки узлов</param>
            <returns>Перечисление узлов переменных</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.GetTreeNodesOf``1">
            <summary>Получить перечисление узлов дерева выражения, содержащих указанный тип переменных</summary>
            <typeparam name="TVariable">Тип переменной</typeparam>
            <returns>Перечисление узлов дерева с указанным типом переменных</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.GetTreeNodesVOf``1(System.Func{``0,System.Boolean})">
            <summary>Получить перечисление узлов дерева выражения, содержащих указанный тип переменных</summary>
            <typeparam name="TVariable">Тип переменной</typeparam>
            <param name="selector">Метод выбора узлов по содержащимся в них переменным</param>
            <returns>Перечисление узлов дерева с указанным типом переменных</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.GetTreeNodesOf``1(System.Func{MathService.MathParser.ExpressionTrees.Nodes.VariableValueNode,System.Boolean})">
            <summary>Получить перечисление узлов дерева выражения, содержащих указанный тип переменных</summary>
            <typeparam name="TVariable">Тип переменной</typeparam>
            <param name="selector">Метод выбора узлов</param>
            <returns>Перечисление узлов дерева с указанным типом переменных</returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.System#Collections#Generic#IEnumerable{MathService#MathParser#ExpressionVariabel}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:MathService.MathParser.VariabelsCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="T:MathService.Matrix">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="T:MathService.Matrix.Array">
            <summary>Операции над двумерными массивами</summary>
        </member>
        <member name="M:MathService.Matrix.Array.MatrixToColsArray(System.Double[0:,0:])">
            <summary>Преобразовать двумерный массив элементов матрицы в массив массивов-столбцов</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Массив столбцов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.MatrixToRowsArray(System.Double[0:,0:])">
            <summary>Преобразовать двумерный массив элементов матрицы в массив массивов-строк</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Массив строк</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.ColsArrayToMatrix(System.Double[][])">
            <summary>Создать двумерный массив массив матрицы из массива столбцов</summary>
            <param name="cols">Массив столбцов матрицы</param>
            <returns>Двумерный массив элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="cols"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.RowsArrayToMatrix(System.Double[][])">
            <summary>Создать двумерный массив массив матрицы из массива строк</summary>
            <param name="rows">Массив строк матрицы</param>
            <returns>Двумерный массив элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="rows"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.IsMatrixSungular(System.Double[0:,0:])">
            <summary>Проверка - является ли матрица вырожденой</summary>
            <param name="matrix">Проверяемая матрица</param>
            <returns>Истина, если определитель матрицы равен нулю</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов, или если матрица не квазратная</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Rank(System.Double[0:,0:])">
            <summary>Определение ранга матрицы</summary>
            <param name="matrix">Матрица, ранг которой требуется определить</param>
            <returns>Ранг матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathService.Matrix.Array.CreateDiagonal(System.Double[])">
            <summary>Создать диагональную матрицу</summary>
            <param name="elements">Элементы диагонали матрицы</param>
            <returns>Двумерный массив, содержащий на главной диагонали элементы диагонильрной матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="elements"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetMatrixShadow(System.Double[0:,0:])">
            <summary>Получить массив элементов тени (главной диагонали) матирцы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Массив элементов тени матрицы</returns>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.EnumerateMatrixShadow(System.Double[0:,0:])">
            <summary>Перечислить элементы тени (главной диагонали) матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Перечисление элементов тени матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Permutation_Left(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Применение матрицы перестановок слева (перестановка строк)</summary>
            <param name="matrix">Матрица, подвергаемая перестановке строк</param>
            <param name="p">Матрица перестановок (строк)</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица перестановок не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк матрицы не равно числу столбцов матрицы перестановок</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Permutation_Right(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Применение матрицы перестановок справа (перестановка столбцов)</summary>
            <param name="matrix">Матрица, подвергаемая перестановке столбцов</param>
            <param name="p">Матрица перестановок (столбцов)</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица перестановок не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк матрицы не равно числу столбцов матрицы перестановок</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Permutation_Left_Internal(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Применение матрицы перестановок слева (перестановка строк) без проверок</summary>
            <param name="matrix">Матрица, подвергаемая перестановке строк</param>
            <param name="p">Матрица перестановок (строк)</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="p"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Permutation_Right_Internal(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Применение матрицы перестановок справа (перестановка столбцов) без проверок</summary>
            <param name="matrix">Матрица, подвергаемая перестановке столбцов</param>
            <param name="p">Матрица перестановок (столбцов)</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="p"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.CreateColArray(System.Double[])">
            <summary>Создать двумерный массив элементов матрицы-столбца</summary>
            <param name="data">Элементы массива матрицы-столбца</param>
            <returns>Двумерный массив элементов матрицы столбца</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathService.Matrix.Array.CreateRowArray(System.Double[])">
            <summary>Создать двумерный массив элементов матрицы-строки</summary>
            <param name="data">Элементы массива матрицы-строки</param>
            <returns>Двумерный массив элементов матрицы строки</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetLength(System.Double[0:,0:],System.Int32@,System.Int32@)">
            <summary>Получить размерность массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="N">Число строк матриы</param>
            <param name="M">Число столбцов (элементов строки) матрицы</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetRowsCount(System.Double[0:,0:],System.Int32@)">
            <summary>Получить число строк массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="N">Число строк матриы</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetColsCount(System.Double[0:,0:],System.Int32@)">
            <summary>Получить число столбцов (элементов строки) массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="M">Число столбцов (элементов строки) матрицы</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetUnitaryArrayMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Квадратный двумерный массив размерности NxN с 1 на главной диагонали</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы <paramref name="N"/> меньше 1</exception>
        </member>
        <member name="M:MathService.Matrix.Array.InitializeUnitaryMatrix(System.Double[0:,0:])">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Квадратный двумерный массив размерности NxN с 1 на главной диагонали</returns>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetTransvection(System.Double[0:,0:],System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="i0">Опорная строка</param>
            <returns>Трансвекция матрицы А</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="A"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если опорная строка <paramref name="i0"/> матрицы <paramref name="A"/> &lt; 0 и &gt; числа строк матрицы</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Transvection(System.Double[0:,0:],System.Int32,System.Double[0:,0:])">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j0">Опорный столбец</param>
            <param name="result">Двумерный массив элементов матрицы результата</param>
            <returns>Трансвекция матрицы А</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрицы <paramref name="A"/> и <paramref name="result"/> не заданы</exception>  
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="A"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если опорный столбец <paramref name="j0"/> матрицы <paramref name="A"/> меньше 0 или больше числа столбцов матрицы</exception>
            <exception cref="T:System.ArgumentException">В случае если размер матрицы <paramref name="result"/> не совпадает с размером матрицы <paramref name="A"/></exception>                  
        </member>
        <member name="M:MathService.Matrix.Array.GetCol(System.Double[0:,0:],System.Int32)">
            <summary>Получить столбец матрицы в виде матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <returns>Матрица-столбец, составленная из элементов столбца матрицы c индексом j</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetCol_Array(System.Double[0:,0:],System.Int32)">
            <summary>Получить столбец матрицы в виде маиива</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <returns>Массив, составленная из элементов столбца матрицы c индексом <paramref name="j"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetCol_Array(System.Double[0:,0:],System.Int32,System.Double[])">
            <summary>Получить столбец матрицы в виде маиива</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <param name="result">Массив, составленная из элементов столбца матрицы c индексом <paramref name="j"/></param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если массив <paramref name="result"/> не задан</exception>
            <exception cref="T:System.ArgumentException">В случае если размер массива <paramref name="result"/> не соответствует числу строк матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetRow(System.Double[0:,0:],System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <returns>Матрица-строка, составленная из элементов строки матрицы с индексом <paramref name="i"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetRow_Array(System.Double[0:,0:],System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <returns>Массив, составленный из элементов строки матрицы с индексом <paramref name="i"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetRow_Array(System.Double[0:,0:],System.Int32,System.Double[])">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <param name="result">Массив, составленный из элементов строки матрицы с индексом i</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если массив <paramref name="result"/> не задан</exception>
            <exception cref="T:System.ArgumentException">В случае если размер массива <paramref name="result"/> не соответствует числу столбцов матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Inverse(System.Double[0:,0:])">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Обращаеемая матрица</param>
            <returns>Обратная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Inverse(System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Обращаеемая матрица</param>
            <param name="p">Матрица перестановок</param>
            <returns>Обратная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Размерность массива 0х0</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Inverse(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Матрица, подлежащая обращению</param>
            <param name="result">Обратная матрица</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="result"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetSolve(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>Метод решения СЛАУ A*X=B -&gt; X</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <returns>Матрица решения уравнения A*X=B -&gt; X</returns>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Solve(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Boolean)">
            <summary>Метод решения СЛАУ</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <param name="clone_b">Работать с копией <paramref name="b"/></param>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.TrySolve(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Boolean)">
            <summary>Попытаться решить СЛАУ</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <param name="clone_b">Работать с копией <paramref name="b"/></param>
            <returns>Истина, если решение СЛАУ получено; ложь - если матрица СЛАУ <paramref name="matrix"/> варождена</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="b"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Transponse(System.Double[0:,0:])">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Transponse(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Транспонирование матрицы</summary>
            <param name="matrix">Исходная матрица</param>
            <param name="result">Транспонированная матрица</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="result"/> не задана</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetAdjunct(System.Double[0:,0:],System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.CopyMinor(System.Double[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32,System.Double[0:,0:])">
            <summary>Скопировать минор из матрицы в матрицу результата</summary>
            <param name="matrix">Массив элементов исходной матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="result">Минор матрицы</param>
        </member>
        <member name="M:MathService.Matrix.Array.GetMinor(System.Double[0:,0:],System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <returns>Минор элемента матрицы [n,m]</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetMinor(System.Double[0:,0:],System.Int32,System.Int32,System.Double[0:,0:])">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <param name="result">Минор элемента матрицы [n,m]</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число строк матрицы результата <paramref name="result"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число столбцов матрицы результата <paramref name="result"/> не равно числу столбцов исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetDeterminant(System.Double[0:,0:])">
            <summary>Определитель матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Определитель матрицы</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Swap``1(``0@,``0@)">
            <summary>Поменять значения местами</summary>
            <typeparam name="T">Тип значения</typeparam>
        </member>
        <member name="M:MathService.Matrix.Array.GetLUPDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="l">Нижне-треугольная матрица</param>
            <param name="u">Верхнетреугольная матрица</param>
            <param name="p">Матрица преобразований P*X = L*U</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура декомпозиции прошла успешно. Ложь, если матрица вырождена</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы <paramref name="matrix"/> меньше 1</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetLUDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="l">Нижне-треугольная матрица</param>
            <param name="u">Верхнетреугольная матрица</param>
            <param name="d">Определитль матрицы</param>
            <returns>Истина, если процедура декомпозиции прошла успешно. Ложь, если матрица вырождена</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы N меньше 1</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetLUPDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <param name="p">Массив матрицы перестановок</param>
            <param name="d">Определитль матрицы</param>
            <returns>Истина, если операция выполнена успешно</returns>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetLUPDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double@)">
            <summary>LU-разложение матрицы</summary>
            <param name="matrix">Разлогаемая матрица</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура выполнена успешно</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetLUDecomposition(System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>LU-разложение матрицы</summary>
            <param name="matrix">Разлогаемая матрица</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <returns>Истина, если разложение выполнено успешно</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathService.Matrix.Array.CreatePermutationMatrix(System.Int32[])">
            <summary>Создать матрицу перестановок из массива индексов</summary>
            <param name="indexes">Массив индексов элементов стольцов</param>
            <returns>Матрица перестановок</returns>
        </member>
        <member name="M:MathService.Matrix.Array.GetTriangle(System.Double[0:,0:],System.Double[0:,0:]@,System.Int32@,System.Double@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гауса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="p">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Триугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetTriangle(System.Double[0:,0:],System.Int32@,System.Double@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гауса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Триугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetTriangle(System.Double[0:,0:],System.Double[0:,0:],System.Int32@,System.Double@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гауса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="b">Матрица правой части</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Триугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetTriangle(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Int32@,System.Double@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гауса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="b">Матрица правой части</param>
            <param name="p">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <param name="clone_b">Клонировать матрицу правых частей</param>
            <returns>Триугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Triangulate(System.Double[0:,0:],System.Double[0:,0:]@,System.Double@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к триугольному виду</param>
            <param name="p">Матрица перестановок</param>
            <param name="d">Определитель матрицы (проидведение диогональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Triangulate(System.Double[0:,0:],System.Double@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к триугольному виду</param>
            <param name="d">Определитель матрицы (проидведение диогональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Triangulate(System.Double[0:,0:],System.Double[0:,0:],System.Double@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к триугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="d">Определитель матрицы (проидведение диогональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Triangulate(System.Double[0:,0:]@,System.Double[0:,0:],System.Double@,System.Boolean)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к триугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="d">Определитель матрицы (проидведение диогональных элементов)</param>
            <param name="clone">Клонировать исходную матрицу</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Triangulate(System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@,System.Boolean,System.Boolean)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к триугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="p">Матрица перестановок</param>
            <param name="d">Определитель матрицы (проидведение диогональных элементов)</param>
            <param name="clone_matrix">Клонировать исходную матрицу</param>
            <param name="clone_b">Клонировать присоединённую матрицу</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.AreEquals(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Сравнение двух двумерных массивов элементов матриц</summary>
            <param name="A">Первый массив</param>
            <param name="B">Второй массив</param>
            <returns>Истина, если оба массивы неопределены, либо если оба массивы - один и тот же массив, либо если элементы массивов идентичны</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.AreEquals(System.Double[0:,0:],System.Double[0:,0:],System.Double)">
            <summary>Сравнение двух двумерных массивов элементов матриц</summary>
            <param name="A">Первый массив</param>
            <param name="B">Второй массив</param>
            <param name="eps">Точность сравнения</param>
            <returns>Истина, если оба массивы неопределены, либо если оба массивы - один и тот же массив, либо если элементы массивов идентичны</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetMaxRowAbsSumm(System.Double[0:,0:])">
            <summary>Вычисление максимуа от сумм абсолютных значений по элементам строк</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Максимальная из сумм абсолютных значений элементов строк</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetMaxColAbsSumm(System.Double[0:,0:])">
            <summary>Вычисление максимуа от сумм абсолютных значений по элементам столбцов</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Максимальная из сумм абсолютных значений элементов столбцов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.GetRMS(System.Double[0:,0:])">
            <summary>Вычисление среднеквадратического значения элементов матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Среднеквадратическое значение элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Sqr(System.Double)">
            <summary>Квадрат числа</summary>
            <param name="x">Значение, квадрат которого требуется получить</param>
            <returns>Квадрат указанного числа</returns>
        </member>
        <member name="M:MathService.Matrix.Array.GausSeidelConverge(System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double,System.Int32,System.Int32)">
            <summary>Метод проверки сходимости метода Метод Гаусса — Зейделя</summary>
            <remarks>Метод меняет местами матрицы решения текущего и прошлого шагов, если метод Гаусса — Зейделя не сашёлся на текущем шаге</remarks>
            <param name="new_x">Новое полученное решение</param>
            <param name="last_x">Решение, полученное на прошлом шаге метода</param>
            <param name="eps">Требуемая точность решения</param>
            <param name="N">Число строк матрицы решения</param>
            <param name="M">Число столбцов матрицы решения</param>
            <returns>Истина, если метод сошёлся Метод Гаусса — Зейделя</returns>
        </member>
        <member name="M:MathService.Matrix.Array.GausSeidelSolove(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:],System.Double)">
            <summary>Метод Гаусса — Зейделя решения системы линейных уравнений</summary>
            <param name="matrix">Матрица коэффициентов</param>
            <param name="x">Матрица неизвестных</param>
            <param name="b">Матрица правых частей</param>
            <param name="eps">Требуемая точность</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="b"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица системы не содержит элементов</exception>
            <exception cref="T:System.ArgumentException">Матрица системы не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк массива неизвестных не совпадает с числом строк матрицы системы</exception>
            <exception cref="T:System.ArgumentException">Число строк массива правой части СЛАУ не совпадает с числом строк матрицы системы</exception>
            <exception cref="T:System.ArgumentException">Число столбцов массива правых частей не совпадает с числом столбцов массива неизвестных</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="eps"/> &lt;= <see cref="T:System.Double"/>.<see cref="F:System.Double.Epsilon"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.QRDecomposition(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>QR-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="q">Унитарная матрица (ортогональная) - должна быть передана квадратная матирца nxn != null</param>
            <param name="r">Верхнетреугольная матрица - должна быть передана квадратная матирца nxn != null</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathService.Matrix.Array.QRDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>QR-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="q">Унитарная матрица (ортогональная) - создаётся квадратная матирца nxn != null</param>
            <param name="r">Верхнетреугольная матрица - создаётся квадратная матирца nxn != null</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathService.Matrix.Array.SVD(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[]@,System.Double[0:,0:]@)">
            <summary>SVD-разложение</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="u">Матрица левых сингулярных векторов</param>
            <param name="w">Вектор собственных чисел</param>
            <param name="v">Матрица правых сингулярных векторов</param>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Метод не сошёлся за 30 итераций</exception>
        </member>
        <member name="T:MathService.Matrix.Array.Operator">
            <summary>Операторы над двумерными массивами</summary>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Multiply(System.Double[],System.Double[])">
            <summary>Скалярное произведение векторов</summary>
            <param name="v1">Первый множитель скалярного произведения</param>
            <param name="v2">второй множитель скалярного произведения</param>
            <returns>Скалярное произведение векторов</returns>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.VectorLength(System.Double[])">
            <summary>Длина вектора</summary>
            <param name="v">Вектор элементов</param>
            <returns>Длина вектора</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Multiply(System.Double[],System.Double)">
            <summary>Умножение вектора на число</summary>
            <param name="v1">Первый сомножитель - вектор элэементов</param>
            <param name="v2">Второй сомножитель - число, на которое должны быть умножены все элементы вектора</param>
            <returns>Вектор произведений элементов входного вектора и числа</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Divade(System.Double[],System.Double)">
            <summary>Деление вектора элементов на число</summary>
            <param name="v1">Вектор-делимое</param>
            <param name="v2">Число-делитель</param>
            <returns>Вектор, составленный из частного элементов вектора-делимого и числового делителя</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Projection(System.Double[],System.Double[])">
            <summary>Проекция вектора на вектор</summary>
            <returns>Вектор - произведение компонентов исходных векторов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> or <paramref name="v2"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Длины векторов не совпадают</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Add(System.Double[0:,0:],System.Double)">
            <summary>Оператор вычисления суммы двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив суммы элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Add(System.Double[],System.Double[])">
            <summary>Поэлементное сложение двух матриц</summary>
            <param name="a">Матрица - первое слогаемое</param>
            <param name="b">Матрица - второе слагаемое</param>
            <returns>Матрица, составленная из элементов - сумм элементов исходных матриц</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Substract(System.Double[],System.Double[])">
            <summary>Оператор вычитания между двумя столбцами</summary>
            <param name="a">Столбец уменьшаемого</param>
            <param name="b">Столбец вычитаемого</param>
            <returns>Вектор-столбец разности указанных векторов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Размеры векторов не совпадают</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.MultiplyComponent(System.Double[],System.Double[])">
            <summary>Оператор вычисления поэлементного произведения двух векторов</summary>
            <param name="a">Вектор элементов первого множителя</param>
            <param name="b">Вектор элементов второго множителя</param>
            <returns>Вектор элементов произведения</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Размеры векторов не совпадают</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.DivadeComponent(System.Double[],System.Double[])">
            <summary>Оператор вычисления поэлементного деления двух векторов</summary>
            <param name="a">Вектор - делимое</param>
            <param name="b">Вектор - делитель</param>
            <returns>Вектор, составленный из поэлементного частного элементов векторов делимого и делителя</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Substract(System.Double[0:,0:],System.Double)">
            <summary>Оператор вычисления разности двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив разности элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Substract(System.Double,System.Double[0:,0:])">
            <summary>Оператор вычисления разности двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив разности элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Multiply(System.Double[0:,0:],System.Double)">
            <summary>Оператор вычисления произведения двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив произведения элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Divade(System.Double[0:,0:],System.Double)">
            <summary>Оператор вычисления произведения двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив произведения элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Divade(System.Double,System.Double[0:,0:])">
            <summary>Оператор вычисления частного двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив частного элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Add(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления суммы элементов двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив суммы элементов двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы не равны</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Substract(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления разности элементов двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив разности элементов двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы не равны</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.MultylyCol(System.Double[0:,0:],System.Double[])">
            <summary>Оператор вычисления произведения элементов матрицы на столбец</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="col">Массив элементов столбца</param>
            <returns>Массив произведения элементов матрицы и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="col"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы и столбца не равны</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.MultylyRow(System.Double[],System.Double[0:,0:])">
            <summary>Оператор вычисления произведения элементов строки и матрицы</summary>
            <param name="B">Массив элементов первой матрицы</param>
            <param name="row">Массив элементов строки</param>
            <returns>Массив произведения элементов матрицы и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="row"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы и строки не равны</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.MultylyRowToCol(System.Double[],System.Double[])">
            <summary>Оператор вычисления произведения элементов строки и элементов столбца</summary>
            <param name="col">Массив элементов столбца</param>
            <param name="row">Массив элементов строки</param>
            <returns>Массив произведения элементов строки и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="col"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="row"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности строки и столбца не равны</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Multiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив произведения двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Multiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <param name="result">Массив элементов произведения</param>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="result"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матриц несогласованы</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк <paramref name="result"/> не равно числу строк <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число столбцов <paramref name="result"/> не равно числу строк <paramref name="B"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Divade(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матриц несогласованы</exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.Concatinate(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Объединение метриц по строкам, либо столбцам</summary>
            <returns>Двумерный массив, содержащий объединение элементов исходных массивов по строкам, либо столбцам</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> or <paramref name="B"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.BiliniarMultiply(System.Double[],System.Double[0:,0:],System.Double[])">
            <summary>Оператор вычисления билинейной формы с векторными операндами b = <paramref name="x"/>*<paramref name="a"/>*<paramref name="y"/></summary>
            <param name="x">Массив компонент левой строки билинейной формы</param>
            <param name="a">Матрица билинейной формы</param>
            <param name="y">Массив компонент правого столбца билинейной формы</param>
            <returns>Результат вычисления билинейной формы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="y"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Если длина строки <paramref name="x"/> не равна числу строк матрицы <paramref name="a"/></exception>
            <exception cref="T:System.ArgumentException">Если длина столбца <paramref name="y"/> не равна числу столбцов матрицы <paramref name="a"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.BiliniarMultiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления билинейной формы с векторными операндами b = <paramref name="x"/>*<paramref name="a"/>*<paramref name="y"/></summary>
            <param name="x">Двумерный массив компонент матрицы первого операнда билинейной формы</param>
            <param name="a">Двумерный массив компонент матрицы оператора билинейной мормы</param>
            <param name="y">Двумерный массив компонент матрицы второго операнда билинейной формы</param>
            <returns>
            Двумерный массив компонент матрицы результата вычисления билинейной формы, 
            число строк которого равно числу строк операнда <paramref name="x"/>, число столбцов - равно числу столбцов операнда <paramref name="y"/>
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="y"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Число столбцов <paramref name="x"/> не равно числу строк <paramref name="a"/></exception>
            <exception cref="T:System.ArgumentException">Число строк <paramref name="y"/> не равно числу столбцов <paramref name="a"/></exception>
        </member>
        <member name="M:MathService.Matrix.Array.Operator.BiliniarMultiplyAuto(System.Double[],System.Double[0:,0:])">
            <summary>Вычисление оператора билинейной формы для одного операнда B = X*A*X^T</summary>
            <param name="x">Элементы массива вектора операнда оператора билинейной формы</param>
            <param name="a">Элементы двумерного массива матрицы оператора билинейной формы (должна быть квадратной с числом строк, равным числу элементов вектора операнда <paramref name="x"/>)</param>
            <returns>Численное значение результата вычисления билинейной формы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Если массив элементов матрицы <paramref name="a"/> не квадратный</exception>
            <exception cref="T:System.ArgumentException">Если число элементов вектора <paramref name="x"/> не равно числу строк массива элементов матрицы <paramref name="a"/></exception>
        </member>
        <member name="M:MathService.Matrix.SVD(MathService.Matrix@,System.Double[]@,MathService.Matrix@)">
            <summary>SVD-разложение матрицы</summary>
            <param name="U"></param>
            <param name="w"></param>
            <param name="V"></param>
        </member>
        <member name="M:MathService.Matrix.SVD(MathService.Matrix@,MathService.Matrix@,MathService.Matrix@)">
            <summary>SVD-разложение матрицы</summary>
            <param name="U"></param>
            <param name="S"></param>
            <param name="V"></param>
        </member>
        <member name="M:MathService.Matrix.CreateCol(System.Double[])">
            <summary>Создать матрицу-столбец</summary><param name="data">Элементы столбца</param><returns>Матрица-столбец</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathService.Matrix.CreateRow(System.Double[])">
            <summary>Создать матрицу-строку</summary><param name="data">Элементы строки</param><returns>Матрица-строка</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathService.Matrix.CreateDiagonalMatrix(System.Double[])">
            <summary>Создать диагональную матрицу</summary><param name="elements">Элементы диагональной матрицы</param>
            <returns>Диагональная матрица</returns>
        </member>
        <member name="M:MathService.Matrix.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param><returns>Единичная матрица размерности NxN с 1 на главной диагонали</returns>
        </member>
        <member name="M:MathService.Matrix.GetTransvection(MathService.Matrix,System.Int32)">
            <summary>Трансвекция матрицы</summary><param name="A">Трансвецируемая матрица</param><param name="j">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathService.Matrix._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathService.Matrix._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathService.Matrix._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathService.Matrix.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathService.Matrix.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathService.Matrix.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathService.Matrix.Item(System.Int32)">
            <summary>Вектор-стольбец</summary><param name="j">Номер столбца</param><returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathService.Matrix.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathService.Matrix.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathService.Matrix.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathService.Matrix.IsScalar">
            <summary>Матрица является числом</summary>
        </member>
        <member name="P:MathService.Matrix.T">
            <summary>Транспонированная матрица</summary>
        </member>
        <member name="P:MathService.Matrix.Norm_m">
            <summary>Максимум среди абсолютных сумм элементов строк</summary>
        </member>
        <member name="P:MathService.Matrix.Norm_l">
            <summary>Максимум среди абсолютных сумм элементов столбцов</summary>
        </member>
        <member name="P:MathService.Matrix.Norm_k">
            <summary>Среднеквадратическое значение элементов матрицы</summary>
        </member>
        <member name="M:MathService.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary><param name="N">Число строк</param><param name="M">Число столбцов</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="N"/> &lt; 0 || <paramref name="M"/> &lt; 0</exception>
        </member>
        <member name="M:MathService.Matrix.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary><param name="N">Размерность</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="N" /> &lt; 0</exception>
        </member>
        <member name="T:MathService.Matrix.MatrixItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param><param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathService.Matrix.#ctor(System.Int32,MathService.Matrix.MatrixItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.Matrix.#ctor(System.Int32,System.Int32,MathService.Matrix.MatrixItemCreator)">
            <summary>Матрица</summary><param name="N">Число строк</param><param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.Matrix.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>Инициализация новой матрицы по двумерному массиву её элементов</summary>
            <param name="Data">Двумерный массив элементов матрицы</param>
            <param name="clone">Создать копию данных</param>
        </member>
        <member name="M:MathService.Matrix.#ctor(System.Collections.Generic.IList{System.Double},System.Boolean)">
            <summary>Инициализация новой матрицы - столбца/строки</summary>
            <param name="DataCol">Элементы столбца матрицы</param>
            <param name="IsColumn">Создаётся матрица-столбец</param>
        </member>
        <member name="M:MathService.Matrix.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Double}})">
            <summary>Инициализация новой матрицы на основе перечисления строк (перечисления элементов строк) </summary>
            <param name="Items">Перечисление строк, состоящих из перечисления эламентов строк</param>
        </member>
        <member name="M:MathService.Matrix.GetElements(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Double}})">
            <summary>Получить двумерный массив элементов матрицы</summary>
            <param name="ColsItems">Перечисление элементов (по столбцам)</param>
            <returns>Двумерный массив элементов матрицы</returns>
        </member>
        <member name="M:MathService.Matrix.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathService.Matrix.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathService.Matrix.GetTriangle(MathService.Matrix@,System.Int32@,System.Double@)">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <param name="P">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="D">Определитель</param>
            <returns>Триугольная матрица</returns>
        </member>
        <member name="M:MathService.Matrix.GetTriangle(MathService.Matrix@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <param name="B">Присоединённая матрица правой части СЛАУ</param>
            <param name="CloneB">Работать с клоном матрицы <paramref name="B"/></param>
            <returns>Триугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="B"/> <see langword="null"/></exception>
        </member>
        <member name="M:MathService.Matrix.GetTriangle(MathService.Matrix@,MathService.Matrix@,System.Int32@,System.Double@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <param name="B">Матрица правой части СЛАУ</param>
            <param name="P">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <param name="CloneB">Клонировать матрицу правой части</param>
            <returns>Треугольная матрица</returns>
        </member>
        <member name="M:MathService.Matrix.GetInverse(MathService.Matrix@)">
            <summary>Получить обратную матрицу</summary>                                                     
            <param name="P">Матрица перестановок</param>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathService.Matrix.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathService.Matrix.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathService.Matrix.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathService.Matrix.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathService.Matrix.GetLUDecomposition(MathService.Matrix@,MathService.Matrix@,MathService.Matrix@,System.Double@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <param name="L">Нижне-треугольная матрица</param>
            <param name="U">Верхнетреугольная матрица</param>
            <param name="P">Матрица преобразований P*X = L*U</param>
            <param name="D">Знак определителя</param>
            <returns>Истина, если разложение выполнено успешно, ложь - если матрица вырожденная</returns>
        </member>
        <member name="M:MathService.Matrix.GetData">
            <summary>Получить внутренний массив элементов матрицы</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.Matrix.ToString">
            <inheritdoc/>
        </member>
        <member name="M:MathService.Matrix.ToStringFormat(System.String,System.String,System.IFormatProvider)">
            <summary>Преобразование матрицы в строку с форматированием</summary>
            <param name="Format">Строка формата вывода чисел</param>
            <param name="Splitter">Разделитель элементов матрицы</param>
            <param name="provider">Механизм форматирования чисел матрицы</param>
            <returns>Строковое представление матрицы</returns>
        </member>
        <member name="M:MathService.Matrix.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:MathService.Matrix.System#ICloneable#Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathService.Matrix.MathService#ICloneable{System#Double[,]}#Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathService.Matrix.Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathService.Matrix.op_Addition(MathService.Matrix,MathService.Matrix)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param><param name="B">Второе слогаемое</param><returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathService.Matrix.op_Subtraction(MathService.Matrix,MathService.Matrix)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param><param name="B">Вычитаемое</param><returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathService.Matrix.op_Multiply(MathService.Matrix,MathService.Matrix)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param><param name="B">Второй сомножитель</param><returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathService.Matrix.op_Division(MathService.Matrix,MathService.Matrix)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param><param name="B">Делитель</param><returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathService.Matrix.op_BitwiseOr(MathService.Matrix,MathService.Matrix)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param><param name="B">Второе слогаемое</param><returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathService.Matrix.op_Implicit(System.Double)~MathService.Matrix">
            <summary>Оператор неявного преведения типа вещественного числа двойной точнойсти к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порадка 1х1</returns>
        </member>
        <member name="M:MathService.Matrix.Equals(System.Double[0:,0:])">
            <inheritdoc/>
        </member>
        <member name="M:MathService.Matrix.Equals(MathService.Matrix)">
            <inheritdoc/>
        </member>
        <member name="M:MathService.Matrix.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:MathService.Matrix.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:MathService.MatrixComplex">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="T:MathService.MatrixComplex.Array">
            <summary>Операции над двумерными массивами</summary>
        </member>
        <member name="M:MathService.MatrixComplex.Array.MatrixToColsArray(MathService.Complex[0:,0:])">
            <summary>Преобразовать двумерный массив элементов матрицы в массив массивов-столбцов</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Массив столбцов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.MatrixToRowsArray(MathService.Complex[0:,0:])">
            <summary>Преобразовать двумерный массив элементов матрицы в массив массивов-строк</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Массив строк</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.ColsArrayToMatrix(MathService.Complex[][])">
            <summary>Создать двумерный массив массив матрицы из массива столбцов</summary>
            <param name="cols">Массив столбцов матрицы</param>
            <returns>Двумерный массив элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="cols"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.RowsArrayToMatrix(MathService.Complex[][])">
            <summary>Создать двумерный массив массив матрицы из массива строк</summary>
            <param name="rows">Массив строк матрицы</param>
            <returns>Двумерный массив элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="rows"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.IsMatrixSungular(MathService.Complex[0:,0:])">
            <summary>Проверка - является ли матрица вырожденой</summary>
            <param name="matrix">Проверяемая матрица</param>
            <returns>Истина, если определитель матрицы равен нулю</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов, или если матрица не квазратная</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Determinant(MathService.Complex[0:,0:])">
            <summary>Вычисление определителя матрицы</summary>
            <param name="matrix">Массви элементов матрицы</param>
            <returns>Значение определителя матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Rank(MathService.Complex[0:,0:])">
            <summary>Определение ранга матрицы</summary>
            <param name="matrix">Матрица, ранг которой требуется определить</param>
            <returns>Ранг матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.CreateDiagonal(MathService.Complex[])">
            <summary>Создать диагональную матрицу</summary>
            <param name="elements">Элементы диагонали матрицы</param>
            <returns>Двумерный массив, содержащий на главной диагонали элементы диагонильрной матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="elements"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetMatrixShadow(MathService.Complex[0:,0:])">
            <summary>Получить массив элементов тени (главной диагонали) матирцы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Массив элементов тени матрицы</returns>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.EnumerateMatrixShadow(MathService.Complex[0:,0:])">
            <summary>Перечислить элементы тени (главной диагонали) матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Перечисление элементов тени матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Permutation_Left(MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Применение матрицы перестановок слева (перестановка строк)</summary>
            <param name="matrix">Матрица, подвергаемая перестановке строк</param>
            <param name="p">Матрица перестановок (строк)</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица перестановок не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк матрицы не равно числу столбцов матрицы перестановок</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Permutation_Right(MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Применение матрицы перестановок справа (перестановка столбцов)</summary>
            <param name="matrix">Матрица, подвергаемая перестановке столбцов</param>
            <param name="p">Матрица перестановок (столбцов)</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица перестановок не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк матрицы не равно числу столбцов матрицы перестановок</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Permutation_Left_Internal(MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Применение матрицы перестановок слева (перестановка строк) без проверок</summary>
            <param name="matrix">Матрица, подвергаемая перестановке строк</param>
            <param name="p">Матрица перестановок (строк)</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="p"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Permutation_Right_Internal(MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Применение матрицы перестановок справа (перестановка столбцов) без проверок</summary>
            <param name="matrix">Матрица, подвергаемая перестановке столбцов</param>
            <param name="p">Матрица перестановок (столбцов)</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="p"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.CreateColArray(MathService.Complex[])">
            <summary>Создать двумерный массив элементов матрицы-столбца</summary>
            <param name="data">Элементы массива матрицы-столбца</param>
            <returns>Двумерный массив элементов матрицы столбца</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.CreateRowArray(MathService.Complex[])">
            <summary>Создать двумерный массив элементов матрицы-строки</summary>
            <param name="data">Элементы массива матрицы-строки</param>
            <returns>Двумерный массив элементов матрицы строки</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetLength(MathService.Complex[0:,0:],System.Int32@,System.Int32@)">
            <summary>Получить размерность массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="N">Число строк матриы</param>
            <param name="M">Число столбцов (элементов строки) матрицы</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetRowsCount(MathService.Complex[0:,0:],System.Int32@)">
            <summary>Получить число строк массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="N">Число строк матриы</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetColsCount(MathService.Complex[0:,0:],System.Int32@)">
            <summary>Получить число столбцов (элементов строки) массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="M">Число столбцов (элементов строки) матрицы</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetUnitaryArrayMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Квадратный двумерный массив размерности NxN с 1 на главной диагонали</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы <paramref name="N"/> меньше 1</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.InitializeUnitaryArrayMatrix(MathService.Complex[0:,0:])">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Квадратный двумерный массив размерности NxN с 1 на главной диагонали</returns>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetTransvection(MathService.Complex[0:,0:],System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="i0">Опорная строка</param>
            <returns>Трансвекция матрицы А</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="A"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если опорная строка <paramref name="i0"/> матрицы <paramref name="A"/> &lt; 0 и &gt; числа строк матрицы</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Transvection(MathService.Complex[0:,0:],System.Int32,MathService.Complex[0:,0:])">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Опорный столбец</param>
            <param name="result">Двумерный массив элементов матрицы результата</param>
            <returns>Трансвекция матрицы А</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрицы <paramref name="A"/> и <paramref name="result"/> не заданы</exception>  
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="A"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если опорный столбец <paramref name="j"/> матрицы <paramref name="A"/> меньше 0 или больше числа столбцов матрицы</exception>
            <exception cref="T:System.ArgumentException">В случае если размер матрицы <paramref name="result"/> не совпадает с размером матрицы <paramref name="A"/></exception>                  
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetCol(MathService.Complex[0:,0:],System.Int32)">
            <summary>Получить столбец матрицы в виде матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <returns>Матрица-столбец, составленная из элементов столбца матрицы c индексом j</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetCol_Array(MathService.Complex[0:,0:],System.Int32)">
            <summary>Получить столбец матрицы в виде маиива</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <returns>Массив, составленная из элементов столбца матрицы c индексом <paramref name="j"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetCol_Array(MathService.Complex[0:,0:],System.Int32,MathService.Complex[])">
            <summary>Получить столбец матрицы в виде маиива</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <param name="result">Массив, составленная из элементов столбца матрицы c индексом <paramref name="j"/></param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если массив <paramref name="result"/> не задан</exception>
            <exception cref="T:System.ArgumentException">В случае если размер массива <paramref name="result"/> не соответствует числу строк матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetRow(MathService.Complex[0:,0:],System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <returns>Матрица-строка, составленная из элементов строки матрицы с индексом <paramref name="i"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetRow_Array(MathService.Complex[0:,0:],System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <returns>Массив, составленный из элементов строки матрицы с индексом <paramref name="i"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetRow_Array(MathService.Complex[0:,0:],System.Int32,MathService.Complex[])">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <param name="result">Массив, составленный из элементов строки матрицы с индексом i</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если массив <paramref name="result"/> не задан</exception>
            <exception cref="T:System.ArgumentException">В случае если размер массива <paramref name="result"/> не соответствует числу столбцов матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Inverse(MathService.Complex[0:,0:])">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Обращаеемая матрица</param>
            <returns>Обратная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Inverse(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@)">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Обращаеемая матрица</param>
            <param name="p">Матрица перестановок</param>
            <returns>Обратная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Размерность массива 0х0</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetSolve(MathService.Complex[0:,0:],MathService.Complex[0:,0:],MathService.Complex[0:,0:]@)">
            <summary>Метод решения СЛАУ A*X=B -&gt; X</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <returns>Матрица решения уравнения A*X=B -&gt; X</returns>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Solve(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@,System.Boolean)">
            <summary>Метод решения СЛАУ</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <param name="clone_b">Работать с копией <paramref name="b"/></param>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.TrySolve(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@,System.Boolean)">
            <summary>Попытаться решить СЛАУ</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <param name="clone_b">Работать с копией <paramref name="b"/></param>
            <returns>Истина, если решение СЛАУ получено; ложь - если матрица СЛАУ <paramref name="matrix"/> варождена</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="b"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Inverse(MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Матрица, подлежащая обращению</param>
            <param name="result">Обратная матрица</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="result"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Transponse(MathService.Complex[0:,0:])">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Transponse(MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Транспонирование матрицы</summary>
            <param name="matrix">Исходная матрица</param>
            <param name="result">Транспонированная матрица</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="result"/> не задана</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetAdjunct(MathService.Complex[0:,0:],System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.CopyMinor(MathService.Complex[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32,MathService.Complex[0:,0:])">
            <summary>Скопировать минор из матрицы в матрицу результата</summary>
            <param name="matrix">Массив элементов исходной матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="result">Минор матрицы</param>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetMinor(MathService.Complex[0:,0:],System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetMinor(MathService.Complex[0:,0:],System.Int32,System.Int32,MathService.Complex[0:,0:])">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <param name="result">Минор элемента матрицы [n,m]</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число строк матрицы результата <paramref name="result"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число столбцов матрицы результата <paramref name="result"/> не равно числу столбцов исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetDeterminant(MathService.Complex[0:,0:])">
            <summary>Определитель матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Определитель матрицы</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Swap``1(``0@,``0@)">
            <summary>Поменять значения местами</summary>
            <typeparam name="T">Тип значения</typeparam>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetLUPDecomposition(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@,MathService.Complex@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="l">Нижне-треугольная матрица</param>
            <param name="u">Верхнетреугольная матрица</param>
            <param name="p">Матрица преобразований P*X = L*U</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура декомпозиции прошла успешно. Ложь, если матрица вырождена</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы <paramref name="matrix"/> меньше 1</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetLUDecomposition(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@,MathService.Complex@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="l">Нижне-треугольная матрица</param>
            <param name="u">Верхнетреугольная матрица</param>
            <param name="d">Определитль матрицы</param>
            <returns>Истина, если процедура декомпозиции прошла успешно. Ложь, если матрица вырождена</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы N меньше 1</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetLUPDecomposition(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@,MathService.Complex@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <param name="p">Массив матрицы перестановок</param>
            <param name="d">Определитль матрицы</param>
            <returns>Истина, если операция выполнена успешно</returns>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetLUPDecomposition(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@,MathService.Complex@)">
            <summary>LU-разложение матрицы</summary>
            <param name="matrix">Разлогаемая матрица</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура выполнена успешно</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetLUDecomposition(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@)">
            <summary>LU-разложение матрицы</summary>
            <param name="matrix">Разлогаемая матрица</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <returns>Истина, если разложение выполнено успешно</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.CreatePermutationMatrix(System.Int32[])">
            <summary>Создать матрицу перестановок из массива индексов</summary>
            <param name="indexes">Массив индексов элементов стольцов</param>
            <returns>Матрица перестановок</returns>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetTriangle(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@,System.Int32@,MathService.Complex@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гауса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="p">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Триугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetTriangle(MathService.Complex[0:,0:],System.Int32@,MathService.Complex@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гауса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Триугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetTriangle(MathService.Complex[0:,0:],MathService.Complex[0:,0:],System.Int32@,MathService.Complex@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гауса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="b">Матрица правой части</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Триугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetTriangle(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@,System.Int32@,MathService.Complex@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гауса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="b">Матрица правой части</param>
            <param name="p">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <param name="clone_b">Клонировать матрицу правых частей</param>
            <returns>Триугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Triangulate(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@,MathService.Complex@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к триугольному виду</param>
            <param name="p">Матрица перестановок</param>
            <param name="d">Определитель матрицы (проидведение диогональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Triangulate(MathService.Complex[0:,0:],MathService.Complex@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к триугольному виду</param>
            <param name="d">Определитель матрицы (проидведение диогональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Triangulate(MathService.Complex[0:,0:],MathService.Complex[0:,0:],MathService.Complex@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к триугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="d">Определитель матрицы (проидведение диогональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Triangulate(MathService.Complex[0:,0:]@,MathService.Complex[0:,0:],MathService.Complex@,System.Boolean)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к триугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="d">Определитель матрицы (проидведение диогональных элементов)</param>
            <param name="clone">Клонировать исходную матрицу</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Triangulate(MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@,MathService.Complex@,System.Boolean,System.Boolean)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к триугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="p">Матрица перестановок</param>
            <param name="d">Определитель матрицы (проидведение диогональных элементов)</param>
            <param name="clone_matrix">Клонировать исходную матрицу</param>
            <param name="clone_b">Клонировать присоединённую матрицу</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединнённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.AreEquals(MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Сравнение двух двумерных массивов элементов матриц</summary>
            <param name="A">Первый массив</param>
            <param name="B">Второй массив</param>
            <returns>Истина, если оба массивы неопределены, либо если оба массивы - один и тот же массив, либо если элементы массивов идентичны</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.AreEquals(MathService.Complex[0:,0:],MathService.Complex[0:,0:],System.Double)">
            <summary>Сравнение двух двумерных массивов элементов матриц</summary>
            <param name="A">Первый массив</param>
            <param name="B">Второй массив</param>
            <param name="eps">Точность сравнения</param>
            <returns>Истина, если оба массивы неопределены, либо если оба массивы - один и тот же массив, либо если элементы массивов идентичны</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetMaxRowAbsSumm(MathService.Complex[0:,0:])">
            <summary>Вычисление максимуа от сумм абсолютных значений по элементам строк</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Максимальная из сумм абсолютных значений элементов строк</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetMaxColAbsSumm(MathService.Complex[0:,0:])">
            <summary>Вычисление максимуа от сумм абсолютных значений по элементам столбцов</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Максимальная из сумм абсолютных значений элементов столбцов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GetRMS(MathService.Complex[0:,0:])">
            <summary>Вычисление среднеквадратического значения элементов матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Среднеквадратическое значение элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Sqr(MathService.Complex)">
            <summary>Квадрат числа</summary>
            <param name="x">Значение, квадрат которого требуется получить</param>
            <returns>Квадрат указанного числа</returns>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GausSeidelConverge(MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@,System.Double,System.Int32,System.Int32)">
            <summary>Метод проверки сходимости метода Метод Гаусса — Зейделя</summary>
            <remarks>Метод меняет местами матрицы решения текущего и прошлого шагов, если метод Гаусса — Зейделя не сашёлся на текущем шаге</remarks>
            <param name="new_x">Новое полученное решение</param>
            <param name="last_x">Решение, полученное на прошлом шаге метода</param>
            <param name="eps">Требуемая точность решения</param>
            <param name="N">Число строк матрицы решения</param>
            <param name="M">Число столбцов матрицы решения</param>
            <returns>Истина, если метод сошёлся Метод Гаусса — Зейделя</returns>
        </member>
        <member name="M:MathService.MatrixComplex.Array.GausSeidelSolove(MathService.Complex[0:,0:],MathService.Complex[0:,0:],MathService.Complex[0:,0:],System.Double)">
            <summary>Метод Гаусса — Зейделя решения системы линейных уравнений</summary>
            <param name="matrix">Матрица коэффициентов</param>
            <param name="x">Матрица неизвестных</param>
            <param name="b">Матрица правых частей</param>
            <param name="eps">Требуемая точность</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="b"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица системы не содержит элементов</exception>
            <exception cref="T:System.ArgumentException">Матрица системы не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк массива неизвестных не совпадает с числом строк матрицы системы</exception>
            <exception cref="T:System.ArgumentException">Число строк массива правой части СЛАУ не совпадает с числом строк матрицы системы</exception>
            <exception cref="T:System.ArgumentException">Число столбцов массива правых частей не совпадает с числом столбцов массива неизвестных</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="eps"/> &lt;= <see cref="T:MathService.Complex"/>.<see cref="F:MathService.Complex.Epsilon"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.QRDecomposition(MathService.Complex[0:,0:],MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>QR-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="q">Унитарная матрица (ортогональная) - должна быть передана квадратная матирца nxn != null</param>
            <param name="r">Верхнетреугольная матрица - должна быть передана квадратная матирца nxn != null</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.QRDecomposition(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@,MathService.Complex[0:,0:]@)">
            <summary>QR-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="q">Унитарная матрица (ортогональная) - создаётся квадратная матирца nxn != null</param>
            <param name="r">Верхнетреугольная матрица - создаётся квадратная матирца nxn != null</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.SVD(MathService.Complex[0:,0:],MathService.Complex[0:,0:]@,MathService.Complex[]@,MathService.Complex[0:,0:]@)">
            <summary>SVD-разложение</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="u">Матрица левых сингулярных векторов</param>
            <param name="w">Вектор собственных чисел</param>
            <param name="v">Матрица правых сингулярных векторов</param>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Метод не сошёлся за 30 итераций</exception>
        </member>
        <member name="T:MathService.MatrixComplex.Array.Operator">
            <summary>Операторы над двумерными массивами</summary>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Multyply(MathService.Complex[],MathService.Complex[])">
            <summary>Скалярное произведение векторов</summary>
            <param name="v1">Первый множитель скалярного произведения</param>
            <param name="v2">второй множитель скалярного произведения</param>
            <returns>Скалярное произведение векторов</returns>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.VectorLength(MathService.Complex[])">
            <summary>Длина вектора</summary>
            <param name="v">Вектор элементов</param>
            <returns>Длина вектора</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Multyply(MathService.Complex[],MathService.Complex)">
            <summary>Умножение вектора на число</summary>
            <param name="v1">Первый сомножитель - вектор элэементов</param>
            <param name="v2">Второй сомножитель - число, на которое должны быть умножены все элементы вектора</param>
            <returns>Вектор произведений элементов входного вектора и числа</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Divade(MathService.Complex[],MathService.Complex)">
            <summary>Деление вектора элементов на число</summary>
            <param name="v1">Вектор-делимое</param>
            <param name="v2">Число-делитель</param>
            <returns>Вектор, составленный из частного элементов вектора-делимого и числового делителя</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Projection(MathService.Complex[],MathService.Complex[])">
            <summary>Проекция вектора на вектор</summary>
            <returns>Вектор - произведение компонентов исходных векторов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> or <paramref name="v2"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Длины векторов не совпадают</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Add(MathService.Complex[0:,0:],MathService.Complex)">
            <summary>Оператор вычисления суммы двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив суммы элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Add(MathService.Complex[],MathService.Complex[])">
            <summary>Поэлементное сложение двух матриц</summary>
            <param name="a">Матрица - первое слогаемое</param>
            <param name="b">Матрица - второе слагаемое</param>
            <returns>Матрица, составленная из элементов - сумм элементов исходных матриц</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Substract(MathService.Complex[],MathService.Complex[])">
            <summary>Оператор вычитания между двумя столбцами</summary>
            <param name="a">Столбец уменьшаемого</param>
            <param name="b">Столбец вычитаемого</param>
            <returns>Вектор-столбец разности указанных векторов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Размеры векторов не совпадают</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.MultiplyComponent(MathService.Complex[],MathService.Complex[])">
            <summary>Оператор вычисления поэлементного произведения двух векторов</summary>
            <param name="a">Вектор элементов первого множителя</param>
            <param name="b">Вектор элементов второго множителя</param>
            <returns>Вектор элементов произведения</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Размеры векторов не совпадают</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.DivadeComponent(MathService.Complex[],MathService.Complex[])">
            <summary>Оператор вычисления поэлементного деления двух векторов</summary>
            <param name="a">Вектор - делимое</param>
            <param name="b">Вектор - делитель</param>
            <returns>Вектор, составленный из поэлементного частного элементов векторов делимого и делителя</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Substract(MathService.Complex[0:,0:],MathService.Complex)">
            <summary>Оператор вычисления разности двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив разности элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Substract(MathService.Complex,MathService.Complex[0:,0:])">
            <summary>Оператор вычисления разности двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив разности элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Multyply(MathService.Complex[0:,0:],MathService.Complex)">
            <summary>Оператор вычисления произведения двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив произведения элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Divade(MathService.Complex[0:,0:],MathService.Complex)">
            <summary>Оператор вычисления произведения двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив произведения элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Divade(MathService.Complex,MathService.Complex[0:,0:])">
            <summary>Оператор вычисления частного двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив частного элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Add(MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Оператор вычисления суммы элементов двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив суммы элементов двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы не равны</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Substract(MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Оператор вычисления разности элементов двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив разности элементов двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы не равны</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.MultylyCol(MathService.Complex[0:,0:],MathService.Complex[])">
            <summary>Оператор вычисления произведения элементов матрицы на столбец</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="col">Массив элементов столбца</param>
            <returns>Массив произведения элементов матрицы и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="col"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы и столбца не равны</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.MultylyRow(MathService.Complex[],MathService.Complex[0:,0:])">
            <summary>Оператор вычисления произведения элементов строки и матрицы</summary>
            <param name="B">Массив элементов первой матрицы</param>
            <param name="row">Массив элементов строки</param>
            <returns>Массив произведения элементов матрицы и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="row"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы и строки не равны</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.MultylyRowToCol(MathService.Complex[],MathService.Complex[])">
            <summary>Оператор вычисления произведения элементов строки и элементов столбца</summary>
            <param name="col">Массив элементов столбца</param>
            <param name="row">Массив элементов строки</param>
            <returns>Массив произведения элементов строки и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="col"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="row"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности строки и столбца не равны</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Multyly(MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив произведения двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Multyly(MathService.Complex[0:,0:],MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <param name="result">Массив элементов произведения</param>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="result"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матриц несогласованы</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк <paramref name="result"/> не равно числу строк <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число столбцов <paramref name="result"/> не равно числу строк <paramref name="B"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Divade(MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матриц несогласованы</exception>
        </member>
        <member name="M:MathService.MatrixComplex.Array.Operator.Concatinate(MathService.Complex[0:,0:],MathService.Complex[0:,0:])">
            <summary>Объединение метриц по строкам, либо столбцам</summary>
            <returns>Двумерный массив, содержащий объединение элементов исходных массивов по строкам, либо столбцам</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> or <paramref name="B"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.CreateCol(MathService.Complex[])">
            <summary>Создать матрицу-столбец</summary><param name="data">Элементы столбца</param><returns>Матрица-столбец</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathService.MatrixComplex.CreateRow(MathService.Complex[])">
            <summary>Создать матрицу-строку</summary><param name="data">Элементы строки</param><returns>Матрица-строка</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathService.MatrixComplex.CreateDiagonalMatrixComplex(MathService.Complex[])">
            <summary>Создать диагональную матрицу</summary><param name="elements">Элементы диагональной матрицы</param>
            <returns>Диагональная матрица</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param><returns>Единичная матрица размерности NxN с 1 на главной диагонали</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetTransvection(MathService.MatrixComplex,System.Int32)">
            <summary>Трансвекция матрицы</summary><param name="A">Трансвецируемая матрица</param><param name="j">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathService.MatrixComplex._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathService.MatrixComplex._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathService.MatrixComplex._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathService.MatrixComplex.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathService.MatrixComplex.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathService.MatrixComplex.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathService.MatrixComplex.Item(System.Int32)">
            <summary>Вектор-стольбец</summary><param name="j">Номер столбца</param><returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathService.MatrixComplex.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathService.MatrixComplex.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathService.MatrixComplex.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathService.MatrixComplex.IsScalar">
            <summary>Матрица является числом</summary>
        </member>
        <member name="P:MathService.MatrixComplex.T">
            <summary>Транспонированная матрица</summary>
        </member>
        <member name="P:MathService.MatrixComplex.Norm_m">
            <summary>Максимум среди абсолютных сумм элементов строк</summary>
        </member>
        <member name="P:MathService.MatrixComplex.Norm_l">
            <summary>Максимум среди абсолютных сумм элементов столбцов</summary>
        </member>
        <member name="P:MathService.MatrixComplex.Norm_k">
            <summary>Среднеквадратическое значение элементов матрицы</summary>
        </member>
        <member name="M:MathService.MatrixComplex.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary><param name="N">Число строк</param><param name="M">Число столбцов</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="N"/> &lt; 0 || <paramref name="M"/> &lt; 0</exception>
        </member>
        <member name="M:MathService.MatrixComplex.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary><param name="N">Размерность</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="N" /> &lt; 0</exception>
        </member>
        <member name="T:MathService.MatrixComplex.MatrixComplexItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param><param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathService.MatrixComplex.#ctor(System.Int32,MathService.MatrixComplex.MatrixComplexItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixComplex.#ctor(System.Int32,System.Int32,MathService.MatrixComplex.MatrixComplexItemCreator)">
            <summary>Матрица</summary><param name="N">Число строк</param><param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixComplex.#ctor(MathService.Complex[0:,0:],System.Boolean)">
            <summary>Инициализация новой матрицы по двумерному массиву её элементов</summary>
            <param name="Data">Двумерный массив элементов матрицы</param>
            <param name="clone">Создать копию данных</param>
        </member>
        <member name="M:MathService.MatrixComplex.#ctor(System.Collections.Generic.IList{MathService.Complex},System.Boolean)">
            <summary>Инициализация новой матрицы - столбца/строки</summary>
            <param name="DataCol">Элементы столбца матрицы</param>
            <param name="IsColumn">Создаётся матрица-столбец</param>
        </member>
        <member name="M:MathService.MatrixComplex.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{MathService.Complex}})">
            <summary>Инициализация новой матрицы на основе перечисления строк (перечисления элементов строк) </summary>
            <param name="Items">Перечисление строк, состоящих из перечисления эламентов строк</param>
        </member>
        <member name="M:MathService.MatrixComplex.GetElements(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{MathService.Complex}})">
            <summary>Получить двумерный массив элементов матрицы</summary>
            <param name="ColsItems">Перечисление элементов (по столбцам)</param>
            <returns>Двумерный массив элементов матрицы</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetTriangle(MathService.MatrixComplex@,System.Int32@,MathService.Complex@)">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <param name="P">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="D">Определитель</param>
            <returns>Триугольная матрица</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetTriangle(MathService.MatrixComplex@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <param name="B">Присоединённая матрица правой части СЛАУ</param>
            <param name="CloneB">Работать с клоном матрицы <paramref name="B"/></param>
            <returns>Триугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="B"/> <see langword="null"/></exception>
        </member>
        <member name="M:MathService.MatrixComplex.GetTriangle(MathService.MatrixComplex@,MathService.MatrixComplex@,System.Int32@,MathService.Complex@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <param name="B">Матрица правой части СЛАУ</param>
            <param name="P">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <param name="CloneB">Клонировать матрицу правой части</param>
            <returns>Треугольная матрица</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetInverse(MathService.MatrixComplex@)">
            <summary>Получить обратную матрицу</summary>                                                     
            <param name="P">Матрица перестановок</param>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathService.MatrixComplex.GetLUDecomposition(MathService.MatrixComplex@,MathService.MatrixComplex@,MathService.MatrixComplex@,MathService.Complex@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <param name="L">Нижне-треугольная матрица</param>
            <param name="U">Верхнетреугольная матрица</param>
            <param name="P">Матрица преобразований P*X = L*U</param>
            <param name="D">Знак определителя</param>
            <returns>Истина, если разложение выполнено успешно, ложь - если матрица вырожденная</returns>
        </member>
        <member name="M:MathService.MatrixComplex.GetData">
            <summary>Получить внутренний массив элементов матрицы</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MatrixComplex.ToString">
            <inheritdoc/>
        </member>
        <member name="M:MathService.MatrixComplex.ToStringFormat(System.String,System.String,System.IFormatProvider)">
            <summary>Преобразование матрицы в строку с форматированием</summary>
            <param name="Format">Строка формата вывода чисел</param>
            <param name="Splitter">Разделитель элементов матрицы</param>
            <param name="provider">Механизм форматирования чисел матрицы</param>
            <returns>Строковое представление матрицы</returns>
        </member>
        <member name="M:MathService.MatrixComplex.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:MathService.MatrixComplex.System#ICloneable#Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathService.MatrixComplex.MathService#ICloneable{MathService#Complex[,]}#Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathService.MatrixComplex.Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathService.MatrixComplex.op_Addition(MathService.MatrixComplex,MathService.MatrixComplex)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param><param name="B">Второе слогаемое</param><returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixComplex.op_Subtraction(MathService.MatrixComplex,MathService.MatrixComplex)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param><param name="B">Вычитаемое</param><returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixComplex.op_Multiply(MathService.MatrixComplex,MathService.MatrixComplex)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param><param name="B">Второй сомножитель</param><returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixComplex.op_Division(MathService.MatrixComplex,MathService.MatrixComplex)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param><param name="B">Делитель</param><returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixComplex.op_BitwiseOr(MathService.MatrixComplex,MathService.MatrixComplex)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param><param name="B">Второе слогаемое</param><returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathService.MatrixComplex.op_Implicit(MathService.Complex)~MathService.MatrixComplex">
            <summary>Оператор неявного преведения типа вещественного числа двойной точнойсти к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порадка 1х1</returns>
        </member>
        <member name="M:MathService.MatrixComplex.Equals(MathService.Complex[0:,0:])">
            <inheritdoc/>
        </member>
        <member name="M:MathService.MatrixComplex.Equals(MathService.MatrixComplex)">
            <inheritdoc/>
        </member>
        <member name="M:MathService.MatrixComplex.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:MathService.MatrixComplex.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:MathService.ObjectAnimator.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="T:MathService.Attributes.ElementNameAttribute">
            <summary>Имя элемента</summary>
        </member>
        <member name="P:MathService.Attributes.ElementNameAttribute.Name">
            <summary>Имя элемента</summary>
        </member>
        <member name="M:MathService.Attributes.ElementNameAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:MathService.Attributes.ElementNameAttribute"/></summary>
            <param name="Name">Имя элемента</param>
        </member>
        <member name="M:MathService.Attributes.ElementNameAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathService.Attributes.ElementNameAttribute.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathService.Attributes.ElementNameAttribute.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathService.Attributes.ElementNameAttribute.op_Implicit(MathService.Attributes.ElementNameAttribute)~System.String">
            <summary>Оператор неявного приведения типа <see cref="T:MathService.Attributes.ElementNameAttribute"/> к <see cref="T:System.String"/></summary>
            <param name="A">Атрибут имени</param>
        </member>
        <member name="T:MathService.TypeDesigners.TypeDesignerAttribute">
            <summary>Дизайнер типа</summary>
        </member>
        <member name="P:MathService.TypeDesigners.TypeDesignerAttribute.Designer">
            <summary>Доступ к экземпляру <see cref="T:MathService.TypeDesigners.ITypeDesigner"/> дизайнера типа</summary>
        </member>
        <member name="P:MathService.TypeDesigners.TypeDesignerAttribute.DesignerType">
            <summary>Тип <see cref="T:MathService.TypeDesigners.ITypeDesigner"/>-дизайнер типа</summary>
        </member>
        <member name="M:MathService.TypeDesigners.TypeDesignerAttribute.#ctor(System.Type)">
            <summary>Инициализация нового экземпляра <see cref="T:MathService.TypeDesigners.TypeDesignerAttribute"/></summary>
            <param name="DesignerType">Тип <see cref="T:MathService.TypeDesigners.ITypeDesigner"/> - дизайнер типа</param>
        </member>
        <member name="T:MathService.TypeDesigners.ITypeDesigner">
            <summary>Интерфейс редактора объекта</summary>
        </member>
        <member name="M:MathService.TypeDesigners.ITypeDesigner.Edit(System.Object)">
            <summary>Редактировать объект</summary>
            <param name="Item">Редактируемый объект</param>
        </member>
        <member name="M:MathService.TypeDesigners.ITypeDesigner.Clear">
            <summary>Очистка интерфейса</summary>
        </member>
        <member name="M:MathService.TypeDesigners.ITypeDesigner`1.Edit(`0)">
            <summary>Редактировать объект</summary>
            <param name="Item">Редактируемый объект</param>
        </member>
        <member name="M:MathService.TypeDesigners.ITypeDesigner`1.Clear">
            <summary>Очистка интерфейса</summary>
        </member>
        <member name="M:MathService.CommandStringArguments.GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции аргументов командной строки</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, 
            который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathService.CommandStringArguments.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, 
            который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.Complex">
            <summary>Комплексное число</summary>
        </member>
        <member name="M:MathService.Complex.op_UnaryNegation(MathService.Complex@)">
            <summary>Унарный оператор разности. Возвращает число -Re-jIm</summary>
            <param name="z">Комплексное число</param>
            <returns>Возвращает -Re-jIm</returns>
        </member>
        <member name="M:MathService.Complex.op_UnaryPlus(MathService.Complex@)">
            <summary>Унарный оператор суммы. Возвращает число Re+jIm</summary>
            <param name="z">Комплексное число</param>
            <returns>Возвращает Re+jIm</returns>
        </member>
        <member name="M:MathService.Complex.op_LogicalNot(MathService.Complex@)">
            <summary>Оператор комплексного сопряжения</summary>
            <param name="z">Комплексное число</param>
            <returns>Возвращает Re-jIm</returns>
        </member>
        <member name="M:MathService.Complex.op_Addition(MathService.Complex@,MathService.Complex@)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слогаемое</param>
            <param name="Y">Второе слогаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_Subtraction(MathService.Complex@,MathService.Complex@)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_Addition(System.Double,MathService.Complex@)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слогаемое</param>
            <param name="Y">Второе слогаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_Addition(System.Int32,MathService.Complex@)">
            <summary>Оператор суммы целого и комплексного числа</summary>
            <param name="X">Целое число</param>
            <param name="Y">Комплексное число</param>
            <returns>X+Re{Y}+jIm{Y}</returns>
        </member>
        <member name="M:MathService.Complex.op_Addition(System.Single,MathService.Complex@)">
            <summary>Оператор суммы вещественного числа одинарной точности и комплексного числа</summary>
            <param name="X">Вещественное число одинарной точности число</param>
            <param name="Y">Комплексное число</param>
            <returns>X+Re{Y}+jIm{Y}</returns>
        </member>
        <member name="M:MathService.Complex.op_Subtraction(System.Double,MathService.Complex@)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_Subtraction(System.Int32,MathService.Complex@)">
            <summary>Оператор разности целого и комплексного числа</summary>
            <param name="X">Целое число</param>
            <param name="Y">Комплексное число</param>
            <returns>X-Re{Y}-jIm{Y}</returns>
        </member>
        <member name="M:MathService.Complex.op_Subtraction(System.Single,MathService.Complex@)">
            <summary>Оператор разности вещественного числа одинарной точности и комплексного числа</summary>
            <param name="X">Вещественное число одинарной точности число</param>
            <param name="Y">Комплексное число</param>
            <returns>X-Re{Y}-jIm{Y}</returns>
        </member>
        <member name="M:MathService.Complex.op_Addition(MathService.Complex@,System.Double)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слогаемое</param>
            <param name="Y">Второе слогаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_Addition(MathService.Complex@,System.Int32)">
            <summary>Оператор суммы комплексного числа и целого числа</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Целое число</param>
            <returns>Re{X}+Y+jIm{X}</returns>
        </member>
        <member name="M:MathService.Complex.op_Addition(MathService.Complex@,System.Single)">
            <summary>Оператор суммы комплексного числа и вещественного числа одинарной точности</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число одинарной точности</param>
            <returns>Re{X}+Y+jIm{X}</returns>
        </member>
        <member name="M:MathService.Complex.op_Subtraction(MathService.Complex@,System.Double)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_Subtraction(MathService.Complex@,System.Int32)">
            <summary>Оператор разности комплексного числа и целого числа</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Целое число</param>
            <returns>Re{X}-Y+jIm{X}</returns>
        </member>
        <member name="M:MathService.Complex.op_Subtraction(MathService.Complex@,System.Single)">
            <summary>Оператор разности комплексного числа и вещественного числа одинарной точности</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число одинарной точности</param>
            <returns>Re{X}-Y+jIm{X}</returns>
        </member>
        <member name="M:MathService.Complex.op_Multiply(MathService.Complex@,System.Double)">
            <summary>Оператор умножения комплексного числа на вещественное</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathService.Complex.op_Multiply(MathService.Complex@,System.Int32)">
            <summary>Оператор умножения комплексного числа на целое</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Целое число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathService.Complex.op_Multiply(MathService.Complex@,System.Single)">
            <summary>Оператор умножения комплексного числа на вещественное одинарной точности</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число одинарной точности</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathService.Complex.op_Division(MathService.Complex@,System.Double)">
            <summary>Оператор деления комплексного числа на вещественное</summary>
            <param name="X">Комплексное делимое число</param>
            <param name="Y">Вещественный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathService.Complex.op_Division(MathService.Complex@,System.Int32)">
            <summary>Оператор деления комплексного числа на целое</summary>
            <param name="X">Комплексное делимое число</param>
            <param name="Y">Целый делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathService.Complex.op_Division(MathService.Complex@,System.Single)">
            <summary>Оператор деления комплексного числа на вещественное одинарной точности</summary>
            <param name="X">Комплексное делимое число</param>
            <param name="Y">Вещественный делитель одинарной точности</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathService.Complex.op_Multiply(System.Double,MathService.Complex@)">
            <summary>Оператор произведения вещественного и комплексного числа</summary>
            <param name="X">Вещественное число</param>
            <param name="Y">Комплексное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathService.Complex.op_Multiply(System.Int32,MathService.Complex@)">
            <summary>Оператор произведения целого и комплексного числа</summary>
            <param name="X">Целое число</param>
            <param name="Y">Комплексное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathService.Complex.op_Multiply(System.Single,MathService.Complex@)">
            <summary>Оператор произведения вещественного числа одинарной точности и комплексного числа</summary>
            <param name="X">Вещественное число одинарной точности</param>
            <param name="Y">Комплексное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathService.Complex.op_Division(System.Double,MathService.Complex@)">
            <summary>Оператор деления вещественного и комплексного числа</summary>
            <param name="X">Вещественное делимое число</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathService.Complex.op_Division(System.Int32,MathService.Complex@)">
            <summary>Оператор деления целого и комплексного числа</summary>
            <param name="X">Целого делимое число</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathService.Complex.op_Division(System.Single,MathService.Complex@)">
            <summary>Оператор деления вещественного числа одинарной точности и комплексного числа</summary>
            <param name="X">Вещественное делимое число одинарной точности</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathService.Complex.op_Multiply(MathService.Complex@,MathService.Complex@)">
            <summary>Оператор произведения двух комплексных чисел</summary>
            <param name="X">Первый множитель</param>
            <param name="Y">Второй множитель</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathService.Complex.op_Division(MathService.Complex@,MathService.Complex@)">
            <summary>Оператор деления двух комплексных чисел</summary>
            <param name="X">Делимое комплексное число</param>
            <param name="Y">Делитель комплексного числа</param>
            <returns>Частное двух комплексных чисел</returns>
        </member>
        <member name="M:MathService.Complex.op_ExclusiveOr(MathService.Complex@,System.Double)">
            <summary>Возведение комплексного числа в вещественную степень по формуле Муавра</summary>
            <param name="Z">Возводимое в степень комплексное число Z^X</param>
            <param name="X">Вещественный показатель степени Z^X</param>
            <returns>Z^X</returns>       
        </member>
        <member name="M:MathService.Complex.op_ExclusiveOr(MathService.Complex@,System.Single)">
            <summary>Возведение комплексного числа в вещественную степень одинарной точности по формуле Муавра</summary>
            <param name="Z">Возводимое в степень комплексное число Z^X</param>
            <param name="X">Вещественный показатель степени одинарной точности Z^X</param>
            <returns>Z^X</returns> 
        </member>
        <member name="M:MathService.Complex.op_ExclusiveOr(MathService.Complex@,System.Int32)">
            <summary>Возведение комплексного числа в целую степень по формуле Муавра</summary>
            <param name="Z">Возводимое в степень комплексное число Z^X</param>
            <param name="X">Целый показатель степени Z^X</param>
            <returns>Z^X</returns> 
        </member>
        <member name="M:MathService.Complex.op_ExclusiveOr(System.Double,MathService.Complex@)">
            <summary>Оператор возведения вещественного числа в комплексную степень</summary>
            <param name="X">Вещественное число</param>
            <param name="Z">Комплексная степень</param>
            <returns>Комплексный результат возведения вещественного числа в комплексную степень</returns>
        </member>
        <member name="M:MathService.Complex.op_ExclusiveOr(System.Single,MathService.Complex@)">
            <summary>Оператор возведения вещественного числа одинарной точности в комплексную степень</summary>
            <param name="X">Вещественное число одинарной точности</param>
            <param name="Z">Комплексная степень</param>
            <returns>Комплексный результат возведения вещественного числа одинарной точности в комплексную степень</returns>
        </member>
        <member name="M:MathService.Complex.op_ExclusiveOr(System.Int32,MathService.Complex@)">
            <summary>Оператор возведения целого числа в комплексную степень</summary>
            <param name="X">Целое число</param>
            <param name="Z">Комплексная степень</param>
            <returns>Комплексный результат возведения целого числа в комплексную степень</returns>
        </member>
        <member name="M:MathService.Complex.op_ExclusiveOr(MathService.Complex@,MathService.Complex@)">
            <summary>Оператор возведения комплексного числа в комплексную степень</summary>
            <param name="X">Комплексное основание экспоненты</param>
            <param name="Y">Комплексный показатель степени</param>
            <returns>Комплексный результат возведения комплексного числа в комплексную степень</returns>
        </member>
        <member name="M:MathService.Complex.op_Equality(MathService.Complex@,MathService.Complex@)">
            <summary>Оператор сравнения двух комплексных чисел (равенства)</summary>
            <returns>Истина, если числа равны между собой</returns>
        </member>
        <member name="M:MathService.Complex.op_Inequality(MathService.Complex@,MathService.Complex@)">
            <summary>Оператор сравнения двух комплексных чисел (неравенства)</summary>
            <returns>Истина, если числа не равны</returns>
        </member>
        <member name="M:MathService.Complex.op_Explicit(MathService.Complex@)~System.Double">
            <summary>ОПератор неявного приведения к дробному типу чисел с двойной точностью</summary>
            <param name="Z">Приводимое комплексное число</param>
            <returns>Модуль комплексного числа</returns>
        </member>
        <member name="M:MathService.Complex.op_Implicit(System.Double@)~MathService.Complex">
            <summary>Оператор неявного приведения дробного числа двойной точности к комплексному виду</summary>
            <param name="X">Вещественное число двойной точности</param>
            <returns>Комплексное число</returns>
        </member>
        <member name="T:MathService.Complex.Trigonomerty">
            <summary>Тригонометрические функции комплексного переменного</summary>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Sin(MathService.Complex@)">
            <summary>Синус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Синус комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Cos(MathService.Complex@)">
            <summary>Косинус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Косинус комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.tg(MathService.Complex@)">
            <summary>Тангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Тангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.ctg(MathService.Complex@)">
            <summary>Котангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Котангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Atan(MathService.Complex@)">
            <summary>Арктангенс комплексного переменного</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Арктангенс комплексного аргумента</returns>
        </member>
        <member name="T:MathService.Complex.Trigonomerty.Hyperbolic">
            <summary>Гиперболические функции</summary>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Hyperbolic.Sh(MathService.Complex@)">
            <summary>Гиперболический синус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический синус комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Hyperbolic.Ch(MathService.Complex@)">
            <summary>Гиперболический косинус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический косинус комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Hyperbolic.tgh(MathService.Complex@)">
            <summary>Гиперболический тангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический тангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.Trigonomerty.Hyperbolic.ctgh(MathService.Complex@)">
            <summary>Гиперболический котангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический котангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathService.Complex.ClearString(System.String@)">
            <summary>Метод убирает все парные символы скобок в начале и конце строки</summary>
            <param name="str">Очищаемая строка</param>
        </member>
        <member name="M:MathService.Complex.Parse(System.String)">
            <summary>Разобрать строку в комплексное число</summary>
            <param name="str">Разбираемая строка</param>
            <returns>Комплексное число, получаемое в результате разбора строки</returns>
            <exception cref="T:System.ArgumentNullException">В случае если передана пустая ссылка на строку</exception>
            <exception cref="T:System.FormatException">В случае ошибочной строки</exception>
        </member>
        <member name="M:MathService.Complex.TryParse(System.String,MathService.Complex@)">
            <summary>Попытаться разобрать строку и преобразовать её в комплексное число</summary>
            <param name="str">Разбираемая строка</param>
            <param name="z">Число, получаемое в результате разбора строки</param>
            <returns>Истина, если операция разбора строки выполнена успешно</returns>
        </member>
        <member name="F:MathService.Complex.Epsilon">
            <summary>Точность вычисления тригонометрических функций 3e-16 </summary>
            <remarks>Определено приближённо</remarks>
        </member>
        <member name="M:MathService.Complex.Ln(System.Double)">
            <summary>Логарифм комплексного аргумента</summary>
            <param name="Im">Комплексный аргумент</param>
            <returns>Значение логарифма</returns>
        </member>
        <member name="M:MathService.Complex.Ln(MathService.Complex@)">
            <summary>НАтуральный логорифм комплексного числа</summary>
            <param name="z">Комплексное число</param>
            <returns>Натуральный логорифм</returns>
        </member>
        <member name="M:MathService.Complex.Log(System.Double,System.Double)">
            <summary>Логорифм мномого числа по действительному основанию</summary>
            <param name="Im">Мнимое число</param>
            <param name="b">Действительное основание логорифма</param>
            <returns>Логорифм мнимого числа по действительному основанию</returns>
        </member>
        <member name="M:MathService.Complex.Log(MathService.Complex@,System.Double)">
            <summary>Логарифм комплексного числа по действительному аргументу</summary>
            <param name="z">Комплексное число</param>
            <param name="b">Действительное основание логорифма</param>
            <returns>Логорифм комплексного числа по действительному основанию</returns>
        </member>
        <member name="M:MathService.Complex.Exp(System.Double)">
            <summary>Экспоненциальная форма числа Z = e^j*Arg</summary>
            <param name="Arg">Аргумент</param>
            <returns>Комплексное число в экспоненциальной форме записи</returns>
        </member>
        <member name="M:MathService.Complex.Exp(System.Double,System.Double)">
            <summary>Экспоненциальная форма числа Z = Abs * e^j*Arg</summary>
            <param name="Abs">Модуль числа</param>
            <param name="Arg">Аргумент числа</param>
            <returns>Комплексное число в экспоненциальной форме</returns>
        </member>
        <member name="M:MathService.Complex.Mod(System.Double,System.Double)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимиая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathService.Complex.Mod(System.Double,MathService.Complex@)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимиая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathService.Complex.Mod(MathService.Complex@,MathService.Complex@)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимиая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathService.Complex.Mod(MathService.Complex@,System.Double)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимиая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="F:MathService.Complex.Real">
            <summary>Действительное "комплексное" число</summary>
        </member>
        <member name="F:MathService.Complex.NaN">
            <summary>Не-число</summary>
        </member>
        <member name="F:MathService.Complex.i">
            <summary>Мнимая единица</summary>
        </member>
        <member name="M:MathService.Complex.CreateArray(System.Double[],System.Double[])">
            <summary>Создать массив комплексных чисел</summary>
            <param name="Re">Массив действительных чисел</param>
            <param name="Im">Массив мнимых чисел</param>
            <returns>Массив комплексных чисел</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="Re"/> or <paramref name="Im"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Длины массивов не совпадают</exception>
        </member>
        <member name="F:MathService.Complex._Re">
            <summary>Действительная часть</summary>
        </member>
        <member name="F:MathService.Complex._Im">
            <summary>Мнимая часть</summary>
        </member>
        <member name="P:MathService.Complex.Expression">
            <summary>Преобразование комплексного числа в выражение</summary>
        </member>
        <member name="P:MathService.Complex.Re">
            <summary>Действительная часть</summary>
        </member>
        <member name="P:MathService.Complex.Im">
            <summary>Мнимая часть</summary>
        </member>
        <member name="P:MathService.Complex.Power">
            <summary>X * X^* = Re(X)^2 + Im(X)^2</summary>
        </member>
        <member name="P:MathService.Complex.Abs">
            <summary>Модуль</summary>
        </member>
        <member name="P:MathService.Complex.Arg">
            <summary>Аргумент</summary>
        </member>
        <member name="P:MathService.Complex.ComplexConjugate">
            <summary>Комплексно сопряжённое число</summary>
        </member>
        <member name="P:MathService.Complex.Reciprocal">
            <summary>Обратное значение 1/Z</summary>
        </member>
        <member name="M:MathService.Complex.#ctor(System.Double,System.Double)">
            <summary>Комплексное число</summary>
            <param name="Re">Действительная часть</param>
            <param name="Im">Мнимая часть</param>
        </member>
        <member name="M:MathService.Complex.ToString_Exponent">
            <summary>Представление комплексного числа в текстовой экспонетциальной форме</summary>
            <returns>Текстовое экспонетциальное представление комплексного числа</returns>
        </member>
        <member name="M:MathService.Complex.ToString_Exponent_pi">
            <summary>Представление комплексного числа в текстовой экспонетциальной форме с нормировкой аргумента к значению pi</summary>
            <returns>Текстовое экспонетциальное представление комплексного числа с нормировкой аргумента к значению pi</returns>
        </member>
        <member name="M:MathService.Complex.ToString_Exponent_Deg">
            <summary>Представление комплексного числа в текстовой экспонетциальной форме с нормировкой аргумента в градусах</summary>
            <returns>Текстовое экспонетциальное представление комплексного числа с нормировкой аргумента в градусах</returns>
        </member>
        <member name="M:MathService.Complex.ToString">
            <summary>Строковый эквивалент</summary>
            <returns>Строковый эквивалент</returns>
        </member>
        <member name="M:MathService.Complex.ToString(System.String)">
            <summary>Преобразование в строковый формат</summary>
            <param name="Format">Формат преобразования</param>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathService.Complex.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathService.Complex.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathService.Complex.Clone">
            <summary>Получение клона</summary>
            <returns>Клон числа</returns>
        </member>
        <member name="M:MathService.Complex.System#ICloneable#Clone">
            <summary>Получение клона</summary>
            <returns>Клон числа</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathService.Complex.Equals(MathService.Complex)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{MathService#Complex}#Equals(MathService.Complex)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Double)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#Double}#Equals(System.Double)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Int16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#Int16}#Equals(System.Int16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.UInt16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#UInt16}#Equals(System.UInt16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Byte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#Byte}#Equals(System.Byte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.SByte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#SByte}#Equals(System.SByte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Single)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#Single}#Equals(System.Single)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Int32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#Int32}#Equals(System.Int32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.UInt32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#UInt32}#Equals(System.UInt32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.Int64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#Int64}#Equals(System.Int64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Equals(System.UInt64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.System#IEquatable{System#UInt64}#Equals(System.UInt64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathService.Complex.Rotate(System.Double)">
            <summary>Поворот вектора комплексного числа на угол</summary>
            <param name="w">Угол поворота вектора в комплексной плоскости</param>
            <returns>Комплексное число, повёрнутое на угол</returns>
        </member>
        <member name="M:MathService.Complex.Round(System.Int32)">
            <summary>Округление числа</summary>
            <param name="DigitsCount">Число разрядов</param>
            <returns>Округлённое число</returns>
        </member>
        <member name="M:MathService.Complex.Sqrt">
            <summary>Вычисление квадратного корня числа</summary>
            <returns>Квадратный корень числа</returns>
        </member>
        <member name="T:MathService.ComplexConverter">
            <summary>Конвертер комплексных чисел</summary>
        </member>
        <member name="M:MathService.ComplexConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:MathService.ComplexConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathService.ComplexConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:MathService.ComplexConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:MathService.Consts">
            <summary>Константы</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.yotta">
            <summary>10^24</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.zetta">
            <summary>10^21</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.exa">
            <summary>10^18</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.peta">
            <summary>10^15</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.tera">
            <summary>10^12</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.giga">
            <summary>10^9</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.mega">
            <summary>10^6</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.kilo">
            <summary>10^3</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.hecto">
            <summary>10^2</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.deca">
            <summary>10^1</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.none">
            <summary>10^0</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.deci">
            <summary>10^-1</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.santi">
            <summary>10^-2</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.milli">
            <summary>10^-3</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.micro">
            <summary>10^-6</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.nano">
            <summary>10^-9</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.pico">
            <summary>10^-12</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.femto">
            <summary>10^-15</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.atto">
            <summary>10^-18</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.zepto">
            <summary>10^-21</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefixExp.yocto">
            <summary>10^-24</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.yotta">
            <summary>10^24</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.zetta">
            <summary>10^21</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.exa">
            <summary>10^18</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.peta">
            <summary>10^15</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.tera">
            <summary>10^12</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.giga">
            <summary>10^9</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.mega">
            <summary>10^6</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.kilo">
            <summary>10^3</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.hecto">
            <summary>10^2</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.deca">
            <summary>10^1</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.none">
            <summary>10^0</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.deci">
            <summary>10^-1</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.santi">
            <summary>10^-2</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.milli">
            <summary>10^-3</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.micro">
            <summary>10^-6</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.nano">
            <summary>10^-9</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.pico">
            <summary>10^-12</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.femto">
            <summary>10^-15</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.atto">
            <summary>10^-18</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.zepto">
            <summary>10^-21</summary>
        </member>
        <member name="F:MathService.Consts.SIPrefix.yocto">
            <summary>10^-24</summary>
        </member>
        <member name="F:MathService.Consts.Percent">
            <summary>% = 0.01</summary>
        </member>
        <member name="F:MathService.Consts.e">
            <summary>e = 2.7182818284590452353602874713527</summary>
        </member>
        <member name="F:MathService.Consts.pi00625">
            <summary>π/16 (90°/8 = 11.25°)</summary>
        </member>
        <member name="F:MathService.Consts.pi0125">
            <summary>π/8 (90/4° = 22.5°)</summary>
        </member>
        <member name="F:MathService.Consts.pi025">
            <summary>π/4 (90°/2 = 45°)</summary>
        </member>
        <member name="F:MathService.Consts.pi05">
            <summary>π/2 (90°)</summary>
        </member>
        <member name="F:MathService.Consts.pi05neg">
            <summary>-π/2 (-90°)</summary>
        </member>
        <member name="F:MathService.Consts.pi">
            <summary>π = 3.1415926535897932384626433832795</summary>
        </member>
        <member name="F:MathService.Consts.pi_neg">
            <summary>-π = -3.1415926535897932384626433832795</summary>
        </member>
        <member name="F:MathService.Consts.pi2">
            <summary>2·π (360°)</summary>
        </member>
        <member name="F:MathService.Consts.pi2neg">
            <summary>-2·π (-360°)</summary>
        </member>
        <member name="F:MathService.Consts.pi3_2">
            <summary>3·π/</summary>
        </member>
        <member name="F:MathService.Consts.ToRad">
            <summary>π/180</summary>
        </member>
        <member name="F:MathService.Consts.ToDeg">
            <summary>180/π</summary>
        </member>
        <member name="F:MathService.Consts.pi_name">
            <summary>'π'</summary>
        </member>
        <member name="F:MathService.Consts.deg_name">
            <summary>'°'</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_e">
            <summary>√e</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_pi">
            <summary>√π</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_pi2">
            <summary>√2·π</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_2">
            <summary>√2 = 1.4142135623730950488016887242097</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_2_inv">
            <summary>1 / √2 = 0.707...</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_3">
            <summary>√3 = 1.732050807...</summary>
        </member>
        <member name="F:MathService.Consts.sqrt_5">
            <summary>√5 = 2.236067...</summary>
        </member>
        <member name="F:MathService.Consts.GoldenRatio">
            <summary>Золотое сечение = (√5 + 1)/2</summary>
        </member>
        <member name="F:MathService.Consts.GoldenRatio_Inv">
            <summary>Величина, обратная золотому сечению = (√5 - 1)/2</summary>
        </member>
        <member name="T:MathService.Consts.Geometry">
            <summary>Геометрические константы</summary>
        </member>
        <member name="F:MathService.Consts.Geometry.ToDeg">
            <summary>Константа преобразования радиан в градусы = 180/π</summary>
        </member>
        <member name="F:MathService.Consts.Geometry.ToRad">
            <summary>Константа преобразования градусов в радианы = π/180</summary>
        </member>
        <member name="F:MathService.Consts.Geometry.Pi">
            <summary>Константа π = 3.1415926535897932384626433832</summary>
        </member>
        <member name="F:MathService.Consts.SpeedOfLigth">
            <summary>Скорость света 300`000`000 м/с = 3e8 м/с</summary>
        </member>
        <member name="F:MathService.Consts.SpeedOfLightInVacuum">
            <summary>Скорость света в вакууме 299`792`458 м/с</summary>
        </member>
        <member name="F:MathService.Consts.GravitationConstant">
            <summary>Гравитационная постоянная 6.67384(80)×10^−11 m^3·кг^−1·с^−2</summary>
        </member>
        <member name="F:MathService.Consts.PlanckConstant">
            <summary>Постоянная Планка 6.626 069 57(29) ×10^−34 Жд·с</summary>
        </member>
        <member name="F:MathService.Consts.PlanckConstant_Reduced">
            <summary>Приведённая постоянная Планка 1.054 571 628(53) ×10^−34 Жд·с</summary>
        </member>
        <member name="T:MathService.Consts.ElectroDynamic">
            <summary>Электродинамические константы</summary>
        </member>
        <member name="F:MathService.Consts.ElectroDynamic.Epsilon0">
            <summary>Электрическая постоянная 1/(Mu0 · c^2) = 8,854187817620… ×10^−12 Ф·м^−1</summary>
        </member>
        <member name="F:MathService.Consts.ElectroDynamic.Mu0">
            <summary>Магнитная постоянная 4·π ×10^-7 = 1.2566370614E-6 Гн/м</summary>
        </member>
        <member name="F:MathService.Consts.ElectroDynamic.Impedance0">
            <summary>Сопротивление среды (вакуума) = √(Mu0/Epsilon0) = 376.730313461771 Ом</summary>
        </member>
        <member name="F:MathService.Consts.BigPrime_int">
            <summary>0x3ffeffff = 1073676287</summary>
        </member>
        <member name="F:MathService.Consts.BigPrime_long">
            <summary>0x3fffffefffffff = 18014398241046527</summary>
        </member>
        <member name="F:MathService.Consts.ElementaryCharge">
            <summary>Элементарный заряд e = 1,602 176 565(35)·10^−19 Кл</summary>
        </member>
        <member name="F:MathService.Consts.BoltzmanConstant">
            <summary>Постоянная Больцмана k = 1,380 6488(13)·10^−23 Дж/К</summary>
        </member>
        <member name="F:MathService.Consts.AvogadroConstant">
            <summary>Число Авогадро Na = 6,022 141 29(27)·10^23 1/моль</summary>
        </member>
        <member name="F:MathService.Consts.FaradayConstant">
            <summary>Постоянная Фарадея F = e * Na = 96485,33(83) Кл/моль</summary>
        </member>
        <member name="M:MathService.IFactory`1.Create">
            <summary>Создать новый объект</summary>
            <returns>Новый объект типа <typeparamref name="T"/></returns>
        </member>
        <member name="T:MathService.Factory`1">
            <summary>Генератор объектов типа <typeparamref name="T"/></summary>
            <typeparam name="T">Тип генерируемых объектов</typeparam>
        </member>
        <member name="E:MathService.Factory`1.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
            <summary>Событие возникает при генерации новой строки</summary>
        </member>
        <member name="F:MathService.Factory`1._FactoryMethod">
            <summary>Метод генерации объектов</summary>
        </member>
        <member name="P:MathService.Factory`1.Last">
            <summary>Последний сгенерированный объект</summary>
        </member>
        <member name="P:MathService.Factory`1.FactoryMethod">
            <summary>Метод генерации объектов типа <typeparamref name="T"/></summary>
        </member>
        <member name="M:MathService.Factory`1.#ctor(System.Func{`0})">
            <summary>Новый генератор объектов типа <typeparamref name="T"/></summary>
            <param name="CreateMethod">Метод генерации объектов типа <typeparamref name="T"/></param>
        </member>
        <member name="M:MathService.Factory`1.Create">
            <summary>Создать новый объект</summary>
            <returns>Новый объект типа <typeparamref name="T"/></returns>
        </member>
        <member name="F:MathService.Forms.ProgressForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:MathService.Forms.ProgressForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:MathService.Forms.ProgressForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:MathService.ICountable">
            <summary>Объект позволяет определять количество вложенных объектов</summary>
        </member>
        <member name="P:MathService.ICountable.Count">
            <summary>Число элементов</summary>
        </member>
        <member name="P:MathService.ContractClassICountable.Count">
            <summary>Число элементов</summary>
        </member>
        <member name="M:MathService.LambdaEnumerable`1.GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции.</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathService.LambdaEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.LambdaComparer`1">
            <summary>ОБъект, представляющий метод сравнения двух объектов типа <typeparamref name="T"/>, задаваемый lambda-выражением</summary>
            <typeparam name="T">Тип сравниваемых объектов</typeparam>
        </member>
        <member name="M:MathService.LambdaComparer`1.Compare(`0,`0)">
            <summary>Сравнивает два объекта и возвращает значение, показывающее, что один объект меньше или больше другого или равен ему</summary>
            <param name="x">Первый сравниваемый объект.</param>
            <param name="y">Второй сравниваемый объект.</param>
            <returns>
            Значение Условие Меньше нуля<paramref name="x"/> меньше, чем <paramref name="y"/>.Нуль<paramref name="x"/> равно <paramref name="y"/>.Больше нуля<paramref name="x"/> больше, чем <paramref name="y"/>.
            </returns>
        </member>
        <member name="M:MathService.LambdaComparer`1.System#Collections#IComparer#Compare(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:MathService.LambdaProperty`1">
            <summary>Класс объектов-свойств, определяемых методами установки и чтения значения</summary>
        </member>
        <member name="F:MathService.LambdaProperty`1._GetMethod">
            <summary>Метод получения значения свойства</summary>
        </member>
        <member name="F:MathService.LambdaProperty`1._SetMethod">
            <summary>Метод установки значения свойства</summary>
        </member>
        <member name="P:MathService.LambdaProperty`1.GetMethod">
            <summary>Метод получения значения свойства</summary>
        </member>
        <member name="P:MathService.LambdaProperty`1.SetMethod">
            <summary>Метод установки значения свойства</summary>
        </member>
        <member name="P:MathService.LambdaProperty`1.CanRead">
            <summary>Признак возможности чтения значения свойства (если задан метод чтения)</summary>
        </member>
        <member name="P:MathService.LambdaProperty`1.CanWrite">
            <summary>Признак возможности устанавливать значение свойства (если задан метод записи)</summary>
        </member>
        <member name="P:MathService.LambdaProperty`1.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="M:MathService.LambdaProperty`1.#ctor(System.Func{`0},System.Action{`0})">
            <summary>Новое лямда свойство</summary>
            <param name="GetMethod">Метод чтения значения</param>
            <param name="SetMethod">Метод записи значения</param>
        </member>
        <member name="M:MathService.LambdaProperty`1.Equals(MathService.LambdaProperty{`0})">
            <summary>Указывает, равен ли текущий объект другому объекту того же типа.</summary>
            <returns>true, если текущий объект равен параметру <paramref name="other"/>, в противном случае — false.</returns>
            <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        </member>
        <member name="M:MathService.LambdaProperty`1.GetHashCode">
            <summary>Играет роль хэш-функции для определенного типа. </summary>
            <returns>Хэш-код для текущего объекта <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.LambdaToString">
            <summary>Форматтер строки с помощью лямда-выражения</summary>
        </member>
        <member name="M:MathService.LambdaToString.#ctor(System.Func{System.String})">
            <summary>Новый ламбда-форматтер</summary>
            <param name="CreateMethod">Метод генерации строки</param>
        </member>
        <member name="T:MathService.ObjectWacher`1">
            <summary>Наблюдатель за объектом</summary>
            <typeparam name="T">Тип наблюдаемого объекта</typeparam>
        </member>
        <member name="F:MathService.ObjectWacher`1._Object">
            <summary>Наблюдаемый объект</summary>
        </member>
        <member name="F:MathService.ObjectWacher`1._WachMethod">
            <summary>Метод наблюдения</summary>
        </member>
        <member name="P:MathService.ObjectWacher`1.WachMethod">
            <summary>Метод наблюдения</summary>
        </member>
        <member name="P:MathService.ObjectWacher`1.Object">
            <summary>Наблюдаемый объект</summary>
        </member>
        <member name="M:MathService.ObjectWacher`1.#ctor(`0,System.Action{`0},System.Int32)">
            <summary>Инициализация наблюдателя</summary>
            <param name="obj">Наблюдаемый объект</param>
            <param name="WachMethod">Метод наблюдения</param>
            <param name="Timeout">Таймаут потока наблюдения</param>
        </member>
        <member name="M:MathService.ObjectWacher`1.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="T:MathService.Polynom">
            <summary>
            Полином степени N-1
             a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)
            где N - число элементов массива коэффициентов
            Нулевой элемент массива при нулевой степени члена полинома 
            </summary>
        </member>
        <member name="M:MathService.Polynom.Array.GetCoefficients(System.Double[])">
            <summary>Преобразовать массив корней полинома в коэффициенты прои степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при степенях</returns>
        </member>
        <member name="M:MathService.Polynom.Array.GetCoefficients(MathService.Complex[])">
            <summary>Преобразовать массив корней полинома в коэффициенты прои степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при степенях</returns>
        </member>
        <member name="T:MathService.Polynom.PolynomDevisionResult">
            <summary>Результат деления полиномов</summary>
        </member>
        <member name="F:MathService.Polynom.PolynomDevisionResult.Result">
            <summary>Частное полиномов</summary>
        </member>
        <member name="F:MathService.Polynom.PolynomDevisionResult.Remainder">
            <summary>Остаток деления полиновов</summary>
        </member>
        <member name="M:MathService.Polynom.PolynomDevisionResult.#ctor(MathService.Polynom,MathService.Polynom,MathService.Polynom)">
            <summary>Инициализация результата деления полиномов</summary>
            <param name="Divisor"></param>
            <param name="Result">Частоное</param>
            <param name="Remainder">Остаток от деления</param>
        </member>
        <member name="M:MathService.Polynom.PolynomDevisionResult.op_Implicit(MathService.Polynom.PolynomDevisionResult)~MathService.Polynom">
            <summary>Оператор неявного преобразования результата деления полиномов в полином результата</summary>
            <param name="Result">Результат деления полиномов</param>
            <returns>Частное</returns>
        </member>
        <member name="M:MathService.Polynom.op_Implicit(MathService.Polynom)~System.Func{System.Double,System.Double}">
            <summary>Явное приведение типов полинома к делегату функции преобразования double->double</summary>
            <param name="P">Полином</param>
            <returns>Делегат функции преобразования</returns>
        </member>
        <member name="M:MathService.Polynom.op_Addition(MathService.Polynom,MathService.Polynom)">
            <summary>Оператор сложения двух полиномов</summary>
            <param name="P">Первое слагаемое</param>
            <param name="Q">Второе слагаемое</param>
            <returns>Сумма полиномов</returns>
        </member>
        <member name="M:MathService.Polynom.op_UnaryNegation(MathService.Polynom)">
            <summary>
            Оператор отрицания полинома (изменяет знак всех коэффициентов на обратной). Эквивалентно домножению полинома на -1
            </summary>
            <param name="P">Отрицаемый полином</param>
            <returns>Полином Q = -P</returns>
        </member>
        <member name="M:MathService.Polynom.op_Subtraction(MathService.Polynom,MathService.Polynom)">
            <summary>Оператор вычетания полинома Q из полинома P</summary>
            <param name="P">Уменьшаемое</param>
            <param name="Q">Вычитаемое</param>
            <returns>Разность</returns>
        </member>
        <member name="M:MathService.Polynom.op_Division(MathService.Polynom,MathService.Polynom)">
            <summary>Оператор деления двух полиномов</summary>
            <param name="p">Полином делимого</param>
            <param name="q">Полином делителя</param>
            <returns>Результат деления полиномов, включающий частное и остаток от деления</returns>
        </member>
        <member name="M:MathService.Polynom.op_Explicit(MathService.Polynom)~System.Double[]">
            <summary>Оператор неявного преведения типа полинома в массив вещественных значений коэффициентов</summary>
            <param name="p">Полином</param>
            <returns>Массив значений коэффициентов</returns>
        </member>
        <member name="M:MathService.Polynom.FromRoots(System.Double[])">
            <summary>Получить полином из корней полинома</summary>
            <param name="Root">Корни полинома</param>
            <returns>Полином с указанными корнями</returns>
        </member>
        <member name="F:MathService.Polynom._a">
            <summary>Коэффициенты при степенях</summary>
            <remarks>a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)</remarks>
        </member>
        <member name="P:MathService.Polynom.Coefficients">
            <summary>
            Коэффициенты при степенях
              a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)
            </summary>
        </member>
        <member name="P:MathService.Polynom.Power">
            <summary>Степень полинома = число коэффициентов - 1</summary>
        </member>
        <member name="P:MathService.Polynom.Length">
            <summary>Длина полинома - число коэффициентов</summary>
        </member>
        <member name="P:MathService.Polynom.Item(System.Int32)">
            <summary>
             Коэффициент при степени <paramref name="n"/>, где <paramref name="n"/> принадлежит [0; <see cref="P:MathService.Polynom.Power"/>]
             <see cref="P:MathService.Polynom.Power"/> = <see cref="P:MathService.Polynom.Length"/> - 1
             </summary>
            <param name="n">Степень a[0]+a[1]*x+a[2]*x^2+...<b>+a[<paramref name="n"/>]*x^<paramref name="n"/>+</b>...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)</param>
        </member>
        <member name="M:MathService.Polynom.#ctor(System.Double[])">
            <summary>Полином степени N, нулевой элемент массива a[0] при младшей степени x^0</summary>
            <param name="a">a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)</param>
        </member>
        <member name="M:MathService.Polynom.Value(System.Double)">
            <summary>Получить значение полинома</summary>
            <param name="x">Переменная</param>
            <returns>Значение полинома в точке x</returns>
        </member>
        <member name="P:MathService.ProcessExplorer.FilterToExcludeProcesses">
            <summary>Метод фильтрации процессов, показывающий какие процессы не должны попадать в выборку</summary>
        </member>
        <member name="T:MathService.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.ItemNotNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
            <example><code>
            public void Foo([ItemNotNull]List&lt;string&gt; books)
            {
              foreach (var book in books) {
                if (book != null) // Warning: Expression is always true
                 Console.WriteLine(book.ToUpper());
              }
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.ItemCanBeNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
            <example><code>
            public void Foo([ItemCanBeNull]List&lt;string&gt; books)
            {
              foreach (var book in books)
              {
                // Warning: Possible 'System.NullReferenceException'
                Console.WriteLine(book.ToUpper());
              }
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:MathService.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:MathService.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>
            </summary>
            <example><code>
            public void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> interface
             and this method is used to notify that some property value changed
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               private string _name;
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:MathService.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null, and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:MathService.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            public class Foo {
              private string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            class UsesNoEquality {
              public void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute { }
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly
            (e.g. via reflection, in external library), so this symbol
            will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="T:MathService.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper
            to not mark symbols marked with such attributes as unused
            (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:MathService.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used</summary>
        </member>
        <member name="F:MathService.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member</summary>
        </member>
        <member name="F:MathService.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:MathService.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type</summary>
        </member>
        <member name="T:MathService.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly
            when marked with <see cref="T:MathService.Annotations.MeansImplicitUseAttribute"/>
            or <see cref="T:MathService.Annotations.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:MathService.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used</summary>
        </member>
        <member name="F:MathService.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used</summary>
        </member>
        <member name="T:MathService.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used
            </summary>
        </member>
        <member name="T:MathService.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled
            when the invoked method is on stack. If the parameter is a delegate,
            indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated
            while the method is executed
            </summary>
        </member>
        <member name="T:MathService.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder
            within a web project. Path can be relative or absolute,
            starting from web root (~)
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC controller. If applied to a method,
            the MVC controller name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, Object)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC partial view. If applied to a method,
            the MVC partial view name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcSupressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling all inspections
            for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>
            </summary>
        </member>
        <member name="T:MathService.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:MathService.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>
            </summary>
        </member>
        <member name="P:MathService.Settings.LocalSettingsFileProvider`1.SettingsDictionary">
            <summary>
            In memory storage of the settings values
            </summary>
        </member>
        <member name="P:MathService.Settings.LocalSettingsFileProvider`1.UserConfigPath">
            <summary>
            The setting key this is returning must set before the settings are used.
            e.g. <c>Properties.Settings.Default.SettingsKey = @"C:\temp\user.config";</c>
            </summary>
        </member>
        <member name="M:MathService.Settings.LocalSettingsFileProvider`1.GetPropertyValues(System.Configuration.SettingsContext,System.Configuration.SettingsPropertyCollection)">
            <summary>
            Must override this, this is the bit that matches up the designer properties to the dictionary values
            </summary>
            <param name="context"></param>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:MathService.Settings.LocalSettingsFileProvider`1.SetPropertyValues(System.Configuration.SettingsContext,System.Configuration.SettingsPropertyValueCollection)">
            <summary>
            Must override this, this is the bit that does the saving to file.  Called when Settings.Save() is called
            </summary>
            <param name="context"></param>
            <param name="collection"></param>
        </member>
        <member name="M:MathService.Settings.LocalSettingsFileProvider`1.LoadValuesFromFile">
            <summary>
            Loads the values of the file into memory.
            </summary>
        </member>
        <member name="M:MathService.Settings.LocalSettingsFileProvider`1.CreateEmptyConfig">
            <summary>
            Creates an empty user.config file...looks like the one MS creates.  
            This could be overkill a simple key/value pairing would probably do.
            </summary>
        </member>
        <member name="M:MathService.Settings.LocalSettingsFileProvider`1.SaveValuesToFile">
            <summary>
            Saves the in memory dictionary to the user config file
            </summary>
        </member>
        <member name="T:MathService.Quaternion">
            <summary>Кватернион</summary>
        </member>
        <member name="M:MathService.Quaternion.#ctor(System.Double)">
            <summary>
            Кватерион a + b*i + c*j + d*k
            </summary>
            <param name="a"></param>
        </member>
        <member name="M:MathService.Quaternion.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Кватерион a + b*i + c*j + d*k
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <param name="d"></param>
        </member>
        <member name="M:MathService.Quaternion.op_Multiply(MathService.Quaternion@,MathService.Quaternion@)">
            <summary>
            </summary>
            <remarks>
            (a1 + b1*i + c1*j + d1*k) * (a2 + b2*i + c2*j + d2*k) =
            
            a1*a2 + a1*b2*i + a1*c2*j + a1*d2*k +
            b1*i*a2 + b1*i*b2*i + b1*i*c2*j + b1*i*d2*k +  
            c1*j*a2 + c1*j*b2*i + c1*j*c2*j + c1*j*d2*k +    
            d1*k*a2 + d1*k*b2*i + d1*k*c2*j + d1*k*d2*k =
            
            a1*a2   + a1*b2*i + a1*c2*j + a1*d2*k +
            b1*a2*i - b1*b2   + b1*c2*k - b1*d2*j +   
            c1*a2*j - c1*b2*k - c1*c2   + c1*d2*i + 
            d1*a2*k + d1*b2*j - d1*c2*i - d1*d2   =
            
             a1*a2 - b1*b2 - c1*c2 - d1*d2 +       
            (a1*b2 + b1*a2 + c1*d2 - d1*c2)*i +    
            (a1*c2 + c1*a2 - b1*d2 + d1*b2)*j +
            (a1*d2 + d1*a2 + b1*c2 - c1*b2)*k =
                                    
             ┌a1 -b1 -c1 -d1┐   ┌a2┐
             │b1  a1 -d1  c1│ x │b2│ = Q1 x q2
             │c1  d1  a1 -b1│   │c2│
             └d1 -c1  b1  a1┘   └d2┘
            
             a1*a2 - b1*b2 - c1*c2 - d1*d2 +       
            (b1*a2 + a1*b2 - d1*c2 + c1*d2)*i +    
            (c1*a2 + d1*b2 + a1*c2 - b1*d2)*j +
            (d1*a2 - c1*b2 + b1*c2 + a1*d2)*k =
            
             ┌a2 -b2 -c2 -d2┐   ┌a1┐
             │b2  a2  d2 -c2│ x │b1│
             │c2 -d2  a2  b2│   │c1│
             └d2  c2 -b2  a2┘   └d1┘
                   
             a1*a2 - b1*b2 - c1*c2 - d1*d2 +       
            (a1*b2 + b1*a2 + c1*d2 - d1*c2)*i +    
            (a1*c2 - b1*d2 + c1*a2 + d1*b2)*j +
            (a1*d2 + b1*c2 - c1*b2 + d1*a2)*k
            
            x| 1  i  j  k
            -+-----------
            1| 1  i  j  k
            i| i -1  k -j
            j| j -k -1  i
            k| k  j -i -1
            
            </remarks>
            <param name="X"></param>
            <param name="Y"></param>
            <returns></returns>
        </member>
        <member name="T:MathService.RegExpConsts">
            <summary>
            
            </summary>
            <remarks>http://html5pattern.com/</remarks>
        </member>
        <member name="F:MathService.RegExpConsts.UserName">
            <summary>2-20 символов, которыми могут быть буквы и цифры, первый символ обязательно буква</summary>
        </member>
        <member name="F:MathService.RegExpConsts.PassworsSimple">
            <summary>Строчные и прописные латинские буквы, цифры</summary>
        </member>
        <member name="F:MathService.RegExpConsts.PassworsAdvanced">
            <summary>Строчные и прописные латинские буквы, цифры, спецсимволы. Минимум 8 символов</summary>
        </member>
        <member name="F:MathService.RegExpConsts.DateStringYYYYMMDD">
            <summary>Дата в формате YYYY-MM-DD</summary>
        </member>
        <member name="F:MathService.RegExpConsts.DateStringYYYYMMDDAdvanced">
            <summary>Более строгая проверка даты в формате YYYY-MM-DD</summary>
        </member>
        <member name="T:MathService.SealedEvent">
            <summary>Изолированное событие</summary>
        </member>
        <member name="E:MathService.SealedEvent.Event">
            <summary>Событие</summary>
        </member>
        <member name="M:MathService.SealedEvent.Invoke(System.Object,System.EventArgs)">
            <summary>Вызвать событие</summary>
            <param name="Sender">Источник события</param><param name="args">Аргументы события</param>
        </member>
        <member name="M:MathService.SealedEvent.BeginInvoke(System.Object,System.EventArgs,System.AsyncCallback,System.Object)">
            <summary>Вызвать событие асинхронно</summary>
            <param name="Sender">Источник события</param><param name="args">Аргументы события</param>
            <param name="CallBack">Метод обработки завершения вызова</param><param name="State">Объект-состояние</param>
        </member>
        <member name="M:MathService.SealedEvent.InvokeFast(System.Object,System.EventArgs)">
            <summary>Быстрый вызов события</summary>
            <param name="Sender">Источник события</param><param name="args">Аргумент события</param>
        </member>
        <member name="T:MathService.SealedEvent`1">
            <summary>Изолированное событие</summary>
            <typeparam name="TEventArgs">Тип параметра аргумента</typeparam>
        </member>
        <member name="E:MathService.SealedEvent`1.Event">
            <summary>Событие</summary>
        </member>
        <member name="M:MathService.SealedEvent`1.Invoke(System.Object,`0)">
            <summary>Вызвать событие</summary>
            <param name="Sender">Источник события</param><param name="args">Аргументы события</param>
        </member>
        <member name="M:MathService.SealedEvent`1.BeginInvoke(System.Object,`0,System.AsyncCallback,System.Object)">
            <summary>Вызвать событие асинхронно</summary>
            <param name="Sender">Источник события</param><param name="args">Аргументы события</param>
            <param name="CallBack">Метод обработки завершения вызова</param><param name="State">Объект-состояние</param>
        </member>
        <member name="M:MathService.SealedEvent`1.InvokeFast(System.Object,`0)">
            <summary>Быстрый вызов события</summary>
            <param name="Sender">Источник события</param><param name="args">Аргумент события</param>
        </member>
        <member name="T:MathService.SpecialFunctions.Bessel">
            <summary>Класс функций Бесселя</summary>
        </member>
        <member name="M:MathService.SpecialFunctions.Bessel.J0(System.Double)">
            <summary>Функция Бесселя 0 порядка</summary>
            <param name="x">Аргумент</param>
            <returns>Значение функции Бесселя нулевого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.Bessel.J1(System.Double)">
            <summary>Функция Бесселя 1 порядка</summary>
            <param name="x">Аргумент функции</param>
            <returns>Значение функции Бесселя первого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.Bessel.Jn(System.Int32,System.Double)">
            <summary>Функция Бесселя n порядка</summary>
            <param name="n">Порядок функции Бесселя</param>
            <param name="x">Аргумент Функции Бесселя</param>
            <returns>Значение функции Бесселя n порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.Bessel.Y0(System.Double)">
            <summary>Функция Бесселя второго типа, нулевого порядка</summary>
            <param name="x">Аргумент функции Бесселя второго типа, нулевого порядка</param>
            <returns>Значение функции Бесселя второго типа, нулевого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.Bessel.Y1(System.Double)">
            <summary>Функция Бесселя второго типа, первого порядка</summary>
            <param name="x">Аргумент функции Бесселя второго типа, первого порядка</param>
            <returns>Значение функции Бесселя второго типа, первого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.Bessel.Yn(System.Int32,System.Double)">
            <summary>Функция Бесселя второго типа, n порядка</summary>
            <param name="n">Порядок функции Бесселя второго типа</param>
            <param name="x">Аргумент функции Бесселя второго типа, n порядка</param>
            <returns>Значение функции Бесселя второго типа, n порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.Bessel.I0(System.Double)">
            <summary>Модифицированная функция Бесселя нулевого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя нулевого порядка</param>
            <returns>Значение модифицированной функции Бесселя нулевого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.Bessel.I1(System.Double)">
            <summary>Модифицированная функция Бесселя первого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя первого порядка</param>
            <returns>Значение модифицированной функции Бесселя первого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.Bessel.K0(System.Double)">
            <summary>Модифицированная функция Бесселя второго типа, нулевого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя второго типа, нулевого порядка</param>
            <returns>Значение модифицированной функции Бесселя второго типа, нулевого порядка</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.Bessel.K1(System.Double)">
            <summary>Модифицированная функция Бесселя второго типа, первого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя второго типа, первого порядка</param>
            <returns>Значение модифицированной функции Бесселя второго типа, первого порядка</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">x меньше 0</exception>
        </member>
        <member name="M:MathService.SpecialFunctions.Bessel.Kn(System.Int32,System.Double)">
            <summary>Модифицированная функция Бесселя второго типа, n порядка </summary>
            <param name="n">Порядок модифицированной функции Бесселя второго типа</param>
            <param name="x">Аргумент модифицированной функции Бесселя второго типа, n порядка</param>
            <returns>Значение модифицированной функции Бесселя второго типа, n порядка</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">при x меньше, либо = 0</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">|n| больше 31</exception>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="T:MathService.SpecialFunctions.Distribution.Normal">
            <summary>Нормальное распределение</summary>
        </member>
        <member name="M:MathService.SpecialFunctions.Distribution.Normal.ErrorFunction(System.Double)">
            <summary>Интеграл от exp{-t^2} от нуля до x / .5 sqrt(pi)</summary>
            <param name="x">Аргумент функции нормального распределения</param>
            <returns>Значение нормального распределения</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.EllipticJacobi.FullEllipticIntegral(System.Double)">
            <summary>Полный эллиптический интеграл</summary>
            <param name="k">Параметр интегрирования от 0 до 1</param>
            <returns></returns>
        </member>
        <member name="T:MathService.SpecialFunctions.Gamma">
            <summary>Гамма-функция</summary>
        </member>
        <member name="F:MathService.SpecialFunctions.pi_2">
            <summary>Pi/2</summary>
        </member>
        <member name="F:MathService.SpecialFunctions.Eps">
            <summary>Точность алгоритмов 5e-16</summary>
        </member>
        <member name="F:MathService.SpecialFunctions.c_FibonachiPhi">
            <summary>(1+sqrt(5))/2</summary>
        </member>
        <member name="F:MathService.SpecialFunctions.c_InvSqrt5">
            <summary>1/sqrt(5)</summary>
        </member>
        <member name="M:MathService.SpecialFunctions.BinomialCoefficient(System.Int32,System.Int32)">
            <summary>Биномиальный коэффициент</summary>
            <param name="n">Показатель степени бинома</param>
            <param name="k">Индекс коэффициента</param>
            <returns>Биномиальный коэффициент (n, k)</returns>
        </member>
        <member name="M:MathService.SpecialFunctions.KroneckerDelta(System.Int32,System.Int32)">
            <summary>Символ Кронекера δ(i,j) = 1 - если i = j, и = 0 - если i ≠ j</summary>
            <param name="i">Индекс</param><param name="j">Индекс</param>
            <returns>1 - если i = j, и = 0 - если i ≠ j</returns>
        </member>
        <member name="F:MathService.Statistic.RandomNumbers.PolyformRandomGenertor.c_Normal_A">
            <summary>area under rectangle</summary>
        </member>
        <member name="F:MathService.Statistic.RandomNumbers.PolyformRandomGenertor.A">
            <summary>area under rectangle</summary>
        </member>
        <member name="M:MathService.Statistic.RandomNumbers.PolyformRandomGenertor.Cauchy(System.Double,System.Double)">
            <summary>Случайная величина с распределением Коши</summary>
            <param name="x0"></param>
            <param name="gamma"></param>
            <returns></returns>
        </member>
        <member name="T:MathService.Statistic.RandomNumbers.RandomGenerator">
            <summary>Генератор случайных чисел</summary>
        </member>
        <member name="F:MathService.Statistic.RandomNumbers.RandomGenerator.SystemRandomGenerator">
            <summary>Датчик случайных чисел с равномерным распределением</summary>
        </member>
        <member name="F:MathService.Statistic.RandomNumbers.RandomGenerator._sigma">
            <summary>Дисперсия</summary>
        </member>
        <member name="F:MathService.Statistic.RandomNumbers.RandomGenerator._mu">
            <summary>Математическое ожидание</summary>
        </member>
        <member name="P:MathService.Statistic.RandomNumbers.RandomGenerator.sigma">
            <summary>Дисперсия</summary>
        </member>
        <member name="P:MathService.Statistic.RandomNumbers.RandomGenerator.mu">
            <summary>Математическое ожидание</summary>
        </member>
        <member name="P:MathService.Statistic.RandomNumbers.RandomGenerator.Value">
            <summary>Случайное значение</summary>
        </member>
        <member name="M:MathService.Statistic.RandomNumbers.RandomGenerator.GetValue">
            <summary>Новое случайное число</summary><returns>Случайное число</returns>
        </member>
        <member name="T:MathService.Statistic.RandomNumbers.UniformRandomGenerator">
            <summary>Генератор случайных чисел с равномерным распределением</summary>
        </member>
        <member name="T:MathService.Statistic.Histogram">
            <summary>Гистограмма</summary>
        </member>
        <member name="T:MathService.Tasks.IActionTask">
            <summary>Задача для выполнеия</summary>
        </member>
        <member name="E:MathService.Tasks.IActionTask.Started">
            <summary>Событие начала выполнеия задачи</summary>
        </member>
        <member name="E:MathService.Tasks.IActionTask.Complited">
            <summary>Событие завершения выполнения задачи</summary>
        </member>
        <member name="E:MathService.Tasks.IActionTask.Error">
            <summary>Событие возникновения ошибки выполнения задачи</summary>
            <remarks>При отсутствии обраотчиков ошибка может проходить вверх по стеку</remarks>
        </member>
        <member name="P:MathService.Tasks.IActionTask.StartTime">
            <summary>Время начала выполнения задачи</summary>
        </member>
        <member name="P:MathService.Tasks.IActionTask.CompliteTime">
            <summary>Время завершения выполнения задачи</summary>
        </member>
        <member name="M:MathService.Tasks.IActionTask.Execute">
            <summary>Запуск выполнения задачи</summary>
            <remarks>Должен:
            - устанавливать <see cref="P:MathService.Tasks.IActionTask.StartTime"/>
            - запускать выполнение задачи
            - параллельно генерировать событие <see cref="E:MathService.Tasks.IActionTask.Started"/>
            - ожидать завершения выполнения задачи
            -- по завершении устанавливать <see cref="P:MathService.Tasks.IActionTask.CompliteTime"/>
            -- Синхронно генерировать событие <see cref="E:MathService.Tasks.IActionTask.Complited"/>
            - Отслеживать появление исключительных ситуаций в теле задчи
            -- При исключении генерировать событие <see cref="E:MathService.Tasks.IActionTask.Error"/> 
            --- При отсутствии обработчиков события считать исключение не обработанным
            </remarks>
        </member>
        <member name="T:MathService.Tasks.ActionTask">
            <inheritdoc />
        </member>
        <member name="E:MathService.Tasks.ActionTask.Started">
            <inheritdoc />
        </member>
        <member name="E:MathService.Tasks.ActionTask.Complited">
            <inheritdoc />
        </member>
        <member name="E:MathService.Tasks.ActionTask.Error">
            <inheritdoc />
        </member>
        <member name="F:MathService.Tasks.ActionTask._Action">
            <summary>Выполняемое действие</summary>
        </member>
        <member name="P:MathService.Tasks.ActionTask.StartTime">
            <inheritdoc />
        </member>
        <member name="P:MathService.Tasks.ActionTask.CompliteTime">
            <inheritdoc />
        </member>
        <member name="M:MathService.Tasks.ActionTask.Execute">
            <inheritdoc />
        </member>
        <member name="T:MathService.Tasks.Scheduler.QueuedTaskScheduler">
            <summary>
            Provides a TaskScheduler that provides control over priorities, fairness, and the underlying threads utilized.
            </summary>
        </member>
        <member name="T:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerDebugView">
            <summary>Debug view for the QueuedTaskScheduler.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerDebugView._Scheduler">
            <summary>The scheduler.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerDebugView.#ctor(MathService.Tasks.Scheduler.QueuedTaskScheduler)">
            <summary>Initializes the debug view.</summary>
            <param name="Scheduler">The scheduler.</param>
        </member>
        <member name="P:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerDebugView.ScheduledTasks">
            <summary>Gets all of the Tasks queued to the scheduler directly.</summary>
        </member>
        <member name="P:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerDebugView.Queues">
            <summary>Gets the prioritized and fair queues.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler._QueueGroups">
            <summary>
            A sorted list of round-robin queue lists.  Tasks with the smallest priority value
            are preferred.  Priority groups are round-robin'd through in order of priority.
            </summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler._DisposeCancellation">
            <summary>Cancellation token used for disposal.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler._ConcurrencyLevel">
            <summary>
            The maximum allowed concurrency level of this scheduler.  If custom threads are
            used, this represents the number of created threads.
            </summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler.__TaskProcessingThread">
            <summary>Whether we're processing tasks on the current thread.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler._TargetScheduler">
            <summary>The scheduler onto which actual work is scheduled.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler._NonthreadsafeTaskQueue">
            <summary>The queue of tasks to process when using an underlying target scheduler.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler._DelegatesQueuedOrRunning">
            <summary>The number of Tasks that have been queued or that are running whiel using an underlying scheduler.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler._BlockingTaskQueue">
            <summary>The collection of tasks to be executed on our custom threads.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.#ctor">
            <summary>Initializes the scheduler.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.#ctor(System.Threading.Tasks.TaskScheduler)">
            <summary>Initializes the scheduler.</summary>
            <param name="TargetScheduler">The target underlying scheduler onto which this sceduler's work is queued.</param>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.#ctor(System.Threading.Tasks.TaskScheduler,System.Int32)">
            <summary>Initializes the scheduler.</summary>
            <param name="TargetScheduler">The target underlying scheduler onto which this sceduler's work is queued.</param>
            <param name="MaxConcurrencyLevel">The maximum degree of concurrency allowed for this scheduler's work.</param>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.#ctor(System.Int32)">
            <summary>Initializes the scheduler.</summary>
            <param name="ThreadCount">The number of threads to create and use for processing work items.</param>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.#ctor(System.Int32,System.String,System.Boolean,System.Threading.ThreadPriority,System.Threading.ApartmentState,System.Int32,System.Action,System.Action)">
            <summary>Initializes the scheduler.</summary>
            <param name="ThreadCount">The number of threads to create and use for processing work items.</param>
            <param name="ThreadName">The name to use for each of the created threads.</param>
            <param name="UseForegroundThreads">A Boolean value that indicates whether to use foreground threads instead of background.</param>
            <param name="ThreadPriority">The priority to assign to each thread.</param>
            <param name="ThreadApartmentState">The apartment state to use for each thread.</param>
            <param name="ThreadMaxStackSize">The stack size to use for each thread.</param>
            <param name="ThreadInit">An initialization routine to run on each thread.</param>
            <param name="ThreadFinally">A finalization routine to run on each thread.</param>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.ThreadBasedDispatchLoop(System.Action,System.Action)">
            <summary>The dispatch loop run by all threads in this scheduler.</summary>
            <param name="ThreadInit">An initialization routine to run when the thread begins.</param>
            <param name="ThreadFinally">A finalization routine to run before the thread ends.</param>
        </member>
        <member name="P:MathService.Tasks.Scheduler.QueuedTaskScheduler.DebugQueueCount">
            <summary>Gets the number of queues currently activated.</summary>
        </member>
        <member name="P:MathService.Tasks.Scheduler.QueuedTaskScheduler.DebugTaskCount">
            <summary>Gets the number of tasks currently scheduled.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.FindNextTask_NeedsLock(System.Threading.Tasks.Task@,MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue@)">
            <summary>Find the next task that should be executed, based on priorities and fairness and the like.</summary>
            <param name="TargetTask">The found task, or null if none was found.</param>
            <param name="QueueForTargetTask">
            The scheduler associated with the found task.  Due to security checks inside of TPL,  
            this scheduler needs to be used to execute that task.
            </param>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler.</summary>
            <param name="task">The task to be queued.</param>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.ProcessPrioritizedAndBatchedTasks">
            <summary>
            Process tasks one at a time in the best order.  
            This should be run in a Task generated by QueueTask.
            It's been separated out into its own method to show up better in Parallel Tasks.
            </summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.NotifyNewWorkItem">
            <summary>Notifies the pool that there's a new item to be executed in one of the round-robin queues.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Tries to execute a task synchronously on the current thread.</summary>
            <param name="task">The task to execute.</param>
            <param name="TaskWasPreviouslyQueued">Whether the task was previously queued.</param>
            <returns>true if the task was executed; otherwise, false.</returns>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.GetScheduledTasks">
            <summary>Gets the tasks scheduled to this scheduler.</summary>
            <returns>An enumerable of all tasks queued to this scheduler.</returns>
            <remarks>This does not include the tasks on sub-schedulers.  Those will be retrieved by the debugger separately.</remarks>
        </member>
        <member name="P:MathService.Tasks.Scheduler.QueuedTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level to use when processing tasks.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.Dispose">
            <summary>Initiates shutdown of the scheduler.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.ActivateNewQueue">
            <summary>Creates and activates a new scheduling queue for this scheduler.</summary>
            <returns>The newly created and activated queue at priority 0.</returns>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.ActivateNewQueue(System.Int32)">
            <summary>Creates and activates a new scheduling queue for this scheduler.</summary>
            <param name="priority">The priority level for the new queue.</param>
            <returns>The newly created and activated queue at the specified priority.</returns>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.RemoveQueue_NeedsLock(MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue)">
            <summary>Removes a scheduler from the group.</summary>
            <param name="queue">The scheduler to be removed.</param>
        </member>
        <member name="T:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueueGroup">
            <summary>A group of queues a the same priority level.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueueGroup.NextQueueIndex">
            <summary>The starting index for the next round-robin traversal.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueueGroup.CreateSearchOrder">
            <summary>Creates a search order through this group.</summary>
            <returns>An enumerable of indices for this group.</returns>
        </member>
        <member name="T:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue">
            <summary>Provides a scheduling queue associatd with a QueuedTaskScheduler.</summary>
        </member>
        <member name="T:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView">
            <summary>A debug view for the queue.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView._Queue">
            <summary>The queue.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.#ctor(MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue)">
            <summary>Initializes the debug view.</summary>
            <param name="queue">The queue to be debugged.</param>
        </member>
        <member name="P:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.Priority">
            <summary>Gets the priority of this queue in its associated scheduler.</summary>
        </member>
        <member name="P:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.Id">
            <summary>Gets the ID of this scheduler.</summary>
        </member>
        <member name="P:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.ScheduledTasks">
            <summary>Gets all of the tasks scheduled to this queue.</summary>
        </member>
        <member name="P:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.AssociatedScheduler">
            <summary>Gets the QueuedTaskScheduler with which this queue is associated.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue._Pool">
            <summary>The scheduler with which this pool is associated.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.WorkItems">
            <summary>The work items stored in this queue.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.Disposed">
            <summary>Whether this queue has been disposed.</summary>
        </member>
        <member name="F:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.Priority">
            <summary>Gets the priority for this queue.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.#ctor(System.Int32,MathService.Tasks.Scheduler.QueuedTaskScheduler)">
            <summary>Initializes the queue.</summary>
            <param name="priority">The priority associated with this queue.</param>
            <param name="pool">The scheduler with which this queue is associated.</param>
        </member>
        <member name="P:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.WaitingTasks">
            <summary>Gets the number of tasks waiting in this scheduler.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.GetScheduledTasks">
            <summary>Gets the tasks scheduled to this scheduler.</summary>
            <returns>An enumerable of all tasks queued to this scheduler.</returns>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler.</summary>
            <param name="task">The task to be queued.</param>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Tries to execute a task synchronously on the current thread.</summary>
            <param name="task">The task to execute.</param>
            <param name="TaskWasPreviouslyQueued">Whether the task was previously queued.</param>
            <returns>true if the task was executed; otherwise, false.</returns>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.ExecuteTask(System.Threading.Tasks.Task)">
            <summary>Runs the specified ask.</summary>
            <param name="task">The task to execute.</param>
        </member>
        <member name="P:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level to use when processing tasks.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.QueuedTaskScheduler.QueuedTaskSchedulerQueue.Dispose">
            <summary>Signals that the queue should be removed from the scheduler as soon as the queue is empty.</summary>
        </member>
        <member name="T:MathService.Tasks.Scheduler.ThreadPerTaskScheduler">
            <summary>Provides a task scheduler that dedicates a thread per task.</summary>
        </member>
        <member name="M:MathService.Tasks.Scheduler.ThreadPerTaskScheduler.GetScheduledTasks">
            <summary>Gets the tasks currently scheduled to this scheduler.</summary>
            <remarks>This will always return an empty enumerable, as tasks are launched as soon as they're queued.</remarks>
        </member>
        <member name="M:MathService.Tasks.Scheduler.ThreadPerTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Starts a new thread to process the provided task.</summary>
            <param name="task">The task to be executed.</param>
        </member>
        <member name="M:MathService.Tasks.Scheduler.ThreadPerTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Runs the provided task on the current thread.</summary>
            <param name="task">The task to be executed.</param>
            <param name="TaskWasPreviouslyQueued">Ignored.</param>
            <returns>Whether the task could be executed on the current thread.</returns>
        </member>
        <member name="T:MathService.Temp.Simplex">
            <summary>
            Данный класс содержит реализацию симплекс-метода.
            </summary>
            <remarks>
            Изначально был написан на C++, источник: http://marioslapseofreason.blogspot.com/2010/12/linear-programming-simplex-algorithm.html
            Портирование под .NET и добавление проверки начальных условий: Владимир Панченко
            </remarks>
        </member>
        <member name="M:MathService.Temp.Simplex.CheckSimplex(System.Double[],System.Double[0:,0:],System.Double[])">
            <summary>
            Проверяет корректность исходных данных.
            </summary>
            <param name="b">Вектор со значениями правой части неравенств.</param>
            <param name="MaxFunction"></param>
        </member>
        <member name="M:MathService.Temp.Simplex.SetSimplex(System.Double[],System.Double[0:,0:],System.Double[])">
            <param name="maxFunction">Vector with the values of the coefficients for each variable.
            Example: { 2 , 1.5 , 1 } for 2X + (3/2)Y + Z</param>
            <param name="A">Matrix with the coefficient of the left sides of all the inequalities.</param>
            <param name="b">Vector with the values of the right side of the inequalities.</param>
            <returns>Linear program in canonical form</returns>
        </member>
        <member name="M:MathService.Temp.Simplex.DoSimplex(System.Double[],System.Double[0:,0:],System.Double[],System.Double@)">
            <summary>
            Максимизирует целевую функцию с учётом ограничений с помощью симплекс-метода.
            </summary>
            <param name="maxFunction">Вектор коэффицентов целевой функции.</param>
            <param name="A">Матрица коэффициентов при параметрах в левой части неравенств.</param>
            <param name="b">Вектор со значениями правой части неравенств.</param>
            <param name="max">Максимальное значение функции с учётом ограничений.</param>
            <returns>Вектор значений параметров.</returns>
        </member>
        <member name="T:MathService.Temp.Y_Combinator">
            <summary>Y-комбинатор</summary>
        </member>
        <member name="M:MathService.Temp.Y_Combinator.Y``2(System.Func{System.Func{``0,``1},System.Func{``0,``1}})">
            <summary>Y = (λh.λF.F(λx.((h(h))(F))(x))) (λh.λF.F(λx.((h(h))(F))(x)))</summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TOut"></typeparam>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="T:MathService.Test.Productivity">
            <summary>
            Тестирование производительности
            </summary>
        </member>
        <member name="M:MathService.Test.Productivity.GetExecutionTime(System.Action,System.Int32,System.Threading.ThreadPriority)">
            <summary>Определение времени выполнения кода </summary>
            <param name="action">Выполняемый код</param>
            <param name="Count">Объём статистики</param>
            <returns>Средняя длительность выполнения кода</returns>
        </member>
        <member name="T:MathService.TimeInterval">
            <summary>Интервальный предикат</summary>
        </member>
        <member name="F:MathService.TimeInterval._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathService.TimeInterval._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathService.TimeInterval._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathService.TimeInterval._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathService.TimeInterval.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathService.TimeInterval.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathService.TimeInterval.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathService.TimeInterval.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathService.TimeInterval.Length">
            <summary>Протяжённость интервала</summary>
        </member>
        <member name="M:MathService.TimeInterval.#ctor(System.TimeSpan)">
            <summary>Интервал</summary>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathService.TimeInterval.#ctor(System.TimeSpan,System.TimeSpan)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верзняя граница интервала</param>
        </member>
        <member name="M:MathService.TimeInterval.#ctor(System.TimeSpan,System.TimeSpan,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
        </member>
        <member name="M:MathService.TimeInterval.#ctor(System.TimeSpan,System.Boolean,System.TimeSpan)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathService.TimeInterval.#ctor(System.TimeSpan,System.Boolean,System.TimeSpan,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathService.TimeInterval.Check(System.TimeSpan)">
            <summary>Проверка на входжение в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <returns>Истина, если величина входит в интервал</returns>
        </member>
        <member name="M:MathService.TimeInterval.IsInclude(MathService.TimeInterval)">
            <summary>
            Проверка вхождения интервала в интервал
            </summary>
            <param name="I">Проверяемый интервал</param>
            <returns>Истина, если проверяемый интервал входит</returns>
        </member>
        <member name="M:MathService.TimeInterval.op_Implicit(MathService.TimeInterval)~System.Predicate{System.TimeSpan}">
            <summary>Оператор неявного приведения типа к предикату</summary>
            <param name="I">Интервал</param>
            <returns>Предикат от вещественного типа двойной точности</returns>
        </member>
        <member name="M:MathService.TimeInterval.op_ExclusiveOr(System.TimeSpan,MathService.TimeInterval)">
            <summary>Оператор проверки на вхоождение величины в интервал</summary>
            <param name="x">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="M:MathService.TimeInterval.op_ExclusiveOr(MathService.TimeInterval,System.TimeSpan)">
            <summary>Оператор проверки на вхоождение величины в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="T:MathService.DateTimeInterval">
            <summary>Интервальный предикат</summary>
        </member>
        <member name="F:MathService.DateTimeInterval._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathService.DateTimeInterval._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathService.DateTimeInterval._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathService.DateTimeInterval._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathService.DateTimeInterval.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathService.DateTimeInterval.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathService.DateTimeInterval.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathService.DateTimeInterval.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathService.DateTimeInterval.Length">
            <summary>Протяжённость интервала</summary>
        </member>
        <member name="M:MathService.DateTimeInterval.#ctor(System.DateTime)">
            <summary>Интервал</summary>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathService.DateTimeInterval.#ctor(System.DateTime,System.DateTime)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верзняя граница интервала</param>
        </member>
        <member name="M:MathService.DateTimeInterval.#ctor(System.DateTime,System.DateTime,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
        </member>
        <member name="M:MathService.DateTimeInterval.#ctor(System.DateTime,System.Boolean,System.DateTime)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathService.DateTimeInterval.#ctor(System.DateTime,System.Boolean,System.DateTime,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathService.DateTimeInterval.Check(System.DateTime)">
            <summary>Проверка на входжение в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <returns></returns>
        </member>
        <member name="M:MathService.DateTimeInterval.op_Implicit(MathService.DateTimeInterval)~System.Predicate{System.DateTime}">
            <summary>Оператор неявного приведения типа к предикату</summary>
            <param name="I">Интервал</param>
            <returns>Предикат от вещественного типа двойной точности</returns>
        </member>
        <member name="M:MathService.DateTimeInterval.op_ExclusiveOr(System.DateTime,MathService.DateTimeInterval)">
            <summary>Оператор проверки на вхоождение величины в интервал</summary>
            <param name="x">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="M:MathService.DateTimeInterval.op_ExclusiveOr(MathService.DateTimeInterval,System.DateTime)">
            <summary>Оператор проверки на вхоождение величины в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="T:MathService.DisposableGroup`1">
            <summary>Группа объектов, поддерживающих интерфейс <see cref="T:System.IDisposable">освобождения ресурсов</see></summary>
            <typeparam name="T">Тип объектов, подерживающих интерфейс <see cref="T:System.IDisposable"/></typeparam>
        </member>
        <member name="F:MathService.DisposableGroup`1._Items">
            <summary>Массив содержащихся объектов интерфейса <see cref="T:System.IDisposable"/></summary>
        </member>
        <member name="P:MathService.DisposableGroup`1.Count">
            <summary>Число элементов группы</summary>
        </member>
        <member name="P:MathService.DisposableGroup`1.Items">
            <summary>Массив элементов группы</summary>
        </member>
        <member name="P:MathService.DisposableGroup`1.Item(System.Int32)">
            <summary>Элемент группы</summary>
            <param name="i">Номер элемента группы</param>
            <returns>Элемент группы с номером <paramref name="i"/></returns>
        </member>
        <member name="M:MathService.DisposableGroup`1.#ctor(`0[])">
            <summary>Группа <typeparam name="T">объектов</typeparam> интерфейса <see cref="T:System.IDisposable"/></summary>
            <param name="item"><typeparam name="T">Объект</typeparam> интерфейса <see cref="T:System.IDisposable"/></param>
        </member>
        <member name="M:MathService.DisposableGroup`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Группа <typeparam name="T">объектов</typeparam> интерфейса <see cref="T:System.IDisposable"/></summary>
            <param name="items">Перечисление <typeparam name="T">объектов</typeparam> интерфейса <see cref="T:System.IDisposable"/></param>
        </member>
        <member name="M:MathService.DisposableGroup`1.Dispose">
            <summary>Освободить ресурсы группы</summary>
        </member>
        <member name="M:MathService.DisposableGroup`1.GetEnumerator">
            <summary>Получить перечислитель элементов группы</summary>
            <returns>Перечислитель элементов группы</returns>
        </member>
        <member name="M:MathService.DisposableGroup`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.ICloneable`1">
            <summary>Объект поддерживает клонирование</summary>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="M:MathService.ICloneable`1.Clone">
            <summary>Клонирование объекта</summary>
            <returns>Клонированный экземпляр объекта</returns>
        </member>
        <member name="T:MathService.IIndexableRead`2">
            <summary>Объект индексируемый только для чтения значений</summary>
            <typeparam name="TIndex">Тип индекса</typeparam>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathService.IIndexableRead`2.Item(`0)">
            <summary>Индексатор объекта только для чтения</summary>
            <param name="index">Индекс</param>
        </member>
        <member name="T:MathService.IIndexableRead`3">
            <summary>Объект индексируемый только для чтения значений с двумя индексами</summary>
            <typeparam name="TIndex1">Тип первого индекса</typeparam>
            <typeparam name="TIndex2">Тип второго индекса</typeparam>
            <typeparam name="TValue">Тип значений</typeparam>
        </member>
        <member name="P:MathService.IIndexableRead`3.Item(`0,`1)">
            <summary>Индексатор объекта только для чтения</summary>
            <param name="index1">Первый индекс</param>
            <param name="index2">Второй индекс</param>
        </member>
        <member name="T:MathService.IIndexableWrite`2">
            <summary>Объект индексируемый только для записи значений</summary>
            <typeparam name="TIndex">Тип индекса</typeparam>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathService.IIndexableWrite`2.Item(`0)">
            <summary>Индексатор объекта только для записи</summary><param name="index">Индекс</param>
        </member>
        <member name="T:MathService.IIndexableWrite`3">
            <summary>Объект индексируемый только для записи значений с двумя индексами</summary>
            <typeparam name="TIndex1">Тип первого индекса</typeparam>
            <typeparam name="TIndex2">Тип второго индекса</typeparam>
            <typeparam name="TValue">Тип значений</typeparam>
        </member>
        <member name="P:MathService.IIndexableWrite`3.Item(`0,`1)">
            <summary>Индексатор объекта только для записи</summary>
            <param name="index1">Первый индекс</param><param name="index2">Второй индекс</param>
        </member>
        <member name="T:MathService.IIndexable`2">
            <summary>Объект индексируемый</summary>
            <typeparam name="TIndex">Тип индекса</typeparam><typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathService.IIndexable`2.Item(`0)">
            <summary>Индексатор объекта</summary><param name="index">Индекс</param>
        </member>
        <member name="T:MathService.IIndexable`3">
            <summary>Объект индексируемый с двумя параметрами индекса</summary>
            <typeparam name="TIndex1">Тип первого индекса</typeparam>
            <typeparam name="TIndex2">Тип второго индекса</typeparam>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathService.IIndexable`3.Item(`0,`1)">
            <summary>Индексатор объекта</summary>
            <param name="index1">Первый индекс</param><param name="index2">Второй индекс</param>
        </member>
        <member name="T:MathService.IIndexable`1">
            <summary>Объект индексируемый с целочисленным индексом</summary>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="T:MathService.INamedRead">
            <summary>Объект, обладающий именем</summary>
        </member>
        <member name="P:MathService.INamedRead.Name">
            <summary>Имя объекта</summary>
        </member>
        <member name="T:MathService.INamed">
            <summary>Объект с возможностью задавать имя</summary>
        </member>
        <member name="P:MathService.INamed.Name">
            <summary>Имя объекта</summary>
        </member>
        <member name="T:MathService.NamedInterfaceExtentions">
            <summary>Методы-расширения интерфейса именованых объектов</summary>
        </member>
        <member name="M:MathService.NamedInterfaceExtentions.Rename(MathService.INamed,System.String)">
            <summary>Изменить имя объекта</summary>
            <param name="obj">Объект, имя которого требуется изменить</param>
            <param name="NewName">Новое имя объекта</param>
        </member>
        <member name="T:MathService.ComplexExtentions">
            <summary>Методы-расширения комплексных чисел</summary>
        </member>
        <member name="M:MathService.ComplexExtentions.ToRe(MathService.Complex[])">
            <summary>Преобразование массива комплексных чисел в масив действительных</summary>
            <param name="c">Массив комплексных чисел</param>
            <returns>Массив действительных чисел</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToIm(MathService.Complex[])">
            <summary>Массив комплексных чисел в массив значений мнимых чисел</summary>
            <param name="c">Массив комплексных чисел</param>
            <returns>Массив значений комплексных мнимых чисел</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToAbs(MathService.Complex[])">
            <summary>Массив комплексных чисел в массив модулей</summary>
            <param name="c">Массив сомплексных чисел</param>
            <returns>Массив модулей комплексных чисел</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToArg(MathService.Complex[])">
            <summary>Массив сомплексных чисел в массив аргументов</summary>
            <param name="c">Массив комплексных чисел</param>
            <returns>Массив аргументов комплексных чисел</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToReImArray(MathService.Complex[])">
            <summary>
            Массив комплексных чисел в двумерный массив действительных и мнимых частей, где
            Re = V[i,0]
            Im = V[i,1]
            </summary>
            <param name="c">Массив комплексных чисел</param>
            <returns>Двумерный массив вещественных и мнимых частей</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToAbsArgArray(MathService.Complex[])">
            <summary>
            Массив комплексных чисел в двумерный массив модулей и аргументов частей, где
            Abs = V[i,0]
            Arg = V[i,1]
            </summary>
            <param name="c">Массив комплексных чисел</param>
            <returns>Двумерный массив Модулей и аргументов</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToComplex(System.Double[])">
            <summary>Преобразовать массив действительных в массив комплексных чисел</summary>
            <param name="Re">Массив действительных чисел</param>
            <returns>Массив комплексных чисел</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.ToComplex(System.Double[0:,0:])">
            <summary>Преобразовать двумерный массив действительных в массив комплексных чисел</summary>
            <param name="Values">Двумерный массив действительных чисел, где Re = V[i,0], Im = V[i,1]</param>
            <returns>Массив комплексных чисел</returns>
        </member>
        <member name="M:MathService.ComplexExtentions.GetAbs(MathService.Complex[])">
            <summary>Преобразование в массив модулей</summary>
            <param name="c">Массив комплексных чисел</param>
            <returns>Массив модулей комплексных чисел</returns>
        </member>
        <member name="T:MathService.MNK">
            <summary>Метод наименьших квадратов</summary>
        </member>
        <member name="F:MathService.MNK._A">
            <summary>Коэффициенты апроксимирующего полинома</summary>
        </member>
        <member name="F:MathService.MNK._M">
            <summary>Максимальный показатель степени многочления апроксимации</summary>
        </member>
        <member name="F:MathService.MNK._XData">
            <summary>Значение абсцисс точек данных</summary>
        </member>
        <member name="F:MathService.MNK._YData">
            <summary>Значение ординат точек данных</summary>
        </member>
        <member name="M:MathService.MNK.#ctor(System.Double[],System.Double[],System.Int32)">
            <summary>Апроксиматор методом наименьших квадратов</summary>
            <param name="X">Массив аргументов</param>
            <param name="Y">Массив значений</param>
            <param name="m">Степень полинома интерполяции</param>
        </member>
        <member name="T:MathService.Interval`1">
            <summary>Интервал сравнимых величин</summary>
            <typeparam name="T">Тип сравнимых величин</typeparam>
        </member>
        <member name="M:MathService.Interval`1.Value(`0,`0,System.Boolean)">
            <summary>Определение нового интервала</summary>
            <param name="Min">Минимальное значение</param>
            <param name="Max">Максимальное значение</param>
            <param name="IncludeLimits">Границы интервала входят?</param>
            <returns>Новый интервал в указанных границах</returns>
        </member>
        <member name="F:MathService.Interval`1._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathService.Interval`1._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathService.Interval`1._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathService.Interval`1._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathService.Interval`1.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathService.Interval`1.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathService.Interval`1.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathService.Interval`1.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="M:MathService.Interval`1.#ctor(`0,`0)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верзняя граница интервала</param>
        </member>
        <member name="M:MathService.Interval`1.#ctor(`0,`0,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы? (default:true)</param>
        </member>
        <member name="M:MathService.Interval`1.#ctor(`0,System.Boolean,`0)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathService.Interval`1.#ctor(`0,System.Boolean,`0,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathService.Interval`1.Normalize(`0)">
            <summary>
            Метод возвращает указанное значение, если оно находится внутри интервала, либо соответствующую его границу, если значение входит за его пределы
            </summary>
            <param name="Value">Нормализуемое значение</param>
            <returns>Значение, переданное в качестве аргумента, если оно входит в интервал, иначе соответствующая граница интервала</returns>
        </member>
        <member name="M:MathService.Interval`1.Normalize(`0@)">
            <summary>Замена значения ссылки на значение границы интервала, если значение не входит в интервал</summary>
            <param name="Value">Проверяемое значение</param>
        </member>
        <member name="M:MathService.Interval`1.Check(`0)">
            <summary>Проверка на вхождение значения в интервал</summary>
            <param name="Value">Проверяемое значение</param>
            <returns>Истина, если значение входит в интервал</returns>
        </member>
        <member name="M:MathService.Interval`1.IsInclude(MathService.Interval{`0})">
            <summary>Проверка - входит ли указанный интервал в текущий</summary>
            <param name="I">Проверяемый интервал</param>
            <returns>Истина, если проверяемый интервал находится в границах текущего</returns>
        </member>
        <member name="M:MathService.Interval`1.GetHashCode">
            <summary>Играет роль хэш-функции для определенного типа. </summary>
            <returns>Хэш-код для текущего объекта <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.Interval`1.Equals(MathService.Interval{`0})">
            <summary>Указывает, равен ли текущий объект другому объекту того же типа.</summary>
            <returns>true, если текущий объект равен параметру <paramref name="other"/>, в противном случае — false.</returns>
            <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        </member>
        <member name="M:MathService.Interval`1.Equals(System.Object)">
            <summary>
            Определяет, равен ли заданный объект <see cref="T:System.Object"/> текущему объекту <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true, если указанный объект <see cref="T:System.Object"/> равен текущему объекту <see cref="T:System.Object"/>; в противном случае — false.
            </returns>
            <param name="obj">Объект <see cref="T:System.Object"/>, который требуется сравнить с текущим объектом <see cref="T:System.Object"/>.</param>
            <exception cref="T:System.NullReferenceException">Параметр <paramref name="obj"/> имеет значение null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.Interval`1.System#ICloneable#Clone">
            <summary>Создает новый объект, который является копией текущего экземпляра.</summary>
            <returns>Новый объект, являющийся копией этого экземпляра.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.Interval`1.ToString">
            <summary>
            Возвращает объект <see cref="T:System.String"/>, который представляет текущий объект <see cref="T:System.Object"/>.
            </summary>
            <returns>Объект <see cref="T:System.String"/>, представляющий текущий объект <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.Interval`1.op_Implicit(MathService.Interval{`0})~System.Predicate{`0}">
            <summary>Оператор неявного приведения типа к предикату</summary>
            <param name="I">Интервал</param>
            <returns>Предикат от вещественного типа двойной точности</returns>
        </member>
        <member name="M:MathService.Interval`1.op_ExclusiveOr(`0,MathService.Interval{`0})">
            <summary>Оператор проверки на вхоождение величины в интервал</summary>
            <param name="Value">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="M:MathService.Interval`1.op_ExclusiveOr(MathService.Interval{`0},`0)">
            <summary>Оператор проверки на вхоождение величины в интервал</summary>
            <param name="Value">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="T:MathService.Interval">
            <summary>Интервал вещественых значений двойной точности</summary>
        </member>
        <member name="M:MathService.Interval.Comparer_Length(MathService.Interval,MathService.Interval)">
            <summary>Метод сравнения двух интервалов</summary>
            <param name="a">Первый сравниваемый интервал</param>
            <param name="b">Второй сравниваемый интервал</param>
            <returns>1 - если первый интервал больше второго, -1 - если первый интервал меньше второго, 0 - если интервалы равны</returns>
        </member>
        <member name="P:MathService.Interval.Length">
            <summary>Длина интервала</summary>
        </member>
        <member name="P:MathService.Interval.Middle">
            <summary>Середина интервала</summary>
        </member>
        <member name="M:MathService.Interval.#ctor(System.Double,System.Double)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верзняя граница интервала</param>
        </member>
        <member name="M:MathService.Interval.#ctor(System.Double,System.Double,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
        </member>
        <member name="M:MathService.Interval.#ctor(System.Double,System.Boolean,System.Double)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathService.Interval.#ctor(System.Double,System.Boolean,System.Double,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathService.Interval.ToString(System.String,System.IFormatProvider)">
            <summary>Форматирует значение текущего экземпляра с использованием заданного формата.</summary>
            <returns>Объект <see cref="T:System.String"/> содержит значение текущего экземпляра в заданном формате.</returns>
            <param name="format">
            Объект <see cref="T:System.String"/>, задающий используемый формат.— или — 
            Значение null для использования формата по умолчанию, определенного для типа реализации 
            <see cref="T:System.IFormattable"/>. 
            </param>
            <param name="formatProvider">
            Объект <see cref="T:System.IFormatProvider"/>, используемый для форматирования значения.— или — 
            Значение null для получения сведений о форматировании чисел на основе текущего значения параметра языкового 
            стандарта операционной системы. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.MatrixDecimal">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathService.MatrixDecimal.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetTransvection(MathService.MatrixDecimal,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathService.MatrixDecimal._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathService.MatrixDecimal._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathService.MatrixDecimal._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathService.MatrixDecimal.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathService.MatrixDecimal.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathService.MatrixDecimal.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathService.MatrixDecimal.Item(System.Int32)">
            <summary>Вектор-стольбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathService.MatrixDecimal.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathService.MatrixDecimal.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathService.MatrixDecimal.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathService.MatrixDecimal.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathService.MatrixDecimal.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathService.MatrixDecimal.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="T:MathService.MatrixDecimal.MatrixDecimalItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.#ctor(System.Int32,MathService.MatrixDecimal.MatrixDecimalItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixDecimal.#ctor(System.Int32,System.Int32,MathService.MatrixDecimal.MatrixDecimalItemCreator)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixDecimal.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathService.MatrixDecimal.LUDecomposition(System.Decimal[0:,0:],System.Decimal[0:,0:]@,System.Decimal[0:,0:]@,System.Decimal[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note - This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower traingular matrix is returned</param>
            <param name="U">An array where the upper traingular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathService.MatrixDecimal.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.op_Addition(MathService.MatrixDecimal,MathService.MatrixDecimal)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.op_Subtraction(MathService.MatrixDecimal,MathService.MatrixDecimal)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.op_Multiply(MathService.MatrixDecimal,MathService.MatrixDecimal)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.op_Division(MathService.MatrixDecimal,MathService.MatrixDecimal)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.op_BitwiseOr(MathService.MatrixDecimal,MathService.MatrixDecimal)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathService.MatrixDecimal.op_Implicit(System.Decimal)~MathService.MatrixDecimal">
            <summary>Оператор неявного преведения типа вещественного числа двойной точнойсти к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порадка 1х1</returns>
        </member>
        <member name="T:MathService.MatrixFloat">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathService.MatrixFloat.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetTransvection(MathService.MatrixFloat,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathService.MatrixFloat._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathService.MatrixFloat._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathService.MatrixFloat._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathService.MatrixFloat.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathService.MatrixFloat.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathService.MatrixFloat.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathService.MatrixFloat.Item(System.Int32)">
            <summary>Вектор-стольбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathService.MatrixFloat.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathService.MatrixFloat.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathService.MatrixFloat.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathService.MatrixFloat.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathService.MatrixFloat.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathService.MatrixFloat.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="T:MathService.MatrixFloat.MatrixFloatItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathService.MatrixFloat.#ctor(System.Int32,MathService.MatrixFloat.MatrixFloatItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixFloat.#ctor(System.Int32,System.Int32,MathService.MatrixFloat.MatrixFloatItemCreator)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixFloat.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixFloat.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathService.MatrixFloat.LUDecomposition(System.Single[0:,0:],System.Single[0:,0:]@,System.Single[0:,0:]@,System.Single[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note - This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower traingular matrix is returned</param>
            <param name="U">An array where the upper traingular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathService.MatrixFloat.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathService.MatrixFloat.op_Addition(MathService.MatrixFloat,MathService.MatrixFloat)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixFloat.op_Subtraction(MathService.MatrixFloat,MathService.MatrixFloat)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixFloat.op_Multiply(MathService.MatrixFloat,MathService.MatrixFloat)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixFloat.op_Division(MathService.MatrixFloat,MathService.MatrixFloat)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixFloat.op_BitwiseOr(MathService.MatrixFloat,MathService.MatrixFloat)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathService.MatrixFloat.op_Implicit(System.Single)~MathService.MatrixFloat">
            <summary>Оператор неявного преведения типа вещественного числа двойной точнойсти к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порадка 1х1</returns>
        </member>
        <member name="T:MathService.MatrixInt">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathService.MatrixInt.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetTransvection(MathService.MatrixInt,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathService.MatrixInt._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathService.MatrixInt._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathService.MatrixInt._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathService.MatrixInt.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathService.MatrixInt.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathService.MatrixInt.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathService.MatrixInt.Item(System.Int32)">
            <summary>Вектор-стольбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathService.MatrixInt.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathService.MatrixInt.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathService.MatrixInt.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathService.MatrixInt.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathService.MatrixInt.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathService.MatrixInt.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="T:MathService.MatrixInt.MatrixIntItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathService.MatrixInt.#ctor(System.Int32,MathService.MatrixInt.MatrixIntItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixInt.#ctor(System.Int32,System.Int32,MathService.MatrixInt.MatrixIntItemCreator)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixInt.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MatrixInt.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixInt.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathService.MatrixInt.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathService.MatrixInt.op_Addition(MathService.MatrixInt,MathService.MatrixInt)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixInt.op_Subtraction(MathService.MatrixInt,MathService.MatrixInt)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixInt.op_Multiply(MathService.MatrixInt,MathService.MatrixInt)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixInt.op_Division(MathService.MatrixInt,MathService.MatrixInt)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixInt.op_BitwiseOr(MathService.MatrixInt,MathService.MatrixInt)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathService.MatrixInt.op_Implicit(System.Int32)~MathService.MatrixInt">
            <summary>Оператор неявного преведения типа вещественного числа двойной точнойсти к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порадка 1х1</returns>
        </member>
        <member name="T:MathService.MatrixLong">
            <summary>Матрица NxM</summary>
            <remarks>
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathService.MatrixLong.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetTransvection(MathService.MatrixLong,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathService.MatrixLong._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathService.MatrixLong._M">
            <summary>Число столбцов матриц</summary>
        </member>
        <member name="F:MathService.MatrixLong._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathService.MatrixLong.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathService.MatrixLong.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathService.MatrixLong.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathService.MatrixLong.Item(System.Int32)">
            <summary>Вектор-стольбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathService.MatrixLong.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathService.MatrixLong.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathService.MatrixLong.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathService.MatrixLong.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathService.MatrixLong.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathService.MatrixLong.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="M:MathService.MatrixLong.#ctor(System.Int32,System.Func{System.Int32,System.Int32,System.Int64})">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixLong.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Int64})">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathService.MatrixLong.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.MatrixLong.GetImverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathService.MatrixLong.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathService.MatrixLong.LUDecomposition(System.Int64[0:,0:],System.Int64[0:,0:]@,System.Int64[0:,0:]@,System.Int64[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note: This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower traingular matrix is returned</param>
            <param name="U">An array where the upper traingular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathService.MatrixLong.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathService.MatrixLong.op_Addition(MathService.MatrixLong,MathService.MatrixLong)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixLong.op_Subtraction(MathService.MatrixLong,MathService.MatrixLong)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixLong.op_Multiply(MathService.MatrixLong,MathService.MatrixLong)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixLong.op_Division(MathService.MatrixLong,MathService.MatrixLong)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathService.MatrixLong.op_BitwiseOr(MathService.MatrixLong,MathService.MatrixLong)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathService.MatrixLong.op_Implicit(System.Int64)~MathService.MatrixLong">
            <summary>
            Оператор неявного преведения типа вещественного числа двойной точнойсти к типу 
            Матрица порядка 1х1
            </summary>
            <param name="X">Приводимое число</param>
            <returns>Матрица порадка 1х1</returns>
        </member>
        <member name="T:MathService.TimeoutEvent`1">
            <summary>Класс задержки реакции на событие</summary>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
        </member>
        <member name="M:MathService.TimeoutEvent`1.Subscribe(System.Int32,System.EventHandler{`0},System.EventHandler{`0})">
            <summary>Метод подписки на событие</summary>
            <param name="Timeout">Таймаут</param>
            <param name="OnTimeout">Метод обработки первичного вызова события</param>
            <param name="OnInvoke">Метод обраобтки вторичного события</param>
            <returns>Обработчик исходного события</returns>
        </member>
        <member name="F:MathService.TimeoutEvent`1.c_Infinite">
            <summary>Константа бесконечного периода ожидания</summary>
        </member>
        <member name="T:MathService.TimeoutEvent`1.Info">
            <summary>Аргумент события</summary>
        </member>
        <member name="P:MathService.TimeoutEvent`1.Info.EventSender">
            <summary>Источник сходного события</summary>
        </member>
        <member name="P:MathService.TimeoutEvent`1.Info.E">
            <summary>Акргумент исходного события</summary>
        </member>
        <member name="M:MathService.TimeoutEvent`1.Info.#ctor(System.Object,`0)">
            <summary>Аргумент события</summary>
            <param name="EventSender">Источник исходного события</param>
            <param name="e">Аргумент исходного события</param>
        </member>
        <member name="E:MathService.TimeoutEvent`1.Invoked">
            <summary>Первычная генерация события</summary>
        </member>
        <member name="M:MathService.TimeoutEvent`1.OnInvoked(MathService.TimeoutEvent{`0}.Info)">
            <summary>Метод первичной генерации события <see cref="E:MathService.TimeoutEvent`1.Invoked"/></summary>
            <param name="e">Аргумент первичного вызова события</param>
        </member>
        <member name="E:MathService.TimeoutEvent`1.Timeouted">
            <summary>Событие, возникающее после последнего вызова метода <see cref="M:MathService.TimeoutEvent`1.Invoke(System.Object,`0)"/> через период времени <see cref="P:MathService.TimeoutEvent`1.Timeout"/></summary>
        </member>
        <member name="M:MathService.TimeoutEvent`1.OnTimeouted(MathService.TimeoutEvent{`0}.Info)">
            <summary>Мeтод генерации события <see cref="E:MathService.TimeoutEvent`1.Timeouted"/></summary>
            <param name="e">Аргумент события</param>
        </member>
        <member name="F:MathService.TimeoutEvent`1._Timer">
            <summary>Таймер</summary>
        </member>
        <member name="F:MathService.TimeoutEvent`1._Timeout">
            <summary>Период времени таймаута</summary>
        </member>
        <member name="F:MathService.TimeoutEvent`1._LastCallTime">
            <summary>Время последнего вызова</summary>
        </member>
        <member name="F:MathService.TimeoutEvent`1._InProcess">
            <summary>Признак ожидания таймаута события</summary>
        </member>
        <member name="F:MathService.TimeoutEvent`1._LastEventArgs">
            <summary>Аргумент последнего выхова метода <see cref="M:MathService.TimeoutEvent`1.Invoke(System.Object,`0)"/></summary>
        </member>
        <member name="F:MathService.TimeoutEvent`1._NeedAbort">
            <summary>Признак ожидания отмены генерации события <see cref="E:MathService.TimeoutEvent`1.Timeouted"/></summary>
        </member>
        <member name="P:MathService.TimeoutEvent`1.Timeout">
            <summary>Задейржка во времени генерации события <see cref="E:MathService.TimeoutEvent`1.Timeouted"/> в миллисекундах</summary>
        </member>
        <member name="P:MathService.TimeoutEvent`1.LastCallTime">
            <summary>Время последнего выхова метода <see cref="M:MathService.TimeoutEvent`1.Invoke(System.Object,`0)"/></summary>
        </member>
        <member name="P:MathService.TimeoutEvent`1.InProcess">
            <summary>Признак ожидания генерации события <see cref="E:MathService.TimeoutEvent`1.Invoked"/></summary>
        </member>
        <member name="P:MathService.TimeoutEvent`1.NeedAbort">
            <summary>Признак отмены генерации собития <see cref="E:MathService.TimeoutEvent`1.Timeouted"/></summary>
        </member>
        <member name="M:MathService.TimeoutEvent`1.#ctor(System.Int32)">
            <summary>Инициализация нового объекта задержки генерации соытия</summary>
            <param name="Timeout">Временная задержка в миллисекундах</param>
        </member>
        <member name="M:MathService.TimeoutEvent`1.#ctor(System.Int32,System.EventHandler{`0})">
            <summary>Инициализация нового объекта задержки генерации соытия</summary>
            <param name="Timeout">Временная задержка в миллисекундах</param>
            <param name="OnTimeout">Метод вторичной обработки события</param>
        </member>
        <member name="M:MathService.TimeoutEvent`1.#ctor(System.Int32,System.EventHandler{`0},System.EventHandler{`0})">
            <summary>Инициализация нового объекта задержки генерации соытия</summary>
            <param name="Timeout">Временная задержка в миллисекундах</param>
            <param name="OnTimeout">Метод вторичной обработки события</param>
            <param name="OnInvoke">Метод первичной обработки события</param>
        </member>
        <member name="M:MathService.TimeoutEvent`1.OnTimer(System.Object)">
            <summary>Метод оброботки события таймера</summary>
            <param name="State">Состояние таймера</param>
        </member>
        <member name="M:MathService.TimeoutEvent`1.Invoke(System.Object,`0)">
            <summary>Метод генерации события</summary>
            <param name="EventSender">Источник события</param>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:MathService.TimeoutEvent`1.Abort">
            <summary>Отмена реакции на событие</summary>
        </member>
        <member name="T:MathService.Time.TimeCounter">
            <summary>
            Измеритель времени
            </summary>
        </member>
        <member name="F:MathService.Time.TimeCounter._Started">
            <summary>Флаг состояния</summary>
        </member>
        <member name="F:MathService.Time.TimeCounter._LockObject">
            <summary>Объект межпотоковой синхронизации</summary>
        </member>
        <member name="P:MathService.Time.TimeCounter.IsStarted">
            <summary>Состояние измерителя</summary>
        </member>
        <member name="P:MathService.Time.TimeCounter.TotalTime">
            <summary>Прошло времени</summary>
        </member>
        <member name="M:MathService.Time.TimeCounter.Start">
            <summary>Запуск</summary>
        </member>
        <member name="M:MathService.Time.TimeCounter.Stop">
            <summary>Остановка</summary>
        </member>
        <member name="M:MathService.Time.TimeCounter.Reset">
            <summary>Сброс измерителя</summary>
        </member>
        <member name="T:MathService.Trees.ITreeItemEx">
            <summary>Методы-расширения интерфейса элемента двусвязного дерева</summary>
        </member>
        <member name="M:MathService.Trees.ITreeItemEx.GetRootItem``1(``0)">
            <summary>Определение корня дерева</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <returns>КОрневой объект дерева объектов</returns>
        </member>
        <member name="M:MathService.Trees.ITreeItemEx.OrderWalk``1(``0,MathService.Trees.ITreeItemEx.OrderWalkType,System.Int32)">
            <summary>Обход элементов поддерева начиная с текущего в порядке: текущий, дочерний, следующий по уровню</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:MathService.Trees.ITreeItemEx.GetParents``1(``0)">
            <summary>Получить все родительские элементы</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <returns></returns>
        </member>
        <member name="M:MathService.Trees.ITreeItemEx.GetLevelItems``1(``0)">
            <summary>Получить все элементы дочернего уровня поддерева</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <returns></returns>
        </member>
        <member name="M:MathService.Trees.ITreeItemEx.GetChilds``1(``0)">
            <summary>Получить все дочерние элементы поддерева</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <returns></returns>
        </member>
        <member name="T:MathService.Trees.ITreeItem`1">
            <summary>Элемент двусвязного дерева</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MathService.Trees.ITreeItem`1.Parent">
            <summary>Родительский узел</summary>
        </member>
        <member name="P:MathService.Trees.ITreeItem`1.Child">
            <summary>Дочерний узел</summary>
        </member>
        <member name="P:MathService.Trees.ITreeItem`1.Prev">
            <summary>Предыдущий узел уровня</summary>
        </member>
        <member name="P:MathService.Trees.ITreeItem`1.Next">
            <summary>Следующий узел дерева</summary>
        </member>
        <member name="P:MathService.Trees.Tree`1.Count">
            <summary>Число элементов</summary>
        </member>
        <member name="P:MathService.Trees.Tree`1.Item(System.Int32)">
            <summary>Индексатор объекта</summary><param name="index">Индекс</param>
        </member>
        <member name="P:MathService.Trees.Tree`1.MathService#IIndexable{System#Int32,MathService#Trees#ITree{T}}#Item(System.Int32)">
            <summary>Индексатор объекта</summary><param name="index">Индекс</param>
        </member>
        <member name="P:MathService.Trees.Tree`1.MathService#IIndexableWrite{System#Int32,MathService#Trees#ITree{T}}#Item(System.Int32)">
            <summary>Индексатор объекта только для записи</summary><param name="index">Индекс</param>
        </member>
        <member name="P:MathService.Trees.Tree`1.MathService#IIndexableRead{System#Int32,MathService#Trees#ITree{T}}#Item(System.Int32)">
            <summary>Индексатор объекта только для чтения</summary>
            <param name="index">Индекс</param>
        </member>
        <member name="M:MathService.Trees.Tree`1.System#Collections#Generic#IEnumerable{MathService#Trees#ITree{T}}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции.</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathService.Trees.Tree`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathService.UsingDisposableObject`1">
            <summary>Класс-обёртка для inline-доступа к свойствам созданного объекта, наследующего интерфейс IDisposasble</summary>
            <typeparam name="T">Тип используемого объекта, наследующего интерфейс IDIsposable</typeparam>
        </member>
        <member name="M:MathService.UsingDisposableObject`1.#ctor(`0)">
            <summary>Новая обёртка для используемого объекта</summary>
            <param name="Obj">Используемый объект</param>
        </member>
        <member name="M:MathService.UsingDisposableObject`1.GetValue``1(System.Func{`0,``0})">
            <summary>Получить значение от объекта</summary>
            <typeparam name="TValue">Тип значения, получаемого от объекта</typeparam>
            <param name="f">Метод получения значения</param>
            <returns>Значение, полученное от объекта указанным методом</returns>
        </member>
        <member name="T:MathService.UsingObject`1">
            <summary>Оболочка, обеспечивающая освобождение ресурсов указаннцм методом для указанного объекта</summary>
            <typeparam name="T">Тип объекта, с которым работает оболочка</typeparam>
        </member>
        <member name="F:MathService.UsingObject`1._Obj">
            <summary>Используемый объект</summary>
        </member>
        <member name="F:MathService.UsingObject`1._Disposer">
            <summary>МЕтод освобождения ресурсов</summary>
        </member>
        <member name="P:MathService.UsingObject`1.Object">
            <summary>Используемый объект</summary>
        </member>
        <member name="M:MathService.UsingObject`1.#ctor(`0,System.Action{`0})">
            <summary>Упаковка объекта в оболочку с указанием метода освобождения ресурсов, занимаемых указанным объектом</summary>
            <param name="obj">Уничтожаемый объект</param>
            <param name="Disposer">Метод освобождения ресурсов</param>
        </member>
        <member name="M:MathService.UsingObject`1.Dispose">
            <summary>Разрушение обёртки, влекущее разрушение исопльзуемого объекта</summary>
        </member>
        <member name="M:MathService.UsingObject`1.op_Implicit(MathService.UsingObject{`0})~`0">
            <summary>Оператор неявного приведения типов</summary>
            <param name="obj">ОБъект-оболочка</param>
            <returns>Внутренний объект</returns>
        </member>
        <member name="M:MathService.ValuedInterval`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathService.Values.AbstractSetOf`1">
            <summary>Абстрактное множество элементов</summary>
            <typeparam name="T">Тип элементов множества</typeparam>
        </member>
        <member name="P:MathService.Values.AbstractSetOf`1.Power">
            <summary>Мощность множества</summary>
        </member>
        <member name="M:MathService.Values.AbstractSetOf`1.Contains(`0)">
            <summary>Признак вхождения элемента в множество</summary>
            <param name="value">Проверяемый элемент</param>
            <returns>Истина, если элемент принедлежит множеству</returns>
        </member>
        <member name="M:MathService.Values.AbstractSetOf`1.NotContains(`0)">
            <summary>Признак того, что элемент не входит в множество</summary>
            <param name="value">Проверяемый элемент</param>
            <returns>Истина, если элемент не принадлежит множеству</returns>
        </member>
        <member name="M:MathService.Values.AbstractSetOf`1.GetEnumerator">
            <summary>Получить перечислитель множества</summary>
            <returns>Перечислитель множества</returns>
        </member>
        <member name="M:MathService.Values.AbstractSetOf`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитель множества</summary>
            <returns>Перечислитель множества</returns>
        </member>
        <member name="T:MathService.Values.CSV">
            <summary>Файл текстовых данных, разделённых запятой</summary>
        </member>
        <member name="T:MathService.Values.CSV.Item">
            <summary>Элемент данных</summary>
        </member>
        <member name="F:MathService.Values.CSV.Item._Header">
            <summary>Элементы заголовка</summary>
        </member>
        <member name="F:MathService.Values.CSV.Item._Items">
            <summary>Элементы данных</summary>
        </member>
        <member name="P:MathService.Values.CSV.Item.Item(System.Int32)">
            <summary>Требуемый элемент данных по указанному индексу</summary>
            <param name="index">Индекс элемента данных</param>
            <returns>Элемент данных по указанному индексу</returns>
        </member>
        <member name="P:MathService.Values.CSV.Item.Item(System.String)">
            <summary>Требуемый элемент данных по указнному имени заголовка столбца</summary>
            <param name="key">Имя столбца зоголовка</param>
            <returns>Требуемый элемент данных</returns>
        </member>
        <member name="P:MathService.Values.CSV.Item.ItemsCount">
            <summary>Количество элементов данных</summary>
        </member>
        <member name="M:MathService.Values.CSV.Item.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.String},System.String[])">
            <summary>Новый элемент данных</summary>
            <param name="Header">Названия столбцов</param>
            <param name="Items">Элементы данных</param>
        </member>
        <member name="M:MathService.Values.CSV.Item.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathService.Values.CSV.Item.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathService.Values.CSV.Item.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="F:MathService.Values.CSV._FileName">
            <summary>Имя файла</summary>
        </member>
        <member name="F:MathService.Values.CSV._Separator">
            <summary>Символ-разделитель</summary>
        </member>
        <member name="F:MathService.Values.CSV._SkipFirstLines">
            <summary>Количество пропускаемых первых строк файла</summary>
        </member>
        <member name="F:MathService.Values.CSV._HeaderLine">
            <summary>Считывать строку заголовков</summary>
        </member>
        <member name="F:MathService.Values.CSV._SkipEmptyLines">
            <summary>Пропускать пустые строки</summary>
        </member>
        <member name="F:MathService.Values.CSV._Encoding">
            <summary>Кодировка файла</summary>
        </member>
        <member name="M:MathService.Values.CSV.#ctor(System.String,System.Char,System.Int32,System.Boolean,System.Boolean,System.Text.Encoding)">
            <summary>Новый файл данных, разделённых запятой</summary>
            <param name="FileName">Имя файла данных</param>
            <param name="Separator">Символ-разделитель</param>
            <param name="SkipFirstLines">Количество пропускаемых строк в начале файла</param>
            <param name="HeaderLine">Считывать ли заголовок</param>
            <param name="SkipEmptyLines">Пропускать пустые строки</param>
            <param name="Encoding">Кодировка файла (если не указана, используется <see cref="!:Encoding.UTF8S"/>)</param>
        </member>
        <member name="M:MathService.Values.CSV.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathService.Values.CSV.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathService.Values.IResetable">
            <summary>Объект, позволяющий осуществлять сброс своего состояния</summary>
        </member>
        <member name="M:MathService.Values.IResetable.Reset">
            <summary>Сброс состояния</summary>
        </member>
        <member name="T:MathService.Values.IValue`1">
            <summary>Объект, позволяющий читать и устанавливать значение</summary>
            <typeparam name="T">Тип значения объекта</typeparam>
        </member>
        <member name="P:MathService.Values.IValue`1.Value">
            <summary>Значение объекта</summary>
        </member>
        <member name="T:MathService.Values.IValueRead`1">
            <summary>Объект, обладающий значением</summary>
            <typeparam name="T">Тип значения объекта</typeparam>
        </member>
        <member name="P:MathService.Values.IValueRead`1.Value">
            <summary>Значение объекта</summary>
        </member>
        <member name="T:MathService.Values.IValueWrite`1">
            <summary>Объект, позволяющий определять значение</summary>
            <typeparam name="T">Тип значений объекта</typeparam>
        </member>
        <member name="P:MathService.Values.IValueWrite`1.Value">
            <summary>Значение объекта</summary>
        </member>
        <member name="T:MathService.Values.LazyValue`1">
            <summary>"Ленивое" значение</summary>
            <typeparam name="T">Тип значения</typeparam>
        </member>
        <member name="F:MathService.Values.LazyValue`1._Initializator">
            <summary>Инициализатор значения</summary>
        </member>
        <member name="F:MathService.Values.LazyValue`1._Value">
            <summary>Значение</summary>
        </member>
        <member name="F:MathService.Values.LazyValue`1._LockObject">
            <summary>Объект кросспоточной блокировки</summary>
        </member>
        <member name="F:MathService.Values.LazyValue`1._Initialized">
            <summary>Флаг инициализации</summary>
        </member>
        <member name="P:MathService.Values.LazyValue`1.Initialized">
            <summary>Признак инициализации</summary>
        </member>
        <member name="P:MathService.Values.LazyValue`1.Value">
            <summary>Значение</summary>
        </member>
        <member name="M:MathService.Values.LazyValue`1.#ctor(System.Func{`0})">
            <summary>Создание нового "ленивого" значения</summary>
            <param name="Initializator">Инициализатор значения</param>
        </member>
        <member name="M:MathService.Values.LazyValue`1.Initialize(System.Func{`0})">
            <summary>Инициализация "ленивого" значения</summary>
            <param name="Initializator">Инициализатор</param>
        </member>
        <member name="M:MathService.Values.LazyValue`1.System#IInitializable#Initialize">
            <summary>Невный вызов метода инициализации для интерфейса IInitializable</summary>
        </member>
        <member name="M:MathService.Values.LazyValue`1.Reset">
            <summary>Сброс состояния</summary>
        </member>
        <member name="M:MathService.Values.LazyValue`1.op_Implicit(MathService.Values.LazyValue{`0})~`0">
            <summary>Оператор неявного преобразования "ленивого" значения в обычное</summary>
            <param name="value">"Ленивое" значение</param>
            <returns>Обычное значение, получаемое при вычислении "ленивого" значения</returns>
        </member>
        <member name="M:MathService.Values.LazyValue`1.op_Implicit(System.Func{`0})~MathService.Values.LazyValue{`0}">
            <summary>Оператор неявного преобразования метода инициализации в "ленивое значение"</summary>
            <param name="Initializator">Метод инициализации "ленивого" значения</param>
            <returns>"Ленивое" значение с указанным методом инициализации</returns>
        </member>
        <member name="T:MathService.Values.LinearQueue`1">
            <summary>
            Очередь с линейным доступом
            </summary>
            <typeparam name="T">Тип элементов очереди</typeparam>
        </member>
        <member name="T:MathService.Values.MaxValue">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:MathService.Values.MaxValue.Value">
            <summary>Минимальное значение</summary>
        </member>
        <member name="M:MathService.Values.MaxValue.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathService.Values.MaxValue"/></summary>
        </member>
        <member name="M:MathService.Values.MaxValue.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathService.Values.MaxValue"/></summary>
            <param name="StartValue">Начальное значение</param>
        </member>
        <member name="M:MathService.Values.MaxValue.AddValue(System.Double)">
            <summary>Добавить новое значение</summary>
            <param name="value">Добавляемое значение</param>
            <returns>Истина, если добавляемое значение является максимальным</returns>
        </member>
        <member name="M:MathService.Values.MaxValue.Reset">
            <summary>Сбросить состояние минимального значения</summary>
        </member>
        <member name="M:MathService.Values.MaxValue.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathService.Values.MaxValue.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathService.Values.MaxValue.ToString(System.String)">
            <summary>Возвращает форматированную строку значения </summary>
            <param name="FormatString">Формат значения</param>
            <returns>Форматированная строка значения</returns>
        </member>
        <member name="M:MathService.Values.MaxValue.op_Implicit(MathService.Values.MaxValue)~System.Double">
            <summary>Оператор неявного приведения типа <see cref="T:MathService.Values.MaxValue"/> к <see cref="T:System.Double"/></summary>
            <param name="MaxValue">Максимальное значение значение</param>
        </member>
        <!-- Проигнорирован некорректный комментарий XML для члена "T:MathService.Values.ObjectSelector`1" -->
        <member name="F:MathService.Values.ObjectSelector`1._Selector">
            <summary>Метод выбора одного из значений ряда источников объектов</summary>
        </member>
        <member name="F:MathService.Values.ObjectSelector`1._Values">
            <summary>Массив "ленивых" значений, используемиых в качестве генераторов объектов </summary>
        </member>
        <member name="F:MathService.Values.ObjectSelector`1._CanRead">
            <summary>Метод, определяющий возможность чтения данных из источников</summary>
        </member>
        <member name="P:MathService.Values.ObjectSelector`1.Value">
            <summary>Очередное значение из вектора генераторов значений</summary>
        </member>
        <member name="P:MathService.Values.ObjectSelector`1.CanRead">
            <summary>Признак возможности чтения объекта</summary>
        </member>
        <member name="M:MathService.Values.ObjectSelector`1.#ctor(System.Func{`0[],System.Int32},System.Func{System.Boolean},System.Func{`0}[])">
            <summary>Новый генератор последовательности объектов из источника параллельных значений</summary>
            <param name="Selector">Метод выбора значения</param>
            <param name="CanRead">Метод определения возможности чтения значения</param>
            <param name="Generator">Массив генераторов объектов "ленивых" значений</param>
        </member>
        <member name="M:MathService.Values.ObjectSelector`1.#ctor(System.Func{`0[],System.Int32},System.Func{System.Boolean},System.Collections.Generic.IEnumerable{System.Func{`0}})">
            <summary>Новый генератор последовательности объектов из источника параллельных значений</summary>
            <param name="Selector">Метод выбора значения</param>
            <param name="CanRead">Метод определения возможности чтения значения</param>
            <param name="GeneratorsEnum">Массив генераторов объектов "ленивых" значений</param>
        </member>
        <member name="T:MathService.Values.SetOf`1">
            <summary>Множество объектов типа <typeparamref name="T"/></summary>
            <typeparam name="T">Тип элементов множества</typeparam>
        </member>
        <member name="P:MathService.Values.SetOf`1.Mixed">
            <summary>Перемешивать содержимое при выдаче массива элементов</summary>
        </member>
        <member name="F:MathService.Values.SetOf`1._List">
            <summary>Список элементов</summary>
        </member>
        <member name="P:MathService.Values.SetOf`1.Power">
            <summary>Мощность множества</summary>
        </member>
        <member name="M:MathService.Values.SetOf`1.#ctor">
            <summary>Новое множество элементов</summary>
        </member>
        <member name="M:MathService.Values.SetOf`1.#ctor(System.Int32)">
            <summary>Новое множество элементов</summary>
            <param name="Capacity">Ёмкость множества</param>
        </member>
        <member name="M:MathService.Values.SetOf`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Новое множество элементов</summary>
            <param name="collection">Коллекция элементов</param>
        </member>
        <member name="M:MathService.Values.SetOf`1.#ctor(`0[])">
            <summary>Новое множество элементов</summary>
            <param name="element">Элементы множества</param>
        </member>
        <member name="M:MathService.Values.SetOf`1.ToList">
            <summary>Преобразование в список</summary>
            <returns>Список элементов</returns>
        </member>
        <member name="M:MathService.Values.SetOf`1.ToArray">
            <summary>Преобразование множества элементов в массив</summary>
            <returns>Массив элементов</returns>
        </member>
        <member name="M:MathService.Values.SetOf`1.Clone">
            <summary>Клонирование множества элементов</summary>
            <returns></returns>
        </member>
        <member name="M:MathService.Values.SetOf`1.GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции.</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathService.Values.SetOf`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathService.Values.SetOf`1.Add(`0)">
            <summary>Добавляет элемент в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <param name="item">Объект, добавляемый в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathService.Values.SetOf`1.Clear">
            <summary>Удаляет все элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения. </exception>
        </member>
        <member name="M:MathService.Values.SetOf`1.Contains(`0)">
            <summary>
            Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:MathService.Values.SetOf`1.System#Collections#Generic#ICollection{T}#CopyTo(`0[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">
            Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. 
            Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.
            </param>
            <param name="arrayIndex">
            Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.
            </param>
            <exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex"/> меньше 0.</exception>
            <exception cref="T:System.ArgumentException">
            Массив <paramref name="array"/> является многомерным.
              -или- Значение индекса массива <paramref name="arrayIndex"/> больше или равно длине массива <paramref name="array"/>.
              -или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="arrayIndex"/> и до конца массива назначения <paramref name="array"/>.
              -или-Тип не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.
            </exception>
        </member>
        <member name="M:MathService.Values.SetOf`1.Remove(`0)">
            <summary>
            Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathService.Values.SetOf`1.System#Collections#Generic#ICollection{T}#Count">
            <summary>
            Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:MathService.Values.SetOf`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Получает значение, указывающее, доступен ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> только для чтения.
            </summary>
            <returns>
            Значение true, если интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения, в противном случае — значение false.
            </returns>
        </member>
        <member name="T:MathService.Values.StatisticValue">
            <summary>Статистическая информация о значении</summary>
        </member>
        <member name="F:MathService.Values.StatisticValue._Average">
            <summary>Среднее значение</summary>
        </member>
        <member name="F:MathService.Values.StatisticValue._Average2">
            <summary>Среднее значение квадрата величины</summary>
        </member>
        <member name="F:MathService.Values.StatisticValue._MinMax">
            <summary>Диапазон значений</summary>
        </member>
        <member name="P:MathService.Values.StatisticValue.M">
            <summary>Математическое ожидание величины</summary>
        </member>
        <member name="P:MathService.Values.StatisticValue.D">
            <summary>Дисперсия</summary>
        </member>
        <member name="P:MathService.Values.StatisticValue.MinMax">
            <summary>Интервал значений, в который попадает величина</summary>
        </member>
        <member name="P:MathService.Values.StatisticValue.Count">
            <summary>Размер выборки</summary>
        </member>
        <member name="M:MathService.Values.StatisticValue.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathService.Values.StatisticValue"/></summary>
            <param name="Length">Требуемый размер выборки</param>
        </member>
        <member name="M:MathService.Values.StatisticValue.AddValue(System.Double)">
            <summary>Добавить значение к оценке статистики</summary>
            <param name="x">Добавляемое значение</param>
        </member>
        <member name="M:MathService.Values.StatisticValue.AddEnumerable(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Добавить перечисление объектов к оценке статистики</summary>
            <param name="collection">Добавляемая последовательность значений</param>
        </member>
        <member name="M:MathService.Values.StatisticValue.Reset">
            <summary>Сбросить состояние оценки</summary>
        </member>
        <member name="M:MathService.Values.StatisticValue.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathService.Values.StreamDataSpeedValue">
            <summary>Измеритель скорости потока данных</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue.__DataNames">
            <summary>Названия скоростей</summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.Now">
            <summary>Текущее время</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue._AverageValue">
            <summary>Значение, усреднённое во времени</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue._DataStream">
            <summary>Поток данных</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue._LastPosition">
            <summary>Последнее положение в потоке денных</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue._LastTime">
            <summary>Последнее время</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue._Round">
            <summary>Количество знаков после запятой в строковом представлении</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue._LastSpeedValue">
            <summary>Последнее зафиксированное значение скорости</summary>
        </member>
        <member name="F:MathService.Values.StreamDataSpeedValue._SpeedCheckTimeout">
            <summary>Минимально допустимый интервал времени в секундах для проверки значения скорости</summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.Round">
            <summary>Количество знаков после запятой в строковом представлении</summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.Value">
            <summary>Мгновенное значение скорости</summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.AverageValue">
            <summary>Усреднённое значение скорости</summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.SpeedStr">
            <summary>Строковое представление скорости</summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.AverageTau">
            <summary>Постоянная времени усреднения </summary>
        </member>
        <member name="P:MathService.Values.StreamDataSpeedValue.SpeedCheckTimeout">
            <summary>Минимально домустимый интервал времени проверки скорости</summary>
        </member>
        <member name="M:MathService.Values.StreamDataSpeedValue.#ctor(System.IO.Stream)">
            <summary>Новый измеритель скорости потока данных</summary>
            <param name="DataStream">Поток данных для измерения</param>
            <exception cref="T:System.ArgumentNullException">Исключение возникает при нуливой ссылке на поток данных</exception>
        </member>
        <member name="M:MathService.Values.StreamDataSpeedValue.Reset">
            <summary>Сброс измерителя: установка стартового значения положения в потоке, сброс усреднителя</summary>
        </member>
        <member name="M:MathService.Values.StreamDataSpeedValue.CheckSpeed">
            <summary>Получить измерение скорости</summary>
            <returns>Мгновенная измеренная скорость перемещения в потоке</returns>
        </member>
        <member name="M:MathService.Values.StreamDataSpeedValue.op_Implicit(MathService.Values.StreamDataSpeedValue)~System.Double">
            <summary>Неявное преобразование измерителя скорости к значению скорости (усреднённому)</summary>
            <param name="speed">Измеритель скорости</param>
            <returns>Значение скосроти</returns>
        </member>
        <member name="M:MathService.Values.TimeAverage2Value.Add(System.Double)">
            <summary>Добавить значение</summary><param name="value">Значение</param>
        </member>
        <member name="T:MathService.Values.MinMaxValue">
            <summary>Объект, отслеживающий минимальное и максимальное значение входящей величины</summary>
        </member>
        <member name="F:MathService.Values.MinMaxValue._Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="F:MathService.Values.MinMaxValue._Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:MathService.Values.MinMaxValue.Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:MathService.Values.MinMaxValue.Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:MathService.Values.MinMaxValue.Interval">
            <summary>Интервал значений</summary>
        </member>
        <member name="M:MathService.Values.MinMaxValue.Reset">
            <inheritdoc />
        </member>
        <member name="M:MathService.Values.MinMaxValue.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathService.Values.MinMaxValue.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="T:MathService.Values.TimeAverageValue">
            <summary>Усредняемая по времени величина</summary>
        </member>
        <member name="F:MathService.Values.TimeAverageValue._LastTime">
            <summary>Последнее время доступа</summary>
        </member>
        <member name="F:MathService.Values.TimeAverageValue._Tau">
            <summary>Постоянная времени усреднения</summary>
        </member>
        <member name="P:MathService.Values.TimeAverageValue.Tau">
            <summary>Постоянная времени</summary>
        </member>
        <member name="P:MathService.Values.TimeAverageValue.Value">
            <summary>Значение</summary>
        </member>
        <member name="P:MathService.Values.TimeAverageValue.Initialized">
            <summary>Признак инициализации</summary>
        </member>
        <member name="M:MathService.Values.TimeAverageValue.#ctor(System.Double)">
            <summary>Усредняемая по времени величина</summary>
            <param name="tau">Постоянная времени усреднения >= 0</param>
        </member>
        <member name="M:MathService.Values.TimeAverageValue.#ctor(System.Double,System.Double)">
            <summary>Усредняемая по времени величина</summary>
            <param name="Value">Начальное значение</param><param name="tau">постоянная времени >= 0</param>
        </member>
        <member name="M:MathService.Values.TimeAverageValue.Add(System.Double)">
            <summary>Добавить значение</summary>
            <param name="value">Значение</param>
        </member>
        <member name="M:MathService.Values.TimeAverageValue.Reset">
            <summary>Сброс состояния</summary>
        </member>
        <member name="T:MathService.Values.AverageValue">
            <summary>Скользящее среднее</summary>
        </member>
        <member name="F:MathService.Values.AverageValue._N">
            <summary>Номер итерации усреднения</summary>
        </member>
        <member name="F:MathService.Values.AverageValue._Value">
            <summary>Текущее значение усредняемой величины</summary>
        </member>
        <member name="F:MathService.Values.AverageValue._StartValue">
            <summary>Начальное значение</summary>
        </member>
        <member name="F:MathService.Values.AverageValue._Length">
            <summary>Размер окна усреднеия</summary>
        </member>
        <member name="P:MathService.Values.AverageValue.StartValue">
            <summary>Начальное значение</summary>
        </member>
        <member name="P:MathService.Values.AverageValue.Length">
            <summary>Размер окна усреднения</summary>
        </member>
        <member name="P:MathService.Values.AverageValue.Value">
            <summary>Текущее значение усредняемой величины</summary>
        </member>
        <member name="P:MathService.Values.AverageValue.ValuesCount">
            <summary>Количество точек усреднения</summary>
        </member>
        <member name="M:MathService.Values.AverageValue.#ctor(System.Int32)">
            <summary>Инициализация нового скользящего среднего</summary>
            <param name="Length">Размер окна усреднения</param>
        </member>
        <member name="M:MathService.Values.AverageValue.#ctor(System.Double)">
            <summary>Инициализация нового скользящего среднего</summary>
            <param name="StartValue">Начальное значение для усреднения</param>
        </member>
        <member name="M:MathService.Values.AverageValue.#ctor(System.Double,System.Int32)">
            <summary>Инициализация нового скользящего среднего</summary>
            <param name="StartValue">Начальное значение</param>
            <param name="Length">Размер окна усреднения</param>
        </member>
        <member name="M:MathService.Values.AverageValue.AddValue(System.Double)">
            <summary>Добавить значение к усреднению</summary>
            <param name="value">Добавляемое значение</param>
        </member>
        <member name="M:MathService.Values.AverageValue.Reset">
            <summary>Сбросить состояние</summary>
        </member>
        <member name="M:MathService.Values.AverageValue.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Текстовое представление</returns>
        </member>
        <member name="M:MathService.Values.AverageValue.ToString(System.String)">
            <summary>Преобразование в строку с форматированием</summary>
            <param name="Format">Формат</param>
            <returns>Текстовое представление</returns>
        </member>
        <member name="M:MathService.Values.AverageValue.op_Implicit(MathService.Values.AverageValue)~System.Double">
            <summary>Оператор неявного приведения к типу вещественного числа</summary>
            <param name="Value">Усредняемое значение</param>
        </member>
        <member name="M:MathService.Values.AverageValue.op_Implicit(System.Double)~MathService.Values.AverageValue">
            <summary>ОПератор неявного приведнеия вещественного числа к скользящему среднему</summary>
            <param name="Data">Вещественное число</param>
        </member>
        <member name="M:MathService.Values.AverageValue.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Новая усредняемая величина</summary>
            <param name="info">Сериализационная информация</param>
            <param name="context">Контекст сериализации</param>
        </member>
        <member name="M:MathService.Values.AverageValue.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:MathService.Values.AverageValue.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Получить состояние объекта</summary>
            <param name="info">Объект сериализации</param>
            <param name="context">Конекст операции сериализации</param>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="info"/> == null</exception>
        </member>
        <member name="T:MathService.Values.MinValue">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:MathService.Values.MinValue.Value">
            <summary>Минимальное значение</summary>
        </member>
        <member name="M:MathService.Values.MinValue.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathService.Values.MinValue"/></summary>
        </member>
        <member name="M:MathService.Values.MinValue.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathService.Values.MinValue"/></summary>
            <param name="StartValue">Начальное значение</param>
        </member>
        <member name="M:MathService.Values.MinValue.AddValue(System.Double)">
            <summary>Добавить новое значение</summary>
            <param name="value">Добавляемое значение</param>
            <returns>Истина, если добавляемое значение является минимальным</returns>
        </member>
        <member name="M:MathService.Values.MinValue.Reset">
            <summary>Сбросить состояние минимального значения</summary>
        </member>
        <member name="M:MathService.Values.MinValue.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathService.Values.MinValue.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathService.Values.MinValue.ToString(System.String)">
            <summary>Возвращает форматированную строку значения </summary>
            <param name="FormatString">Формат значения</param>
            <returns>Форматированная строка значения</returns>
        </member>
        <member name="M:MathService.Values.MinValue.op_Implicit(MathService.Values.MinValue)~System.Double">
            <summary>Оператор неявного приведения типа <see cref="T:MathService.Values.MinValue"/> к <see cref="T:System.Double"/></summary>
            <param name="MinValue">Минимальное значение</param>
        </member>
        <member name="T:MathService.Vectors.SpaceAngle">
            <summary>Пространственный угол</summary>
        </member>
        <member name="F:MathService.Vectors.SpaceAngle.c_ToDeg">
            <summary>Константа преобразования угла в радианах в градусы</summary>
        </member>
        <member name="F:MathService.Vectors.SpaceAngle.c_ToRad">
            <summary>Константа преобразования угла в градусах в радианы</summary>
        </member>
        <member name="F:MathService.Vectors.SpaceAngle.pi">
            <summary>Число Пи</summary>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.Random(System.Double,System.Double)">
            <summary>Случайный пространственный угол</summary>
            <param name="Min">Минимальное значение угла</param>
            <param name="Max">Максимальное значение угла</param>
            <returns>Случайный пространственный угол</returns>
        </member>
        <member name="F:MathService.Vectors.SpaceAngle._AngleType">
            <summary>Тип угла</summary>
        </member>
        <member name="F:MathService.Vectors.SpaceAngle._Thetta">
            <summary>Угол места</summary>
        </member>
        <member name="F:MathService.Vectors.SpaceAngle._Phi">
            <summary>Угол азимута</summary>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.Thetta">
            <summary>Угол места</summary>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.Phi">
            <summary>Азимутальный угол в плоскости XOY</summary>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.ComplexCosThetta">
            <summary>Комплексное число, характеризующее действительной частью направляющий косинус <see cref="P:MathService.Vectors.SpaceAngle.Thetta"/>, мнимой частью - направляющий синус</summary>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.ComplexCosPhi">
            <summary>Комплексное число, характеризующее действительной частью направляющий косинус <see cref="P:MathService.Vectors.SpaceAngle.Phi"/>, мнимой частью - направляющий синус</summary>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.AngleType">
            <summary>Тип угла</summary>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.InDeg">
            <summary>Представление угла в градусах</summary>
            <exception cref="T:System.NotSupportedException" accessor="get">Неизвестный тип угла</exception>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.InRad">
            <summary>Представлкние угла в радианах</summary>
            <exception cref="T:System.NotSupportedException" accessor="get">Неизвестный тип угла</exception>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.#ctor(System.Double,System.Double)">
            <summary>Пространственный угол в радианах</summary>
            <param name="Thetta">Угол места [рад]</param>
            <param name="Phi">Азимутальный угол [рад]</param>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.#ctor(MathService.Vectors.SpaceAngle@,MathService.AngleType@)">
            <exception cref="T:System.NotSupportedException">Если AngleType != Deg || Rad - Неизвестный тип угла</exception>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.Rotate_PhiThetta(System.Double,System.Double,MathService.AngleType@)">
            <summary>Повернуть угол в сферической системе координат</summary>
            <param name="thetta">Угол места поворота локальной системы кординат</param>
            <param name="phi">Угол азимута поворота локальной системы координат</param>
            <param name="type">Тип значений угловых величин</param>
            <returns>Угол в повёрнутой локальной системе координат</returns>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.Rotate_PhiThetta(MathService.Vectors.SpaceAngle@)">
            <summary>Повернуть угол в сферической системе координат</summary>
            <param name="angle">Пространственный угол поворота локаьлной системы координат</param>
            <returns>Угол в повёрнутой локальной системе координат</returns>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.op_ExclusiveOr(System.Func{MathService.Vectors.SpaceAngle,System.Double},MathService.Vectors.SpaceAngle@)">
            <summary>Оператор поворота функции на пространственный угол</summary>
            <param name="f">Вещественная пространственная функция</param>
            <param name="a">Пространственный угол поворота</param>
            <returns>Вещественная функция, аргумент которой повёрнут на указанный пространственный угол</returns>
        </member>
        <member name="M:MathService.Vectors.SpaceAngle.op_ExclusiveOr(System.Func{MathService.Vectors.SpaceAngle,MathService.Complex},MathService.Vectors.SpaceAngle@)">
            <summary>Оператор поворота функции на пространственный угол</summary>
            <param name="f">Комплексная пространственная функция</param>
            <param name="a">Пространственный угол поворота</param>
            <returns>Комплексная функция, аргумент которой повёрнут на указанный пространственный угол</returns>
        </member>
        <member name="P:MathService.Vectors.SpaceAngle.ComparisonsAccuracy">
            <summary>Точность сравнения (по умолчанию 10^-13)</summary>
        </member>
        <member name="T:MathService.Vectors.Vector3D">
            <summary>Трёхмерный вектор</summary>
        </member>
        <member name="M:MathService.Vectors.Vector3D.Product_Scalar(MathService.Vectors.Vector3D)">
            <summary>Скалярное произведение векторов</summary>
            <param name="Vector">Вектор, на который домножается текущий вектор</param>
            <returns>Число, равное скалярному произведению векторов</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.Product_Mixed(MathService.Vectors.Vector3D,MathService.Vectors.Vector3D,MathService.Vectors.Vector3D)">
            <summary>Смешанное произведение трёх векторов</summary>
            <param name="A">Первый вектор произведения</param>
            <param name="B">Второй вектор произведения</param>
            <param name="C">Третий вектор произведения</param>
            <returns>Число, равное смешанному произведения векторов</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.Product_Vector(MathService.Vectors.Vector3D)">
            <summary>Векторное произведение векторов</summary>
            <param name="Vector">Вектор, на который домножается исходный вектор</param>
            <returns>Вектор, равный векторному произведению векторов</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.Product_Component(MathService.Vectors.Vector3D)">
            <summary>Покомпонентное домножение на вектор</summary>
            <param name="Vector">Векторный сомножитель</param>
            <returns>Вектор, компоненты которого являются произведениями компоненты векторов</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.GetAngle(MathService.Vectors.Vector3D)">
            <summary>Угол между векторами</summary>
            <param name="Vector">Вектор, к которорому вычисляется угол</param>
            <returns>Пространственный угол между векторами</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.GetProjectionTo(MathService.Vectors.Vector3D)">
            <summary>Проекция на вектор</summary>
            <param name="Vector">Вектор, НА который производится проекция</param>
            <returns>Проекция на вектор</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.GetProjectionTo(MathService.Vectors.SpaceAngle)">
            <summary>Проекция на наравление</summary>
            <param name="Direction">Направление, на которое проектируется вектор</param>
            <returns>Проекция вектора на направление</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.op_Multiply(MathService.Vectors.Vector3D,MathService.Vectors.Vector3D)">
            <summary>Скалярное произведение векторов</summary>
            <param name="A">Первый вектор-множитель</param>
            <param name="B">Второй вектор-множитель</param>
            <returns>Число - скалярное произведение векторов</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.op_ExclusiveOr(MathService.Vectors.Vector3D,MathService.Vectors.Vector3D)">
            <summary>Угол между векторами</summary>
            <param name="A">Вектор 1</param>
            <param name="B">Вектор 2</param>
            <returns>Угол между вектором А и вектором В в пространстве</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.op_BitwiseOr(MathService.Vectors.Vector3D,MathService.Vectors.Vector3D)">
            <summary>Проверка на параллельность</summary>
            <param name="A">Вектор 1</param><param name="B">Вектор 2</param>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.op_BitwiseAnd(MathService.Vectors.Vector3D,MathService.Vectors.Vector3D)">
            <summary>Проверка на ортогональность</summary>
            <param name="A">Вектор 1</param><param name="B">Вектор 2</param>
            <returns>Истина, если вектор 1 ортогонален вектору 2</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.op_Modulus(MathService.Vectors.Vector3D,MathService.Vectors.Vector3D)">
            <summary>Проекция вектора A на вектор B</summary>
            <param name="A">Проецируемый вектор</param>
            <param name="B">Вектор, на который производится проекция</param>
            <returns>Проекция вектора А на вектор В</returns>
        </member>
        <member name="M:MathService.Vectors.Vector3D.op_Modulus(MathService.Vectors.Vector3D,MathService.Vectors.SpaceAngle)">
            <summary>Проекция вектора на направление</summary>
            <param name="Vector">Проецируемый вектор</param>
            <param name="Direction">Пространственный угол направления проекции</param>
            <returns>Вещественное значение проекции</returns>
        </member>
        <member name="F:MathService.Vectors.Vector3D.BasysUnitVector">
            <summary>Единичный базисный вектор</summary>
        </member>
        <member name="F:MathService.Vectors.Vector3D.i">
            <summary>Базисный вектор i</summary>
        </member>
        <member name="F:MathService.Vectors.Vector3D.j">
            <summary>Базисный вектор j</summary>
        </member>
        <member name="F:MathService.Vectors.Vector3D.k">
            <summary>Базисный вектор k</summary>
        </member>
        <member name="F:MathService.Vectors.Vector3D._X">
            <summary>Длина по оси X</summary>
        </member>
        <member name="F:MathService.Vectors.Vector3D._Y">
            <summary>Длина по оси Y</summary>
        </member>
        <member name="F:MathService.Vectors.Vector3D._Z">
            <summary>Длина по оси Z</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.X">
            <summary>Длина по оси X</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.Y">
            <summary>Длина по оси Y</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.Z">
            <summary>Длина по оси Z</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.R">
            <summary>Длина вектора</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.AngleXOY">
            <summary>Угол проекции в плоскости XOY</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.AngleXOZ">
            <summary>Угол проекции в плоскости XOZ</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.AngleYOZ">
            <summary>Угол проекции в плоскости YOZ</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.Phi">
            <summary>Азимутальный угол</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.Thetta">
            <summary>Угол места</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.Angle">
            <summary>Пространственный угол</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.VectorXOY">
            <summary>Двумерный вектор - проекция в плоскости XOY</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.VectorXOZ">
            <summary>Двумерный вектор - проекция в плоскости XOZ (X->X; Z->Y)</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.VectorYOZ">
            <summary>Двумерный вектор - проекция в плоскости YOZ (Y->X; Z->Y)</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.R_XOY">
            <summary>Длина в плоскости XOY</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.R_XOZ">
            <summary>Длина в плоскости XOZ</summary>
        </member>
        <member name="P:MathService.Vectors.Vector3D.R_YOZ">
            <summary>Длина в плоскости YOZ</summary>
        </member>
        <member name="M:MathService.Vectors.Vector3D.System#ICloneable#Clone">
            <summary>Создает новый объект, который является копией текущего экземпляра.</summary>
            <returns>Новый объект, являющийся копией этого экземпляра.</returns><filterpriority>2</filterpriority>
        </member>
        <member name="P:MathService.Vectors.Vector3D.ComparisonsAccuracy">
            <summary>Точность сравнения (по умолчанию 10^-16)</summary>
        </member>
        <member name="T:MathService.Vectors.Vector2D">
            <summary>Двумерный вектор</summary>
        </member>
        <member name="F:MathService.Vectors.Vector2D._X">
            <summary>Координата X</summary>
        </member>
        <member name="F:MathService.Vectors.Vector2D._Y">
            <summary>Координата Y</summary>
        </member>
        <member name="P:MathService.Vectors.Vector2D.X">
            <summary>Координата X</summary>
        </member>
        <member name="P:MathService.Vectors.Vector2D.Y">
            <summary>Координата Y</summary>
        </member>
        <member name="P:MathService.Vectors.Vector2D.R">
            <summary>Радиус (длина) вектора</summary>
        </member>
        <member name="P:MathService.Vectors.Vector2D.Angle">
            <summary>Угол к оси X в радианах</summary>
        </member>
        <member name="M:MathService.Vectors.Vector2D.#ctor(System.Double,System.Double)">
            <summary>Инициализация двумерного вектора</summary>
            <param name="X">Координата X</param>
            <param name="Y">Координата Y</param>
        </member>
        <member name="M:MathService.Vectors.Vector2D.#ctor(MathService.Complex@)">
            <summary>Инициализация вектора по по комплексному числу</summary>
            <param name="Z">Комплексное число X + iY</param>
        </member>
        <member name="M:MathService.Vectors.Vector2D.InBasis(MathService.Vectors.Basis2D@)">
            <summary>Представление вектора в базисе</summary>
            <param name="b">Базис</param>
            <returns>Вектор в базисе</returns>
        </member>
        <member name="M:MathService.TypeConverter`2.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:MathService.ViewModels.ViewModel">
            <summary>Наблюдаемая модель</summary>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.PropertyChangingEventArgs`1.#ctor(`0,`0,System.String)">
            <inheritdoc />
        </member>
        <member name="E:MathService.ViewModels.ViewModel.PropertyChanged">
            <summary>Событие возникает когда изменяется значение свойства объекта</summary>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.PropertyChanged_AddHandler(System.ComponentModel.PropertyChangedEventHandler)">
            <summary>Присоединить обработчик события <see cref="E:MathService.ViewModels.ViewModel.PropertyChanged"/></summary>
            <param name="handler">Присоединяемый обработчик события <see cref="E:MathService.ViewModels.ViewModel.PropertyChanged"/></param>
        </member>
        <member name="F:MathService.ViewModels.ViewModel._PropertyChangedHandlers">
            <summary>Словарь обработчиков событий изменений свойств</summary>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.PropertyChanged_AddHandler(System.String,System.Action)">
            <summary>Добавление собработчика события изменения свойства</summary>
            <param name="PropertyName">Имя отслеживаемого события</param>
            <param name="handler">Устанавливаемый обработчик</param>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.PropertyChanged_RemoveHandler(System.String,System.Action)">
            <summary>Извлечение обработчика события изменния указанного свойства</summary>
            <param name="PropertyName">Имя отслеживаемого свойства</param>
            <param name="handler">Извлекаемый обработчик события</param>
            <returns>Истина, если обработчик события удалён успешно</returns>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.PropertyChanged_ClearHandlers(System.String)">
            <summary>Очистка обработчиков изменений свойства</summary>
            <returns>Истина, если очистка произведена успешно</returns>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.PropertyChanged_ClearHandlers">
            <summary>Очистка обработчиков изменений всех свойств</summary>
            <returns>Истина, если очистка произведена успешно</returns>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.PropertyChanged_RemoveHanddler(System.ComponentModel.PropertyChangedEventHandler)">
            <summary>Отсоединить обработчик события <see cref="E:MathService.ViewModels.ViewModel.PropertyChanged"/></summary>
            <param name="handler">Отсоединяемый обработчик события <see cref="E:MathService.ViewModels.ViewModel.PropertyChanged"/></param>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.GetPropertyChangedObservers``1">
            <summary>Получить перечисление всех объектов, подписанных на событие <see cref="E:MathService.ViewModels.ViewModel.PropertyChanged"/></summary>
            <typeparam name="T">Тип интересующих объектов</typeparam>
            <returns></returns>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.GetPropertyChangedObserversMethods">
            <summary>Получить перечисление всех методов, подписанных на событие <see cref="E:MathService.ViewModels.ViewModel.PropertyChanged"/></summary>
            <returns>Перечисление всех методов-подписчиков события <see cref="E:MathService.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.GetPropertyChangedObserversMethods``1">
            <summary>Получить перечисление всех методов, подписанных на событие <see cref="E:MathService.ViewModels.ViewModel.PropertyChanged"/></summary>
            <typeparam name="T">Тип интересующих объектов</typeparam>
            <returns>Перечисление всех методов-подписчиков события <see cref="E:MathService.ViewModels.ViewModel.PropertyChanged"/> для объекта типа <typeparamref name="T"/></returns>
        </member>
        <member name="F:MathService.ViewModels.ViewModel._PropertiesDependencesDictionary">
            <summary>Словарь графа зависимости изменений свйоств</summary>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.PropertyDependence_Add(System.String,System.String[])">
            <summary>Добавить зависимости между свйоствами</summary>
            <param name="PropertyName">Имя исходного свйоства</param>
            <param name="Dependences">Перечисление свйоств, на которые исходное свойство имеет влияние</param>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.IsLoopDependency(System.String,System.String,System.String,System.Collections.Generic.Stack{System.String})">
            <summary>Проверка модели на циклические зависимости между свойствами</summary>
            <param name="property">Проверяемое свойство</param>
            <param name="next_property">Следующее свойство в цепочке зависимости</param>
            <returns>Истина, если найден цикл</returns>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.PropertyDependences_Remove(System.String,System.String)">
            <summary>Удаление зависимости между свйоствами</summary>
            <param name="PropertyName">Исходное свойство</param>
            <param name="Dependence">Свйоство, связь с которым надо разорвать</param>
            <returns>Истина, если связь успено удалена, ложь - если связь отсутствовала</returns>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.PropertyDependences_Clear(System.String)">
            <summary>Очистить граф зависимостей между свйоствами для указанного свйоства</summary>
            <param name="PropertyName">Название свйоства, связи которого нао удалить</param>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения значения свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="F:MathService.ViewModels.ViewModel._PropertyAsyncInvokeTime">
            <summary>Словарь, хранящий время последней генерации события изменения указанного свйоства в асинхронном режиме</summary>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.OnPropertyChangedAsync(System.String,System.Int32,System.Action,System.Action)">
            <summary>Асинхронная генерация события изменения свойства с возможностью указания таймаута ожидания повторных изменений</summary>
            <param name="PropertyName">Имя свйоства</param>
            <param name="Timeout">Таймаут ожидания повторных изменений, прежде чем событие будет сгенерировано</param>
            <param name="OnChanging">Метод, выполняемый до генерации события</param>
            <param name="OnChanged">Метод, выполняемый после генерации события</param>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.#ctor(System.Boolean)">
            <summary>Инициализация новой view-модели</summary>
            <param name="check_dependences">Создавать карту зависимостей на основе атрибутов</param>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.Set``1(``0@,``0,System.String)">
            <summary>Установить значение поля модели, в котором хранится значение изменяющегося свойства</summary>
            <typeparam name="T">Тип значения поля</typeparam>
            <param name="field">Ссылка на поле модели</param>
            <param name="value">Значение, устанавливаемое для поля</param>
            <param name="PropertyName">Имя метода, вызывавшего обновление. По умолчанию должно быть равно пустоте</param>
            <returns>Истина, если метод изменил значение поля и вызвал событие <see cref="E:MathService.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.Set``1(``0@,``0,System.Func{``0,System.Boolean},System.String)">
            <summary>Установить значение поля модели, в котором хранится значение изменяющегося свойства</summary>
            <typeparam name="T">Тип значения поля</typeparam>
            <param name="field">Ссылка на поле модели</param>
            <param name="value">Значение, устанавливаемое для поля</param>
            <param name="value_check">Метод определения области допустимых значений (должен вернуть истину для корректного значения)</param>
            <param name="PropertyName">Имя метода, вызывавшего обновление. По умолчанию должно быть равно пустоте</param>
            <returns>Истина, если метод изменил значение поля и вызвал событие <see cref="E:MathService.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.Set``1(``0@,``0,System.Func{``0,System.Boolean},System.String,System.String)">
            <summary>Установить значение поля модели, в котором хранится значение изменяющегося свойства</summary>
            <typeparam name="T">Тип значения поля</typeparam>
            <param name="field">Ссылка на поле модели</param>
            <param name="value">Значение, устанавливаемое для поля</param>
            <param name="value_check">Метод определения области допустимых значений (должен вернуть истину для корректного значения)</param>
            <param name="ErrorMessage">Сообщение, записываемое в генерируемое исключение <see cref="T:System.ArgumentOutOfRangeException"/> в случае если проверка <paramref name="value_check"/> не пройдена</param>
            <param name="PropertyName">Имя метода, вызывавшего обновление. По умолчанию должно быть равно пустоте</param>
            <returns>Истина, если метод изменил значение поля и вызвал событие <see cref="E:MathService.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.Set``1(``0@,``0,System.Action{System.String},System.String)">
            <summary>Метод установки значения свйоства, осуществляющий генерацию события изменения свйоства</summary>
            <typeparam name="T">Тип знначения свйоства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свйоства</param>
            <param name="value">Значение свйоства, которое надо установить</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Истина, если значение свйоства установлено успешно</returns>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.Set``1(``0@,``0,System.Action{System.String},System.Func{``0,System.Boolean},System.String)">
            <summary>Метод установки значения свйоства, осуществляющий генерацию события изменения свйоства</summary>
            <typeparam name="T">Тип знначения свйоства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свйоства</param>
            <param name="value">Значение свйоства, которое надо установить</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Истина, если значение свйоства установлено успешно</returns>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.Dispose">
            <inheritdoc />
        </member>
        <member name="F:MathService.ViewModels.ViewModel._Disposed">
            <summary>Признак того, что объект уже уничтожен</summary>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов</summary>
            <param name="disposing">Если истина, то требуется освободить управляемые объекты. Освободить неуправляемыые объекты в любом случае</param>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.DisposeManagedObject">
            <summary>Освободить управляемые объекты</summary>
        </member>
        <member name="M:MathService.ViewModels.ViewModel.DisposeUnmanagedObject">
            <summary>Освободить неуправляемые объекты</summary>
        </member>
        <member name="T:MathService.XmInitializer`1">
            <summary>Инициализатор объекта по структуре xml-файла</summary>
            <typeparam name="TObject">Тип инициализируемого объекта</typeparam>
        </member>
        <member name="T:MathService.XmInitializer`1.Rule">
            <summary>Правило инициализации</summary>
        </member>
        <member name="F:MathService.XmInitializer`1.Rule._XPath">
            <summary>XPath-выражение - путь в структуре xml</summary>
        </member>
        <member name="F:MathService.XmInitializer`1.Rule._PropertyBody">
            <summary>Выражение, применяемое при обнаружении значения указанного XPath-пути</summary>
        </member>
        <member name="F:MathService.XmInitializer`1.Rule._Update">
            <summary>Скомпилированный метод инициализации</summary>
        </member>
        <member name="P:MathService.XmInitializer`1.Rule.UpdateExpression">
            <summary>Выражение, применяемое при обнаружении значения указанного XPath-пути</summary>
        </member>
        <member name="P:MathService.XmInitializer`1.Rule.XPath">
            <summary>XPath-выражение - путь в структуре xml</summary>
        </member>
        <member name="P:MathService.XmInitializer`1.Rule.Update">
            <summary>Скомпилированный метод инициализации</summary>
        </member>
        <member name="M:MathService.XmInitializer`1.Rule.#ctor(System.String,System.Linq.Expressions.Expression{System.Action{`0,System.String}},System.Boolean)">
            <summary>Инициализация нового правила</summary>
            <param name="XPath">XPath-путь в структуре xml</param>
            <param name="Expression">Выражение инициализации</param>
        </member>
        <member name="M:MathService.XmInitializer`1.Rule.Execute(`0,System.Xml.Linq.XElement,System.Xml.IXmlNamespaceResolver)">
            <summary>Выполнить инициализацию</summary>
            <param name="obj">Инициализируемый объект</param>
            <param name="e">Корень структуры xml</param>
            <param name="ns">Описание пространств имён</param>
        </member>
        <member name="M:MathService.XmInitializer`1.Rule.Execute(System.Xml.Linq.XElement,System.Xml.IXmlNamespaceResolver)">
            <summary>Выполнить инициализацию</summary>
            <param name="e">Корень структуры xml</param>
            <param name="ns">Описание пространств имён</param>
        </member>
        <member name="T:MathService.XmInitializer`1.Rule`1">
            <summary>Типизированное правило инициализации</summary>
            <typeparam name="TValue">Тип значения инициализируемого параметра объекта</typeparam>
        </member>
        <member name="M:MathService.XmInitializer`1.Rule`1.GetExpression(System.Linq.Expressions.Expression{System.Func{`0,`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Получить выражение инициализации для выражения определения свойства</summary>
            <param name="expression">Выражение определения инициализируемого параметра объекта</param>
            <param name="converter">Выражение преобразования строки в тип объекта</param>
            <returns>Выражение инициализации, как процедура с параметром - объектом и строкой xml-узла</returns>
        </member>
        <member name="M:MathService.XmInitializer`1.Rule`1.GetExpression(System.Linq.Expressions.Expression{System.Action{`0,`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Получить выражение инициализации объекта по выражению инициализации и выражению конвертера</summary>
            <param name="expression">Выражение инициализации</param>
            <param name="converter">Конвертер преобразования строки в нужный тип данных</param>
            <returns>Выражение инициализации объекта по строке xml-структуры</returns>
        </member>
        <member name="M:MathService.XmInitializer`1.Initialize(`0,System.Xml.XmlReader)">
            <devdoc>
                <para>
                    Gets the type of the current node.
                </para>
            </devdoc>
        </member>
        <member name="M:MathService.XmInitializer`1.Add``1(System.String,System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{System.String,``0}})">
            <summary>Добавить правило с указанием выражения получения члена объекта</summary>
            <typeparam name="TPropertyValue">Тип значения свойства</typeparam>
            <param name="path">Путь в xml-структуре</param>
            <param name="expr">Выражение, определяющее член объекта</param>
            <param name="conv">Выражение преобразования строки в целевой тип данных</param>
        </member>
        <member name="M:System.ActionsCollectionProcessor.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="T:System.AffectsTheAttribute">
            <summary>Влияние на</summary>
        </member>
        <member name="P:System.AffectsTheAttribute.Name">
            <summary>Элемент, на который оказывается влияние</summary>
        </member>
        <member name="M:System.AffectsTheAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.AffectsTheAttribute"/></summary>
        </member>
        <member name="M:System.AffectsTheAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.AffectsTheAttribute"/></summary>
            <param name="Name">Имя элемента, на что помеченный элемент оказывает влияние</param>
        </member>
        <member name="T:System.ChangedHandlerAttribute">
            <summary>Указывает процедуру без параметров, определённую в классе, которая должна быть вызвана после изменения значения свойства</summary>
        </member>
        <member name="P:System.ChangedHandlerAttribute.MethodName">
            <summary>Имя метода-реакции на изменение значения свойства</summary>
        </member>
        <member name="M:System.ChangedHandlerAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.DependencyOnAttribute"/></summary>
        </member>
        <member name="M:System.ChangedHandlerAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.DependencyOnAttribute"/></summary>
            <param name="MethodName">Имя метода-реакции на изменение значения свойства</param>
        </member>
        <member name="T:System.DependencyOnAttribute">
            <summary>Зависимость от</summary>
        </member>
        <member name="P:System.DependencyOnAttribute.Name">
            <summary>Элемент, от которого существует зависимость</summary>
        </member>
        <member name="M:System.DependencyOnAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.DependencyOnAttribute"/></summary>
        </member>
        <member name="M:System.DependencyOnAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.DependencyOnAttribute"/></summary>
            <param name="Name">Имя элемента, от которого зависит помеченный элемент</param>
        </member>
        <member name="T:System.dValueAttribute">
            <summary>Допустимая величина изменения значения</summary>
        </member>
        <member name="P:System.dValueAttribute.dV">
            <summary>Допустимая величина изменения значения</summary>
        </member>
        <member name="M:System.dValueAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.dValueAttribute"/></summary>
        </member>
        <member name="M:System.dValueAttribute.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:System.dValueAttribute"/></summary>
            <param name="dV">Допустимая величина изменения значения</param>
        </member>
        <member name="T:System.IntervalValueAttribute">
            <summary>Допустимый интервал значений</summary>
        </member>
        <member name="P:System.IntervalValueAttribute.Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:System.IntervalValueAttribute.Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:System.IntervalValueAttribute.Interval">
            <summary>Допустимый интервал значений</summary>
        </member>
        <member name="M:System.IntervalValueAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.IntervalValueAttribute"/></summary>
        </member>
        <member name="M:System.IntervalValueAttribute.#ctor(MathService.Interval)">
            <summary>Инициализация нового экземпляра <see cref="T:System.IntervalValueAttribute"/></summary>
            <param name="Interval">Допустимый интервал значений</param>
        </member>
        <member name="M:System.IntervalValueAttribute.#ctor(System.Double,System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:System.IntervalValueAttribute"/></summary>
            <param name="Min">Минимально допустимое значение</param>
            <param name="Max">Максимально допустимое значение</param>
        </member>
        <member name="T:System.LessOrEqualAttribute">
            <summary>Значение должно быть больше, либо равно</summary>
        </member>
        <member name="F:System.LessOrEqualAttribute._Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="P:System.LessOrEqualAttribute.Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="M:System.LessOrEqualAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.LessOrEqualAttribute"/></summary>
        </member>
        <member name="M:System.LessOrEqualAttribute.#ctor(System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.LessOrEqualAttribute"/></summary>
            <param name="Value">Пороговое значение</param>
        </member>
        <member name="M:System.LessOrEqualAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.LessThenAttribute">
            <summary>Значение должно быть больше, чем</summary>
        </member>
        <member name="P:System.LessThenAttribute.Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="M:System.LessThenAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.LessThenAttribute"/></summary>
        </member>
        <member name="M:System.LessThenAttribute.#ctor(System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.LessThenAttribute"/></summary>
            <param name="Value">Максимально допустимое значение</param>
        </member>
        <member name="M:System.LessThenAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.MaxValueAttribute">
            <summary>Максимально допустимое значение</summary>
        </member>
        <member name="P:System.MaxValueAttribute.Value">
            <summary>Максимально допустимое значение</summary>
        </member>
        <member name="M:System.MaxValueAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.MaxValueAttribute"/></summary>
        </member>
        <member name="M:System.MaxValueAttribute.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:System.MaxValueAttribute"/></summary>
            <param name="Value">Максимально допустимое значение</param>
        </member>
        <member name="T:System.MinValueAttribute">
            <summary>Минимально допустимое значение</summary>
        </member>
        <member name="P:System.MinValueAttribute.Value">
            <summary>Минимально допустимое значение</summary>
        </member>
        <member name="M:System.MinValueAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.MinValueAttribute"/></summary>
        </member>
        <member name="M:System.MinValueAttribute.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:System.MinValueAttribute"/></summary>
            <param name="Value">Минимально допустимое значение</param>
        </member>
        <member name="T:System.GreaterOrEqualAttribute">
            <summary>Значение должно быть больше, либо равно</summary>
        </member>
        <member name="F:System.GreaterOrEqualAttribute._Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="P:System.GreaterOrEqualAttribute.Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="M:System.GreaterOrEqualAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterOrEqualAttribute"/></summary>
        </member>
        <member name="M:System.GreaterOrEqualAttribute.#ctor(System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterOrEqualAttribute"/></summary>
            <param name="Value">Пороговое значение</param>
        </member>
        <member name="M:System.GreaterOrEqualAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.GreaterThenAttribute">
            <summary>Значение должно быть больше, чем</summary>
        </member>
        <member name="F:System.GreaterThenAttribute._Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="P:System.GreaterThenAttribute.Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="M:System.GreaterThenAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterThenAttribute"/></summary>
        </member>
        <member name="M:System.GreaterThenAttribute.#ctor(System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterThenAttribute"/></summary>
            <param name="Value">Максимально допустимое значение</param>
        </member>
        <member name="M:System.GreaterThenAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.NotSupportedAttribute">
            <summary>Атрибут признака неподдерживаемости</summary>
        </member>
        <member name="P:System.NotSupportedAttribute.Message">
            <summary>Сообщение</summary>
        </member>
        <member name="M:System.NotSupportedAttribute.#ctor">
            <summary>Новый атрибут неподдерживаемости</summary>
        </member>
        <member name="M:System.NotSupportedAttribute.#ctor(System.String)">
            <summary>Новый атрибут неподдерживаемости</summary>
            <param name="Message">Сообщение (почему не поддерживается?)</param>
        </member>
        <member name="M:System.NotSupportedAttribute.IsDefaultAttribute">
            <summary>Признак атрибута "по умолчанию"</summary>
            <returns>Истина, если указан незаполненный атрибут</returns>
        </member>
        <member name="T:System.RegexPatternAttribute">
            <summary>Является регулярным выражением</summary>
        </member>
        <member name="T:System.ValueBetweenAttribute">
            <summary>Значение должно быть в диапазоне значений</summary>
        </member>
        <member name="F:System.ValueBetweenAttribute._Min">
            <summary>Инжнее пороговое значение</summary>
        </member>
        <member name="F:System.ValueBetweenAttribute._Max">
            <summary>Инжнее пороговое значение</summary>
        </member>
        <member name="P:System.ValueBetweenAttribute.Min">
            <summary>Инжнее пороговое значение</summary>
        </member>
        <member name="P:System.ValueBetweenAttribute.Max">
            <summary>Инжнее пороговое значение</summary>
        </member>
        <member name="M:System.ValueBetweenAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterOrEqualAttribute"/></summary>
        </member>
        <member name="M:System.ValueBetweenAttribute.#ctor(System.Object,System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterOrEqualAttribute"/></summary>
            <param name="Min">Минимальное значение</param>
            <param name="Max">Максимальное значение</param>
        </member>
        <member name="M:System.ValueBetweenAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.Collections.Generic.SaveDictionary`2.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:System.Collections.Generic.SaveDictionary`2.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:System.Collections.Generic.SaveDictionary`2.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:System.Collections.Generic.IDictionaryExtensions">
            <summary>Класс методов-расширений для интерфейса <see cref="T:System.Collections.Generic.IDictionary`2"/></summary>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddValue``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``1}},``0,``1)">
            <summary>Метод добавления значения в словарь списков значений</summary>
            <param name="dictionary">Словарь списков <see cref="T:System.Collections.Generic.IList`1"/> значений типа <typeparamref name="TValue"/></param>
            <param name="key">Ключ словаря типа <typeparamref name="TKey"/></param>
            <param name="value">Значение списка типа <typeparamref name="TValue"/></param>
            <typeparam name="TKey">Тип ключа словаря <paramref name="key"/></typeparam>
            <typeparam name="TValue">Тип значения списка значений <paramref name="value"/></typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddValue``3(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``2}},``1,System.Func{``1,``0},System.Func{``1,``2})">
            <summary>Метод добавления значения в словарь списков значений</summary>
            <param name="dictionary">Словарь списков <see cref="T:System.Collections.Generic.IList`1"/> значений типа <typeparamref name="TValue"/></param>
            <param name="obj">Объект-ключ словаря типа <typeparamref name="TObject"/></param>
            <param name="KeySelector">Метод образования ключа типа <typeparamref name="TKey"/> словаря из объекта типа <typeparamref name="TObject"/></param>
            <param name="ValueSelector">Метод образования значения типа <typeparamref name="TValue"/> из объекта типа <typeparamref name="TObject"/></param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TObject">Тип входного объекта</typeparam>
            <typeparam name="TValue">Тип значения списка</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddValue``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``1}},``1,System.Func{``1,``0})">
            <summary>Метод добавления значения в словарь списков значений</summary>
            <param name="dictionary">Словарь списков <see cref="T:System.Collections.Generic.IList`1"/> значений типа <typeparamref name="TValue"/></param>
            <param name="value">Значение, записываемое в словарь</param>
            <param name="KeySelector">Метод извлечения ключа из указанного значения</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения списка</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddValues``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>Добавление значений в словарь</summary>
            <param name="dictionary">Словарь в который надо добавить значения</param>
            <param name="collection">Коллекция добавляемух значений</param>
            <param name="converter">Метод определения ключа словаря для каждого из элементов коллекции</param>
            <typeparam name="TKey">ТИп ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValueOrAddNew``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValueOrAddNew``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения по указанному ключу, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValueOrAddNew``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValueOrAddNew``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ, значение для которого требуется получить</param>
            <param name="DefaultValue">Значение по-умолчанию, которое будет добавлено в словарь с указанным ключём, если он отсутствует</param>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Значение словаря для указанного ключа, либо указанное значение по-умолчанию</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ, значение для которого требуется получить</param>
            <param name="DefaultValue">Значение по-умолчанию, которое будет добавлено в словарь с указанным ключём, если он отсутствует</param>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Значение словаря для указанного ключа, либо указанное значение по-умолчанию</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValue``1(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="name">Название объекта, значение для которого требуется получить</param>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Значение словаря для указанного ключа</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32,System.Func{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``3(System.Collections.Generic.IDictionary{``0,``1},System.Int32,``2,System.Func{``2,System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <typeparam name="TParameter">Тип параметра</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32,System.Func{System.Int32,System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``3(System.Collections.Generic.IDictionary{``0,``1},System.Int32,``2,System.Func{System.Int32,``2,System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="parameter">Параметр инициалализации</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="keys">Коллекция ключей</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``3(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0},``2,System.Func{``0,``2,``1})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="keys">Коллекция ключей</param>
            <param name="parameter">Параметр инициалализации</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.RemoveWhere``2(System.Collections.Generic.IDictionary{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,``1},System.Boolean})">
            <summary>Удаление из словаря элементов, удовлетворяющих предикату</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="selector">Метод отбора элементов</param>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Массив удалённых пар ключ-значение</returns>
        </member>
        <member name="T:System.Collections.Generic.IListExtentions">
            <summary>Методы расширения для интерфейса списка</summary>
        </member>
        <member name="M:System.Collections.Generic.IListExtentions.Initialize``1(System.Collections.Generic.IList{``0},System.Int32,System.Func{System.Int32,``0},System.Boolean)">
            <summary>Метод расширения для инициализации списка</summary>
            <param name="list">Инициализируемый объект</param>
            <param name="Count">Требуемое число элементов</param>
            <param name="Initializator">Метод инициализации</param>
            <param name="ClearBefore">Очищать предварительно (по умолчанию)</param>
            <typeparam name="T">Тип элементов списка</typeparam>
            <returns>Инициализированный список</returns>
        </member>
        <member name="M:System.Collections.Generic.IListExtentions.Initialize``2(System.Collections.Generic.IList{``0},System.Int32,``1,System.Func{System.Int32,``1,``0},System.Boolean)">
            <summary>Метод расширения для инициализации списка</summary>
            <param name="list">Инициализируемый объект</param>
            <param name="Count">Требуемое число элементов</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="Initializator">Метод инициализации</param>
            <param name="ClearBefore">Очищать предварительно (по умолчанию)</param>
            <typeparam name="T">Тип элементов списка</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <returns>Инициализированный список</returns>
        </member>
        <member name="M:System.Collections.Generic.IListExtentions.Mix``1(System.Collections.Generic.IList{``0})">
            <summary>Перемешать список</summary>
            <param name="list">Перемешиваемый список</param>
            <typeparam name="T">Тип элементов списка</typeparam>
            <returns>Перемешанный исходный список</returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.GetEnumerator">
            <summary>
            Возвращает перечислитель, выполняющий перебор элементов в коллекции.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Возвращает перечислитель, который осуществляет перебор элементов коллекции.
            </summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Добавляет элемент в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">Объект, добавляемый в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Clear">
            <summary>
            Удаляет все элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения. </exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.</param><param name="arrayIndex">Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex"/> меньше 0.</exception><exception cref="T:System.ArgumentException">Массив <paramref name="array"/> является многомерным.-или-
                            Значение индекса массива <paramref name="arrayIndex"/> больше или равно длине массива <paramref name="array"/>.-или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="arrayIndex"/> и до конца массива назначения <paramref name="array"/>.-или-Тип <paramref name="T"/> не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Count">
            <summary>
            Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.IsReadOnly">
            <summary>
            Получает значение, указывающее, доступен ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> только для чтения.
            </summary>
            <returns>
            Значение true, если интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения, в противном случае — значение false.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.ContainsKey(`0)">
            <summary>
            Определяет, содержится ли элемент с указанным ключом в <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Значение true, если в <see cref="T:System.Collections.Generic.IDictionary`2"/> содержится элемент с данным ключом; в противном случае — значение false.
            </returns>
            <param name="key">Ключ, который требуется найти в <see cref="T:System.Collections.Generic.IDictionary`2"/>.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Add(`0,`1)">
            <summary>
            Добавляет элемент с указанными ключом и значением в <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">Объект, используемый в качестве ключа добавляемого элемента.</param><param name="value">Объект, используемый в качестве значения добавляемого элемента.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception><exception cref="T:System.ArgumentException">Элемент с таким ключом уже существует в <see cref="T:System.Collections.Generic.IDictionary`2"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IDictionary`2"/> доступен только для чтения.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Remove(`0)">
            <summary>
            Удаляет элемент с указанным ключом из <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Значение true, если элемент успешно удален, в противном случае — значение false.  Этот метод также возвращает значение false, если параметр <paramref name="key"/> не найден в исходном объекте <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <param name="key">Ключ элемента, который необходимо удалить.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IDictionary`2"/> доступен только для чтения.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.TryGetValue(`0,`1@)">
            <summary>
            Получает значение, связанное с указанным ключом.
            </summary>
            <returns>
            Значение true, если объект, реализующий <see cref="T:System.Collections.Generic.IDictionary`2"/>, содержит элемент с указанным ключом, в противном случае — значение false.
            </returns>
            <param name="key">Ключ, значение которого необходимо получить.</param><param name="value">Этот метод возвращает значение, связанное с указанным ключом, если он найден; в противном случае — значение по умолчанию для данного типа параметра <paramref name="value"/>. Этот параметр передается неинициализированным.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Item(`0)">
            <summary>
            Получает или задает элемент с указанным ключом.
            </summary>
            <returns>
            Элемент с указанным ключом.
            </returns>
            <param name="key">Ключ элемента, который требуется получить или задать.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception><exception cref="T:System.Collections.Generic.KeyNotFoundException">Свойство получено и параметр <paramref name="key"/> не найден.</exception><exception cref="T:System.NotSupportedException">Свойство задано, и объект <see cref="T:System.Collections.Generic.IDictionary`2"/> доступен только для чтения.</exception>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Keys">
            <summary>
            Получает интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий ключи <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий ключи объекта, который реализует <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Values">
            <summary>
            Получает интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий значения <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий значения объекта, который реализует <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.IsPartyCorrect(System.Collections.BitArray,System.Boolean)">
            <summary>Проверка корректности чётности</summary>
            <param name="bits">Битовый массив</param>
            <param name="PartyBit">Бит чётности</param>
            <returns>Истина, если сумма бит по модулю 2 и бита чётности равна 0</returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.GetBitSummMod2(System.Collections.BitArray)">
            <summary>Сумма бит по модулю 2</summary>
            <param name="bits">Битовый массив</param>
            <returns>Результат сложения бит массива по модулю 2</returns>
        </member>
        <member name="T:System.EventBase">
            <summary>Событие</summary>
        </member>
        <member name="F:System.EventBase._Timeout">
            <summary>Интервал таймаута события</summary>
        </member>
        <member name="F:System.EventBase._Started">
            <summary>Запущен таймаут события</summary>
        </member>
        <member name="F:System.EventBase._Invocked">
            <summary>Событие было сгенерировано в период таймаута</summary>
        </member>
        <member name="F:System.EventBase._Enable">
            <summary>Событие включено</summary>
        </member>
        <member name="F:System.EventBase._EventWaitTokenSource">
            <summary>Источник сигналов отмены ожидающих событий</summary>
        </member>
        <member name="P:System.EventBase.Timeout">
            <summary>Таймаут генерации события</summary>
        </member>
        <member name="P:System.EventBase.Enable">
            <summary>Событие включено</summary>
        </member>
        <member name="P:System.EventBase.HandlersExists">
            <summary>У события есть подписчики</summary>
        </member>
        <member name="M:System.EventBase.#ctor(System.Int32)">
            <summary>Инициализация нового фильтра событий</summary>
            <param name="Timeout">Таймаут фильтра событий</param>
        </member>
        <member name="M:System.EventBase.CheckIfStarted">
            <summary>Проверка состояния генерации события</summary>
            <returns>Истина, если событие находится в режиме таймаута</returns>
        </member>
        <member name="M:System.EventBase.InvokeEventAsync(System.Object,System.EventArgs)">
            <summary>
            Синхронный вызов события с асинхронным продолжением, ожидающим повторный вызов в пределах заданного таймаута
            Если повторный вызов был совершён за время, меньшее, чем таймаут, то повторная генерация события будет отложена
            до истечения таймаута и будет однократна для всех вызовов в период ожидания 
            </summary>
            <param name="sender">Источник события</param>
            <param name="args">Аргумент события</param>
        </member>
        <member name="M:System.EventBase.InvokeEvent(System.Object,System.EventArgs)">
            <summary>Вызвать событие</summary>
            <param name="sender">Источник события</param>
            <param name="args">Аргумент события</param>
            <returns>Истина, если были подписчики события</returns>
        </member>
        <member name="T:System.Event">
            <inheritdoc />
        </member>
        <member name="E:System.Event.Handler">
            <summary>Фильтруемое событие</summary>
        </member>
        <member name="P:System.Event.HandlersExists">
            <inheritdoc />
        </member>
        <member name="M:System.Event.#ctor(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:System.Event.Invoke(System.Object,System.EventArgs)">
            <summary>Генерация события с процессом фильтрации по времени</summary>
            <param name="sender">Источник события</param>
            <param name="args">Аргумент события</param>
        </member>
        <member name="M:System.Event.InvokeEvent(System.Object,System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="T:System.Event`1">
            <inheritdoc />
            <typeparam name="TEventArgs">Тип аргументов события</typeparam>
        </member>
        <member name="E:System.Event`1.Handler">
            <summary>Фильтруемое событие</summary>
        </member>
        <member name="P:System.Event`1.HandlersExists">
            <inheritdoc />
        </member>
        <member name="M:System.Event`1.#ctor(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:System.Event`1.Invoke(System.Object,`0)">
            <summary>Генерация события с процессом фильтрации по времени</summary>
            <param name="sender">Источник события</param>
            <param name="args">Аргумент события</param>
        </member>
        <member name="M:System.Event`1.InvokeEvent(System.Object,System.EventArgs)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitElementInitializer(System.Linq.Expressions.ElementInit)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitTypeIs(System.Linq.Expressions.TypeBinaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberAccess(System.Linq.Expressions.MemberExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitLambda(System.Linq.Expressions.LambdaExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.Expressions.ExpressionMatrix">
            <summary>Матрица выражений NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetUnitaryMatryx(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionMatrix._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionMatrix._M">
            <summary>Число столбцов матриц</summary>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionMatrix._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце) 0..N-1</param>
            <param name="j">Номер столбца (элемента в строке) 0..M-1</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.Item(System.Int32)">
            <summary>Вектор-стольбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.T">
            <summary>Транспонированная матрица</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="T:System.Linq.Expressions.ExpressionMatrix.MatrixItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32,System.Linq.Expressions.ExpressionMatrix.MatrixItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32,System.Int32,System.Linq.Expressions.ExpressionMatrix.MatrixItemCreator)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция f(i,j) - i-строка, j-столбец</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом гауса</summary>
            <returns>Триугольная матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetTransvection(System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="col">Оборный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetTransponse">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.System#ICloneable#Clone">
            <summary> Создает новый объект, который является копией текущего экземпляра</summary>
            <returns> Новый объект, являющийся копией этого экземпляра </returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Addition(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Subtraction(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Multiply(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Division(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_BitwiseOr(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Конкатинация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слогаемое</param>
            <param name="B">Второе слогаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Implicit(System.Linq.Expressions.Expression)~System.Linq.Expressions.ExpressionMatrix">
            <summary>Оператор неявного преведения типа вещественного числа двойной точнойсти к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порадка 1х1</returns>
        </member>
        <member name="T:System.Linq.Expressions.ExpressionRebuilder">
            <summary>Пересборщик дерева выражения Linq.Expression</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionRebuilder.InvokeEvent``1(System.EventHandlerReturn{System.EventArgs{``0},System.Linq.Expressions.Expression},``0,System.Func{``0,System.Linq.Expressions.Expression})">
            <summary>Метод генерации события посещения узла типа Expression</summary>
            <typeparam name="TExpressionNode">Тип узла дерева</typeparam>
            <param name="Handlers">Событие</param>
            <param name="Node">Узел дерева</param>
            <param name="Base">Базовый метод обработки узла</param>
            <returns>Узел, которым надо заместить посещённый узел дерева</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionRebuilder.InvokeEvent``2(System.EventHandlerReturn{System.EventArgs{``1},``1},``0,System.Func{``0,``1})">
            <summary>Метод генерации события посещения узла произвольного типа</summary>
            <typeparam name="TElement">Тип узла дерева</typeparam><typeparam name="TOut">Тип выходного узла</typeparam>
            <param name="Handlers">Событие</param>
            <param name="Node">Посещённый узел дерева</param>
            <param name="Base">Базовый метод обработки узла</param>
            <returns>Узел, которым надо заместить посещённый узел дерева</returns>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.Visited">
            <summary>Событие возникает при посещении любого узла дерева</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionRebuilder.Visit(System.Linq.Expressions.Expression)">
            <summary>Посетить узел дерева</summary><param name="Node">Узел дерева</param><returns>Новый узел дерева</returns>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.BinaryVisited">
            <summary>Событие возникает при посещении узла дерева бинарного выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.BindingVisited">
            <summary>Событие возникает при посещении узла привязки</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.BindingListVisited">
            <summary>Событие возникает при посещении коллекции привязки</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ConditionalVisited">
            <summary>Событие возникает при посещении узла условного оператора</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ConstantlVisited">
            <summary>Событие возникает при посещении узла константы</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ElementInitializerVisited">
            <summary>Событие возникает при посещении узла инициализатора объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ElementInitializerListVisited">
            <summary>Событие возникает при посещении коллекции инициализаторов объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ExpressionListVisited">
            <summary>Событие возникает при посещении коллекции выражений</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.LambdaVisited">
            <summary>Событие возникает при посещении лямда-выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ListInitVisited">
            <summary>Событие возникает при посещении узла инициализатора коллекции</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.InvocationVisited">
            <summary>Событие возникает при посещении узла вызова функции</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberAccessVisited">
            <summary>Событие возникает при посещении узла доступа к члену объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberAssignmentVisited">
            <summary>Событие возникает при посещении узла присвоения члену объекта значения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberInitVisited">
            <summary>Событие возникает при посещении узла инициализатора свойства объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberListBindingVisited">
            <summary>Событие возникает при посещении узла инициализатора коллекции объектов</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberMemberBindingVisited">
            <summary>Событие возникает при посещении узла инициализатора элементов элемента</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MethodCallVisited">
            <summary>Событие возникает при посещении узла вызова метода</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.NewVisited">
            <summary>Событие возникает при посещении узла конструктора</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.NewArrayVisited">
            <summary>Событие возникает при посещении узла конструктора массива</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ParameterVisited">
            <summary>Событие возникает при посещении узла параметра выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.TypeIsVisited">
            <summary>Событие возникает при посещении узла определения типа выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.UnaryVisited">
            <summary>Событие возникает при посещении узла унарного выражения</summary>
        </member>
        <member name="T:System.Linq.Expressions.Property`1">
            <summary>Свойство класса</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
        </member>
        <member name="E:System.Linq.Expressions.Property`1.PropertyChanged">
            <summary>Событие изменения свойства</summary>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения свойства</summary>
            <param name="PropertyName">Имя свойства</param>
        </member>
        <member name="F:System.Linq.Expressions.Property`1._PropertyInfo">
            <summary>Информация о свойстве</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property`1._Reader">
            <summary>Метод чтения свойства</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property`1._Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.CanRead">
            <summary>Признак возможности чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.CanWrite">
            <summary>Признак возможности записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.Reader">
            <summary>Метод чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.DescriptionAttribute">
            <summary>Свойство доступа к значению аттрибута <see cref="T:System.ComponentModel.DescriptionAttribute"/></summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.DisplayName">
            <summary>Отображаемое имя</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.IsNotifyPropertyChanged">
            <summary>Признак реализации объектом-хозяином свойства интерфейса <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.#ctor(System.Type,System.String,System.Boolean)">
            <summary>Инициализация доступа к статическому свойству</summary>
            <param name="type">Рассматриваемый тип</param>
            <param name="Name">Имя статического свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.#ctor(System.Object,System.String,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="Name">Имя свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.#ctor(System.Object,System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="info">Информация о свойстве</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.LoadAttributes">
            <summary>Чтение сведений из аттрибутов</summary>
        </member>
        <member name="T:System.Linq.Expressions.Property">
            <summary>Свойство класса</summary>
        </member>
        <member name="E:System.Linq.Expressions.Property.PropertyChanged">
            <summary>Событие изменения свойства</summary>
        </member>
        <member name="M:System.Linq.Expressions.Property.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения свойства</summary>
            <param name="PropertyName">Имя свойства</param>
        </member>
        <member name="F:System.Linq.Expressions.Property._PropertyInfo">
            <summary>Информация о свойстве</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property._Reader">
            <summary>Метод чтения свойства</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property._Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.CanRead">
            <summary>Признак возможности чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.CanWrite">
            <summary>Признак возможности записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.Reader">
            <summary>Метод чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.DescriptionAttribute">
            <summary>Свойство доступа к значению аттрибута <see cref="T:System.ComponentModel.DescriptionAttribute"/></summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.DisplayName">
            <summary>Отображаемое имя</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.IsNotifyPropertyChanged">
            <summary>Признак реализации объектом-хозяином свойства интерфейса <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="M:System.Linq.Expressions.Property.#ctor(System.Type,System.String,System.Boolean)">
            <summary>Инициализация доступа к статическому свойству</summary>
            <param name="type">Рассматриваемый тип</param>
            <param name="Name">Имя статического свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property.#ctor(System.Object,System.String,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="Name">Имя свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property.#ctor(System.Object,System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="info">Информация о свойстве</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property.LoadAttributes">
            <summary>Чтение сведений из аттрибутов</summary>
        </member>
        <member name="T:System.Linq.Expressions.TeXEvaluationExpressionVisitor">
            <summary>
            Класс "посетителя" для "подстановки" актуальных значний в дерево выражения
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.MultiplicationSign">
            <summary>
            TeX supports several styles for multiplication sign
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.MultiplicationSign.None">
            <summary>
            Without any sign
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.MultiplicationSign.Asterisk">
            <summary>
            * sign
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.MultiplicationSign.Times">
            <summary>
            x sign
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.TeXExpressionVisitor">
            <summary>
            Класс "посетилителя", который "изучает" дерево выражения путем переопределения соответствующих
            виртуальных методов базового класса System.Linq.Expressions.ExpressionVisitor
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.TeXExpressionVisitor.VisitPrefixBinary(System.Linq.Expressions.BinaryExpression)">
            <summary>
            Оператор деления \fract требует иного порядка аргументов:
            \frac{arg1}{arg2} 
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="T:System.Linq.Reactive.IObservableEx`1">
            <summary>Обозреваемый объект</summary>
            <typeparam name="T">Тип объектов последовательности событий</typeparam>
        </member>
        <member name="M:System.Linq.Reactive.IObservableEx`1.Subscribe(System.Linq.Reactive.IObserverEx{`0})">
            <summary>Метод получения наблюдателя</summary>
            <param name="observer">Наблюдатель объекта</param>
            <returns>Объект, реализующий возможность разрушшения связи с наблюдаемым объектом</returns>
        </member>
        <member name="T:System.Linq.Reactive.IObserverEx`1">
            <summary>Интерфейс наблюдателя</summary>
            <typeparam name="T">Тип объектов последовательности событий</typeparam>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Next">
            <summary>Событие появления следующего объекта последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Complited">
            <summary>Событие завершения последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Reset">
            <summary>Событие сброса последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Error">
            <summary>Событие появления исключения</summary>
        </member>
        <member name="M:System.Linq.Reactive.IObserverEx`1.OnReset">
            <summary>Метод генерации события сброса последовательности</summary>
        </member>
        <member name="T:System.Linq.Reactive.LamdaObservable`1">
            <summary>НАблюдаемый объект с методами обработки событий, задаваемыми лямда-синтексисом</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:System.Linq.Reactive.LamdaObservable`1._Observer">
            <summary>Присоединённый наблюдатель</summary>
        </member>
        <member name="F:System.Linq.Reactive.LamdaObservable`1._OnNext">
            <summary>Действие обработки следующего объекта наблюдения</summary>
        </member>
        <member name="F:System.Linq.Reactive.LamdaObservable`1._OnCompleted">
            <summary>Действие обработки завершения процесса наблюдения</summary>
        </member>
        <member name="F:System.Linq.Reactive.LamdaObservable`1._OnReset">
            <summary>Действие обработки сброса состояния наблюдаемого объекта</summary>
        </member>
        <member name="T:System.Linq.Reactive.ObservableExtentions">
            <summary>Методы-расширения интерфейса наблюдаемых объектов <see cref="T:System.Linq.Reactive.IObservableEx`1"/></summary>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.AddObserver``1(System.Collections.Generic.ICollection{System.IObserver{``0}},System.IObserver{``0})">
            <summary>Добавить наблюдатель в список наблюдателей и получить объект-отписчик</summary>
            <typeparam name="T">Тип значений наблюдаемого объекта</typeparam>
            <param name="Observers">Коллекция наблюдателей</param>
            <param name="Observer">Добавляемый наблюдатель</param>
            <returns>Объект, удаляющий наблюдатель из списка наблюдателей в случае своей отписки</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.FromProperty``1(System.ComponentModel.INotifyPropertyChanged,System.String)">
            <summary>Метод получения наблюдаемого объекта для объекта, реализующего интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>  для указанного имени свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="obj">Наблюдаемый объект</param>
            <param name="ProperyName">Имя свойства</param>
            <returns>Объект-наблюдатель за свойством</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>Метод фильтрации событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="observable">Исходный объект-наблюдатель</param>
            <param name="Predicate">Метод фильтрации</param>
            <returns>Объекнаблюдатель с установленным методом фильтрации</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>Метод фильтрации событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="observable">Исходный объект-наблюдатель</param>
            <param name="predicate">Метод фильтрации</param>
            <param name="ElseAction">Метод обработки невошедших событий</param>
            <returns>Объекнаблюдатель с установленным методом фильтрации</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.Select``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>Метод преобразования объектов событий</summary>
            <typeparam name="T">Тип исходных объектов событий</typeparam>
            <typeparam name="Q">Тип результирующих объектов событий</typeparam>
            <param name="observable">Исходный объект-наблюдатель</param>
            <param name="Selector">Объект-наблюдатель с преобразованными объектами событий</param>
            <returns>Объект-наблюдатель с преобразованными типами объектов</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.WhaitSync``1(System.IObservable{``0},System.TimeSpan)">
            <summary>Метод получения синхронно задержанных во времени событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Interval">Интервал времени задержки событий</param>
            <returns>ОБъект-наблюдатель, события которого синхронно задержаны во времени на указанный интервал</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.WhaitAsync``1(System.IObservable{``0},System.TimeSpan)">
            <summary>Метод получения задержанных во времени событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Interval">Интервал времени задержки событий</param>
            <returns>ОБъект-наблюдатель, события которого задержаны во времени на указанный интервал</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.FromEvent``1(System.Object,System.String)">
            <summary>Метод получения объекта-наблюдателя для указанного события</summary>
            <typeparam name="TEventArgs">Тип аргументов события</typeparam>
            <param name="Obj">Наблюдаемый объект</param>
            <param name="EventName">Имя события</param>
            <returns>Объект-ниблюдатель за событием</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.GetObservable``1(System.Collections.Generic.IEnumerable{``0},System.IObservable{``0}@)">
            <summary>Метод получения объекта-наблюдателя из объекта-перечисления</summary>
            <typeparam name="T">Тип объектов перечисления</typeparam>
            <param name="collection">Перечисление объектов</param>
            <param name="observable">Созданный объект-наблюдатель за перечислением объектов коллекции</param>
            <returns>Новое перечисление объектов, перечисление объектов которого вызывает события в наблюдателе</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.Take``1(System.IObservable{``0},System.Int32)">
            <summary>Метод получения объекта-нибулюдателя, пропускающего после создания указанное число событий</summary>
            <typeparam name="T">Тип объектов события</typeparam>
            <param name="observable">Исходный объект-наблюдатель</param>
            <param name="Count">Количество пропускаемых событий</param>
            <returns>Объект-наблюдатель с указанным количеством пропускаемых событий</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.Take``3(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.Boolean)">
            <summary>Метод обработки последовательности событий с учётом разрешающей и запрещающей последовательностей</summary>
            <typeparam name="T">Тип объектов событий наблюдаемого объекта</typeparam>
            <typeparam name="O">Тип объектов событий разрешающей последовательности</typeparam>
            <typeparam name="C">Тип объектов событий запрещающей последовательности</typeparam>
            <param name="source">Объект-наблюдатель источник событий</param>
            <param name="Open">Объект-наблюдатель разрешающий событий в выходной последовательности</param>
            <param name="Close">Объект-наблюдатель запрещающий событий в выходной последовательности</param>
            <param name="IsOpen">Исходное состояния разрешения событий в выходной последовательности (по умолчанию разрешено)</param>
            <returns>Управляемый объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.TakeUntil``2(System.IObservable{``0},System.IObservable{``1},System.Boolean)">
            <summary>Метод получения объекта-наблюдателя, события в котором пропускаются в выходную последовательность только до появления события в управляющей последовательности</summary>
            <typeparam name="T">Тип исходных объектов события</typeparam>
            <typeparam name="Q">Тип события управляющей последовательности</typeparam>
            <param name="source">Исходный объект-наблюдатель</param>
            <param name="Selector">Обект-наблюдатель управляющей последовательности</param>
            <param name="IsOpen">Исходное состояние выходной последовательности</param>
            <returns>Объект-наблюдатель управляемый управляющей последовательностью</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.SkipWhile``2(System.IObservable{``0},System.IObservable{``1},System.Boolean)">
            <summary>Метод получения объекта-наблюдателя, события в котором пропускаются в выходную последовательность только после появления события в управляющей последовательности</summary>
            <typeparam name="T">Тип исходных объектов события</typeparam>
            <typeparam name="Q">Тип события управляющей последовательности</typeparam>
            <param name="source">Исходный объект-наблюдатель</param>
            <param name="Selector">Обект-наблюдатель управляющей последовательности</param>
            <param name="IsOpen">Исходное состояние выходной последовательности</param>
            <returns>Объект-наблюдатель управляемый управляющей последовательностью</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.ForeachAction``1(System.IObservable{``0},System.Action{``0})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.ForeachAction``1(System.IObservable{``0},System.Action{``0},System.Func{``0,System.Boolean})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <param name="where">Метод выборки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.ForeachAction``1(System.IObservable{``0},System.Action{``0,System.Int32})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.ForeachAction``1(System.IObservable{``0},System.Action{``0,System.Int32},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <param name="where">Метод выборки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.OnError``1(System.IObservable{``0},System.Action{System.Exception})">
            <summary>Метод обработки события <see cref="T:System.Exception"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="OnError">Метод обработки события <see cref="T:System.Exception"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.OnComplited``1(System.IObservable{``0},System.Action)">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Complited"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="OnComplited">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Complited"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.OnReset``1(System.IObservable{``0},System.Action)">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Reset"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="observable">Исходный обект-наблюдатель</param>
            <param name="OnReset">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Reset"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.FromAsyncPattern``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0})">
            <summary>Создать метод генерации наблюдаемого объекта из шаблона асинхронной операции</summary>
            <typeparam name="T">Тип результата</typeparam>
            <param name="BeginInvoke">Метод начала асинхронной операции</param>
            <param name="EndInvoke">Метод завершения асинхронной операции</param>
            <returns>Фунцкия, возвращающая наблюдаемый объект, генерирующий своё значение в момент завершения асинхронной операции</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.SelectMany``1(System.IObservable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>Метод-лианиризатор событий для наблюдаемого объекта, возвращающего коллекцию объектов типа <see cref="!:T"/></summary>
            <typeparam name="T">Тип результирующих объектов</typeparam>
            <param name="o">Объект-наблюдатель коллекции</param>
            <returns>Объект-наблюдатель элементов коллекции</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtentions.Single``1(System.IObservable{``0})">
            <summary>Получить первое значение наблюдаемого объекта</summary>
            <typeparam name="T">Тип значений объекта</typeparam>
            <param name="ObservableObject">Наблюдаемый объект</param>
            <returns>Первое значение наблюдаемого объекта</returns>
        </member>
        <member name="T:System.Linq.Reactive.ObservableExContract`1">
            <summary>Класс контрактов для интерфейса <see cref="T:System.Linq.Reactive.IObservableEx`1"/></summary>
            <typeparam name="T">Тип объектов последовательности событий</typeparam>
        </member>
        <member name="T:System.Linq.Reactive.ObserverLink`1">
            <summary>Класс объектов-связей между наблюдателем и списком наблюдателей, позволяющих удалять наблюдатель из писка наблюдателей в случае если объект удаляется из памяти</summary>
            <typeparam name="T">Тип значений наблюдаемого объекта</typeparam>
        </member>
        <member name="M:System.Linq.Reactive.ObserverLink`1.GetHash(System.Collections.Generic.ICollection{System.IObserver{`0}},System.IObserver{`0})">
            <summary>Получить хэш-код связи</summary>
            <param name="Observers">Коллекция наблюдателей</param>
            <param name="Observer">Добавляемый наблюдатель</param>
            <returns>Хэш-код связи</returns>
        </member>
        <member name="F:System.Linq.Reactive.ObserverLink`1.__Links">
            <summary>Словарь связей</summary>
        </member>
        <member name="M:System.Linq.Reactive.ObserverLink`1.GetLink(System.Collections.Generic.ICollection{System.IObserver{`0}},System.IObserver{`0})">
            <summary>Получить связь между наблюдателем и списком наблюдателей</summary>
            <param name="Observers">Коллекция наблюдателей</param>
            <param name="Observer">Добавляемый наблюдатель</param>
            <returns>Связь между наблюдателем и списком наблюдателей</returns>
        </member>
        <member name="F:System.Linq.Reactive.ObserverLink`1._Observer">
            <summary>Удаляемый наблюдатель</summary>
        </member>
        <member name="F:System.Linq.Reactive.ObserverLink`1._Observers">
            <summary>Коллекция наблюдателей, из которой требуется удалить отслеживаемый наблюдатель</summary>
        </member>
        <member name="F:System.Linq.Reactive.ObserverLink`1._SyncRoot">
            <summary>Объект межпотоковой синхроницации</summary>
        </member>
        <member name="M:System.Linq.Reactive.ObserverLink`1.#ctor(System.Collections.Generic.ICollection{System.IObserver{`0}},System.IObserver{`0})">
            <summary>Инициализация новой связи между списком наблюдателей и отслеживаемым наблюдателем</summary>
            <param name="Observers">Список наблюдателей</param>
            <param name="Observer">Отслеживаемый наблюдатель</param>
        </member>
        <member name="T:System.Linq.Reactive.SimpleObservableEx`1">
            <summary>Простейший наблюдаемый объект</summary><typeparam name="T">Тип объектов событий</typeparam>
        </member>
        <member name="F:System.Linq.Reactive.SimpleObservableEx`1._Observers">
            <summary>Список объектов наблюдателей</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnNext(`0)">
            <summary>Метод генерации следующего события</summary>
            <param name="item">Объект события</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnCompleted">
            <summary>Метод генерации события завершения последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnReset">
            <summary>Метод генерации события сброса последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnError(System.Exception)">
            <summary>Метод генерации события возникновения ошибки</summary>
            <param name="error">Возникшее исключение</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnError(System.IObserver{`0},System.Exception)">
            <summary>Генерация события возникновения исключения</summary>
            <param name="observer">НАблюдаемый объект, в котором возникло исключение</param>
            <param name="error">Возникшее исключение</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.Subscribe(System.Linq.Reactive.IObserverEx{`0})">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.Subscribe(System.IObserver{`0})">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.Dispose">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.Reactive.SimpleObserverEx`1">
            <summary>Простейший наблюдатель</summary>
            <typeparam name="T">Объект события</typeparam>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Next">
            <summary>События появления следующего объекта в последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Complited">
            <summary>Событие завершения последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Reset">
            <summary>Событие сброса последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Error">
            <summary>Событие появления исключения</summary>
        </member>
        <member name="P:System.Linq.Reactive.SimpleObserverEx`1.Tag">
            <summary>Тэг наблюдателя</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.#ctor(System.IObservable{`0})">
            <summary>Инициализация нового простейшего наблюдателя</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnNext(`0)">
            <summary>Метод генерации события появления следующего объекта</summary>
            <param name="item">Следующий объект в последовательности</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnError(System.Exception)">
            <summary>Метод генерации события исключительной ситуации</summary>
            <param name="error">Исключительная ситуация</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnCompleted">
            <summary>Метод генерации события завершения последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnReset">
            <summary>Метод генерации события сброса последовательности</summary>
        </member>
        <member name="T:System.Linq.Reactive.TakeObservable`1">
            <summary>Наблюдаемый объект с указанным числом генерации событий</summary>
            <typeparam name="T">Тип объектов последовательности</typeparam>
        </member>
        <member name="F:System.Linq.Reactive.TakeObservable`1._Observer">
            <summary>Исходный наблюдатель</summary>
        </member>
        <member name="M:System.Linq.Reactive.TakeObservable`1.#ctor(System.IObservable{`0},System.Int32)">
            <summary>Наблюдаемый объект с указанным числом генерации событий</summary>
            <param name="observable">Исходный наблюдаемый объект</param>
            <param name="Count">Количество извлекаемых событий</param>
        </member>
        <member name="T:System.Linq.Reactive.TriggeredObservable`1">
            <summary>Управляемый наблюдаемый объект</summary>
            <typeparam name="T">Тип объекта последовательности</typeparam>
        </member>
        <member name="F:System.Linq.Reactive.TriggeredObservable`1._Observer">
            <summary>Наблюдатель</summary>
        </member>
        <member name="P:System.Linq.Reactive.TriggeredObservable`1.Open">
            <summary>Признак разрешения генерации событий</summary>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.#ctor(System.IObservable{`0},System.Boolean)">
            <summary>Управляемый наблюдаемый объект</summary>
            <param name="observable">Наблюдаемый объект</param>
            <param name="IsOpen">Исходное состояние</param>
        </member>
        <member name="T:System.Linq.Reactive.Unit">
            <summary>
            Represents a type with a single value. This type is often used to denote the successful completion of a void-returning method (C#) or a Sub procedure (Visual Basic).
            
            </summary>
        </member>
        <member name="P:System.Linq.Reactive.Unit.Default">
            <summary>
            Gets the single unit value.
            
            </summary>
        </member>
        <member name="M:System.Linq.Reactive.Unit.op_Equality(System.Linq.Reactive.Unit,System.Linq.Reactive.Unit)">
            <summary>
            Determines whether the two specified Unit values are equal. Because Unit has a single value, this always returns true.
            
            </summary>
            <param name="first">The first Unit value to compare.</param><param name="second">The second Unit value to compare.</param>
            <returns>
            Because Unit has a single value, this always returns true.
            </returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.op_Inequality(System.Linq.Reactive.Unit,System.Linq.Reactive.Unit)">
            <summary>
            Determines whether the two specified Unit values are not equal. Because Unit has a single value, this always returns false.
            
            </summary>
            <param name="first">The first Unit value to compare.</param><param name="second">The second Unit value to compare.</param>
            <returns>
            Because Unit has a single value, this always returns false.
            </returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.Equals(System.Linq.Reactive.Unit)">
            <summary>
            Determines whether the specified Unit values is equal to the current Unit. Because Unit has a single value, this always returns true.
            
            </summary>
            <param name="other">An object to compare to the current Unit value.</param>
            <returns>
            Because Unit has a single value, this always returns true.
            </returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current Unit.
            
            </summary>
            <param name="obj">The System.Object to compare with the current Unit.</param>
            <returns>
            true if the specified System.Object is a Unit value; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.GetHashCode">
            <summary>
            Returns the hash code for the current Unit value.
            
            </summary>
            
            <returns>
            A hash code for the current Unit value.
            </returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.ToString">
            <summary>
            Returns a string representation of the current Unit value.
            
            </summary>
            
            <returns>
            String representation of the current Unit value.
            </returns>
        </member>
        <member name="T:System.Linq.IEnumerableExtensions">
            <summary>Класс методов-расширений для интерфейса перечисления</summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Where(System.Collections.Generic.IEnumerable{System.String},System.Text.RegularExpressions.Regex)">
            <summary>Фильтрация последовательности строк по указанному регулярному выражению</summary>
            <param name="strings">Последовательность строк</param>
            <param name="regex">Регулярное выражение-фильтр</param>
            <returns>Последовательность строк, удовлетворяющая регулярному выражению</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.WhereNot(System.Collections.Generic.IEnumerable{System.String},System.Text.RegularExpressions.Regex)">
            <summary>Фильтрация последовательности строк, которые не удовлетворяют регулярному выражению</summary>
            <param name="strings">Фильтруемая последовательность строк</param>
            <param name="regex">Регулярное выражение-фильтр</param>
            <returns>Последовательность строк, которые не удовлетворяют регулярному выражению</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Where(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>Фильтрация последовательности строк по указанному регулярному выражению</summary>
            <param name="strings">Последовательность строк</param>
            <param name="regex">Регулярное выражение-фильтр</param>
            <returns>Последовательность строк, удовлетворяющая регулярному выражению</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.WhereNot(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>Фильтрация последовательности строк, которые не удовлетворяют регулярному выражению</summary>
            <param name="strings">Фильтруемая последовательность строк</param>
            <param name="regex">Регулярное выражение-фильтр</param>
            <returns>Последовательность строк, которые не удовлетворяют регулярному выражению</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.WhereNot``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Выполняет фильтрацию последовательности значений на основе заданного предиката</summary>
            <returns>
            Объект <see cref="T:System.Collections.Generic.IEnumerable`1"/>, содержащий элементы входной последовательности, которые не удовлетворяют условию.
            </returns>
            <param name="collection">Объект <see cref="T:System.Collections.Generic.IEnumerable`1"/>, подлежащий фильтрации.</param>
            <param name="NotSelector">Функция для проверки каждого элемента на не соответствие условию.</param>
            <typeparam name="T">Тип элементов последовательности <paramref name="collection"/>.</typeparam>
            <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="collection"/> или <paramref name="NotSelector"/> — null.</exception>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.TakeWhileNot``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Возвращает цепочку элементов последовательности, удовлетворяющих указанному условию</summary>
            <returns>
            Объект <see cref="T:System.Collections.Generic.IEnumerable`1"/>, содержащий элементы входной последовательности до первого элемента, который не прошел проверку.
            </returns>
            <param name="collection">Последовательность, из которой требуется возвратить элементы.</param>
            <param name="NotSelector">Функция для проверки каждого элемента на соответствие условию.</param>
            <typeparam name="T">Тип элементов последовательности <paramref name="collection"/>.</typeparam>
            <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="collection"/> или <paramref name="NotSelector"/> — null.</exception>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Преобразование перечисления в массив с преобразованием элементов</summary>
            <typeparam name="TItem">Тип элементов исходного перечисления</typeparam>
            <typeparam name="TValue">Тип элементов результирующего массива</typeparam>
            <param name="collection">Исходное перечисление</param>
            <param name="converter">Метод преобразования элементов</param>
            <returns>
            Если ссылка на исходное перечисление не пуста, то
                Результирующий массив, состоящий из элементов исходного перечисления, преобразованных указанным методом
            иначе
                пустая ссылка на массив
            </returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToList``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Преобразование перечисления в список с преобразованием элементов</summary>
            <typeparam name="TItem">Тип элементов исходного перечисления</typeparam>
            <typeparam name="TValue">Тип элементов результирующего списка</typeparam>
            <param name="collection">Исходное перечисление</param>
            <param name="converter">Метод преобразования элементов</param>
            <returns>
            Если ссылка на исходное перечисление не пуста, то
                Результирующий список, состоящий из элементов исходного перечисления, преобразованных указанным методом
            иначе
                пустая ссылка на список
            </returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Aggregate(System.Collections.Generic.IEnumerable{System.String})">
            <summary>Объединение перечисления строк в единую строку с разделителем - переносом строки</summary>
            <param name="Lines">Перечисление строк</param>
            <returns>Если ссылка на перечисление пуста, то пустая ссылка на строку, иначе - объединение строк с разделителем - переносом строки</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AddTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.ICollection{``0})">
            <summary>Добавить элементы перечисления в коллекцию</summary>
            <typeparam name="T">Тип элемента</typeparam>
            <param name="source">Перечисление добавляемых элементов</param>
            <param name="collection">Коллекция-приёмник элементов</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.RemoveFrom``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.ICollection{``0})">
            <summary>Удалить перечисление элементов из коллекци</summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="source">Перечисление удаляемых элементов</param>
            <param name="collection">Коллекция, из которой производится удаление</param>
            <returns>Перечисление результатов операций удаления для каждого из элементов исходного перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AddToDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IDictionary{``0,``1},System.Func{``1,``0})">
            <summary>Добавить в словарь</summary>
            <typeparam name="TKey">Тип ключей словаря</typeparam>
            <typeparam name="TValue">Тип значений словаря</typeparam>
            <param name="collection">Коллекция элементов, добавляемых в словарь</param>
            <param name="dictionary">Словарь, в который добавляются элементы</param>
            <param name="converter">Метод определения ключа элемента</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ConvertToType``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>Преобразовать последовательность одних элементов в последовательность других элементов с использованием механизма конвертации</summary>
            <typeparam name="TItem">Тип исходных элементов</typeparam>
            <typeparam name="TValue">Тип элементов, в которые преобразуются исходные</typeparam>
            <param name="collection">Последовательность исходных элементов</param>
            <returns>Последовательность элементов преобразованного типа</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.SelectWithLastValue``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``1})">
            <summary>Создать последовательность элементов, каждое значение в которой будет получено на основе двух значений исходной последовательности</summary>
            <typeparam name="TItem">Тип элементов исходной последовательности</typeparam>
            <typeparam name="TValue">Тип элементов последовательности сконвертированных элементов</typeparam>
            <param name="collection">Исходная последовательность элементов</param>
            <param name="converter">
            Метод преобразования, в который передаётся исходный элемент последовательности, предыдущий элемент последовательности, 
            и на основе двух этих элементов, он определяет значение элемента результирующей последовательности</param>
            <returns>Последовательность элементов, составляемая из преобразованных элементов исходной последовательности, где метод преобразования учитывает значение предшествующего элемента</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AtFirst``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнить действие для первого элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="action">Действие, выполняемое для первого элемента последовательности в момент её перечисления</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AtLast``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнить действие для последнего элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="action">Действие, выполняемое для последнего элемента в момент её перечисления. Если последовательность элементов просмотрена до конца</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Before``1(System.Collections.Generic.IEnumerable{``0},System.Action)">
            <summary> Выполнить действие до начала перечисления последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="ActionBefore">Действие, выполняемое до начала перечисления элементов последовательности</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.OnComplite``1(System.Collections.Generic.IEnumerable{``0},System.Action)">
            <summary>Выполнение действия по завершению перечисления коллекции</summary>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <param name="collection">Коллекция элементов</param>
            <param name="CompliteAction">ДЕйствие, выполняемое по завершению перечисления коллекции</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="T:System.Linq.IEnumerableExtensions.EnumerableHystory`1">
            <summary>История перечисления последовательности элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumerableHystory`1._HystoryLength">
            <summary>Длина истории</summary>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumerableHystory`1._Queue">
            <summary>Список элементов в истории</summary>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumerableHystory`1._ObservableObject">
            <summary>Объект-наблюдения за историей</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumerableHystory`1.Current">
            <summary>Текущий элемент перечисления</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumerableHystory`1.Length">
            <summary>Длина истории</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumerableHystory`1.Count">
            <summary>Количество элементов в истории</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumerableHystory`1.Item(System.Int32)">
            <summary>Доступ к элементам истории начиная с текущего</summary>
            <param name="i">Индекс элемента в истории, где 0 - текущий элемент</param>
            <returns>Элемент истории перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHystory`1.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:System.Linq.IEnumerableExtensions.EnumerableHystory`1"/></summary>
            <param name="HystoryLength">Длина истории</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHystory`1.Check">
            <summary>Удаление лишних элементов из истории</summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHystory`1.Add(`0)">
            <summary>Добавить элемент в историю перечисления</summary>
            <param name="item">Добавляемый элемент</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHystory`1.GetEnumerator">
            <summary>Получить перечислитель истории элементов</summary><returns>Перечислитель истории элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHystory`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитель истории элементов</summary><returns>Перечислитель истории элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHystory`1.Subscribe(System.IObserver{`0})">
            <summary>Подписка на изменения истории перечисления</summary>
            <param name="observer">Объект-подписчик, уведомляемый об изменениях в истории перечисления</param>
            <returns>ОБъект, осуществляющий возможность отписаться от уведомлений изменения истории перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.SelectWithHystory``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Linq.IEnumerableExtensions.EnumerableHystory{``0},``1},System.Int32)">
            <summary>Преобразование исходной последовательности элементов с учётом указанного размера истории перечисления</summary>
            <typeparam name="TIn">Тип элементов исходной коллекции</typeparam>
            <typeparam name="TOut">Тип элементов результирующей коллекции</typeparam>
            <param name="collection">Исходная коллекция элементов</param>
            <param name="Selector">Метод преобразования элементов коллекции на основе истории их перечисления</param>
            <param name="HystoryLength">Максимальная длина истории перечисления</param>
            <returns>Коллекция элементов, сформированная на основе исходной с учётом истории процесса перчисления исходной коллекции</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetStatistic(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>Оценка статистических параметров перечисления</summary>
            <param name="collection">Перечисление значений, статистику которых требуется получить</param>
            <param name="Length">Размер выборки для оценки</param>
            <returns>Оценка статистики</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.FilterNullValuesFromEnd(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Отбросить нуллевые значения с конца перечисления</summary>
            <param name="collection">Фильтруемое перечисление</param>
            <returns>Перечисление чисел, в котором отсутствуют хвостовые нули</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},``0@,``0@)">
            <summary>Определить минимальное и максимальное значение перечисления</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="collection">Перечисление, минимум и максимум которого необходимо определить</param>
            <param name="selector">Метод преобразования объектов в вещественные числа</param>
            <param name="Min">Минимальный элемент перечисления</param>
            <param name="Max">Максимальный элемент перечисления</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},``0@,System.Int32@,``0@,System.Int32@)">
            <summary>Определить минимальное и максимальное значение перечисления</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="collection">Перечисление, минимум и максимум которого необходимо определить</param>
            <param name="selector">Метод преобразования объектов в вещественные числа</param>
            <param name="Min">Минимальный элемент перечисления</param>
            <param name="MinIndex">Индекс минимального элемента в коллекции</param>
            <param name="Max">Максимальный элемент перечисления</param>
            <param name="MaxIndex">Индекс максимального элемента в коллекции</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMax``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>Определение максимального элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод преобразования элементов в вещественные числа</param>
            <returns>Максимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMax``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},System.Int32@)">
            <summary>Определение максимального элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод преобразования элементов в вещественные числа</param>
            <param name="index">Индекс максимального элемента в последовательности</param>
            <returns>Максимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMin``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>Определение минимального элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод преобразования элементов в вещественные числа</param>
            <returns>Минимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMin``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},System.Int32@)">
            <summary>Определение минимального элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод преобразования элементов в вещественные числа</param>
            <param name="index">Индекс минимального элемента в последовательности</param>
            <returns>Минимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToSeparatedString``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>Преобразвоание последовательности элементов в строку с указанной строкой-разделителем</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов, преобразуемая в строку</param>
            <param name="Separator">Строка-разделитель</param>
            <returns>Строка, составленная из строковых эквивалентов элементов входного перечисления, разделённых строкой-разделителем</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToListFast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Быстрое преобразование последовательности в список</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="Enum">Последовательность, преобразуемая в список</param>
            <returns>Список элементов последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Sum(System.Collections.Generic.IEnumerable{MathService.Complex})">
            <summary>Сумма последовательности комплексных чисел</summary>
            <param name="collection">Последовательность комплексных чисел</param>
            <returns>Комплексное число, являющееся суммой последовательности комплексных чисел</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,System.Int32,``1},System.Int32)">
            <summary>Объединить элементы коллеции</summary>
            <typeparam name="T">Тип элемента коллекции</typeparam>
            <typeparam name="TResult">Тип результата</typeparam>
            <param name="collection">Исходная коллекция элементов</param>
            <param name="Init">Исходное состояние результата объединения</param>
            <param name="func">Метод объединения</param>
            <param name="index">Индекс элемента коллекции</param>
            <returns>Результат объединения коллекции элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Contains``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Проверка на наличие элемиента в коллекции</summary>
            <typeparam name="T">Тип элемента</typeparam>
            <param name="collection">Проверяемая коллекция</param>
            <param name="selector">Метод выбора</param>
            <returns>Истина, если выполняется предикат хотя бы на одном элементе коллекции</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Find``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Найти элемент в перечислении, удовлетворяющий предикату</summary>
            <param name="collection">Перечисление элементов</param>
            <param name="selector">Предикат выбора</param>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <returns>Найденный элемент, либо пустая ссылка</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнение действия для всех элементов коллекции</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="Action">Выполняемое действие</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``2(System.Collections.Generic.IEnumerable{``0},System.Action{``0,``1},``1)">
            <summary>Выполнение действия для всех элементов коллекции</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="Action">Выполняемое действие</param>
            <param name="parameter">Параметр действия</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <typeparam name="TParameter">Тип параметра процесса перебора</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32},System.Int32)">
            <summary>Выполнение действия для всех элементов коллекции с указанием индекса элемента</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="Action">Действие над элементом</param>
            <param name="index">Смещение индекса элемента колеекции</param>
            <typeparam name="T">Тип элемента колекции</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``2(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32,``1},``1,System.Int32)">
            <summary>Выполнение действия для всех элементов коллекции с указанием индекса элемента</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="Action">Действие над элементом</param>
            <param name="parameter">Параметр действия</param>
            <param name="index">Смещение индекса элемента колеекции</param>
            <typeparam name="T">Тип элемента колекции</typeparam>
            <typeparam name="TParameter">Тип параметра процесса перебора</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CastLazy``1(System.Collections.IEnumerable)">
            <summary>Ленивое преобразование типов, пропускающее непреобразуемые объекты</summary>
            <param name="collection">Исходное перечисление объектов</param>
            <typeparam name="T">Тип объектов входного перечисления</typeparam>
            <returns>Коллекция объектов преобразованного типа</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CastLazy``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>Ленивое преобразование типов элементов перечисления</summary>
            <typeparam name="TItem">Тип элементов входной перечисления</typeparam>
            <typeparam name="TValue">Тип элементов перечисления, в который требуется осуществить преобразвоание</typeparam>
            <param name="collection">Исходная перечисление элементов</param>
            <returns>Перечисление элементов преобразованного типа</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazyIf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>Действие, выполняемое в процессе перебора элементов для всех элементов перечисления при условии выполнения предиката</summary>
            <typeparam name="T">Ип элементов перечисления</typeparam>
            <param name="collection">ПЕречисление элементов, для которых надо выполнить действие</param>
            <param name="Predicat">Условие выполнения действия</param>
            <param name="Action">Действие, выполняемое для всех элементов перечисления</param>
            <returns>Исходное перечисление</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazy``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Отложенное выполнение указанного действия для каждого элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="Action">Выполняемое действие</param>
            <returns>Последовательность элементов, для элементов которой выполняется отложенное действие</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazyLast``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнение указанного действия на каждом шаге перебора последовательности после выдачи элемента</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="action">Действие, Выполняемое после выдачи элемента последовательности</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazy``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32},System.Int32)">
            <summary>Отложенное выполнение действия до перебора элементов последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="Action">Выполняемое действие</param>
            <param name="index">Начальный индекс элемента последовательности</param>
            <returns>Последовательность элементов, для элементов которой которой выполняется действие</returns>
        </member>
        <member name="T:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2">
            <summary>Класс вычисления значений функции для коллекции аргументов</summary>
            <typeparam name="T">Тип аргумента функции</typeparam>
            <typeparam name="TResult">Тип значения функции</typeparam>
        </member>
        <member name="T:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.EnumerableCollectionFunctionCalculatorEnumirator">
            <summary>Перечислитель коллеции рассчитанных значений функции</summary>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.EnumerableCollectionFunctionCalculatorEnumirator._Enumerator">
            <summary>Перечислитель коллекции аргументов функции</summary>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.EnumerableCollectionFunctionCalculatorEnumirator._Function">
            <summary>Вычисляемая функция</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.EnumerableCollectionFunctionCalculatorEnumirator.Current">
            <summary>Текцущий элемент коллекции значений функции</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.EnumerableCollectionFunctionCalculatorEnumirator.System#Collections#IEnumerator#Current">
            <summary>Текцущий элемент коллекции значений функции</summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.EnumerableCollectionFunctionCalculatorEnumirator.#ctor(System.Collections.Generic.IEnumerator{`0},System.Func{`0,`1})">
            <summary>Инициализация нового перечислителя колеекции рассчитанных значений функции</summary>
            <param name="Enumerator">Перечислитель коллекции аргументов области определения</param>
            <param name="f">Вычисляемая функция</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.EnumerableCollectionFunctionCalculatorEnumirator.Dispose">
            <summary>Освобождение ресурсов</summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.EnumerableCollectionFunctionCalculatorEnumirator.MoveNext">
            <summary>Переход к следующему элементу коллекции</summary>
            <returns>Истина, если переход выполнен успешно</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.EnumerableCollectionFunctionCalculatorEnumirator.Reset">
            <summary>Сброс состояния перечислителя</summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.EnumerableCollectionFunctionCalculatorEnumirator.Invariant">
            <summary>Инвариант класса</summary>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2._Collection">
            <summary>Коллекция аргументов функции</summary>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2._Function">
            <summary>Вычисляемая функция</summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1})">
            <summary>Инициализация нового потокового вычислителя функции на коллекции аргументов</summary>
            <param name="сollection">Коллекция аргументов</param>
            <param name="f">Вычисляемая функция</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.GetEnumerator">
            <summary>Получение перечислителя</summary>
            <returns>Перечислитель рассчитанных значений функции</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Неявное получение перечислителя</summary>
            <returns>Перечислитель расссчитанных значений функции</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumirableCollectionFunctionCalculator`2.Invariant">
            <summary>Инвариант класса</summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ExistingItems``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Пересечение последовательностей</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="Source">Исходная последовательность элементов</param>
            <param name="Items">Последовательность элементов, пересечение с которой вычисляется</param>
            <returns>Последовательность элементов, входящих как в первую, так и во вторую последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetUnique``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>Последовательность уникальных элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="values">Исходная последовательность элементов</param>
            <param name="Comparer">Метод сравнения элементов</param>
            <returns>Последовательность элементов, таких, что ранее они отсутствовали во входной последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetUnique``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Последовательность уникальных элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="values">Исходная последовательность элементов</param>
            <returns>Последовательность элементов, таких, что ранее они отсутствовали во входной последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.MisingItems``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Найти элементы, которые не входят во вторую последовательность</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="Source">Исходная последовательность</param>
            <param name="Items">Последовательность элементов, которых не должно быть в выходной последовательности</param>
            <returns>Последовательность элементов, которые отсутствуют во второй последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Intersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Пересечение последовательностей</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="A">Первая последовательность</param>
            <param name="B">Вторая последовательность</param>
            <returns>Массив элементов, входящих и в первую и во вторую последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ItemEquals``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Последовательности элементов поэлементно равны</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="A">Первая последовательность</param>
            <param name="B">Вторая последовательность</param>
            <returns>Истина, если последовательности равны с точностью до элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.NotIntersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>ОПределение объектов, которые не входят в пересечение двух последовательностей</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="A">Исходная последовательность</param>
            <param name="B">Вторичная последовательность</param>
            <returns>Массив элементов, входящих либо в первую, либо во вторую последовательность</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Xor``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},``0[]@,``0[]@,``0[]@,``0[]@,``0[]@,``0[]@)">
            <summary>Нахождение пересечения элементов двух последовательностей</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="A">Исходная последовательность</param>
            <param name="B">Вторичная последовательность</param>
            <param name="MissingInAFromB">Массив элементов, отсутствующих в первой последовательности</param>
            <param name="MissingInBFromA">Массив элементов, отсутствующих во второй последовательности</param>
            <param name="ExistingInAFromB">Массив элементов, присутствующих в первой последовательности</param>
            <param name="ExistingInBFromA">Массив элементов, присутствующих во второй последовательности</param>
            <param name="Intersection">Пересечение элементов</param>
            <param name="NotIntersection">Остаток от пересечения элементов</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToSeparatedStr``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>Преобразовать последовательность в строку с указанной строкой-разделителем</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность объектов, преобразуемая в строку с разделителями</param>
            <param name="Separator">Разделитель элементов в строке</param>
            <returns>Строка, составленная из строковых представлений объектов последовательности, разделённых указанной строкой-разделителем</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Найти минимум и максимум последовательности вещественых чисел</summary>
            <param name="values">Последовательность вещественных чисел</param>
            <returns>Интервал, границы которого определяют минимум и максимум значений, которые принимала входная последовательность</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AppendLast``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Добавить элемент в конец последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Исходная последовательность элементов</param>
            <param name="obj">Добавляемый объект</param>
            <returns>Последовательность, составленная из элементов исходной последовательности и добавленного элемента</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AppendLast``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Добавить последовательность элементов в конец последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="first_collection">Начальная последовательность элементов</param>
            <param name="last_collection">Завершающая последовательность элементов</param>
            <returns>Последовательность элементов, составленная из элементов первичной и вторичной последовательностей</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AppendFirst``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Добавить объект в начало перечисления</summary>
            <typeparam name="T">Тип объектов перечисления</typeparam>
            <param name="collection">Основное перечисление</param>
            <param name="obj">Объект, добавляемый в начало перечисления</param>
            <returns>Перечисление объектов, составленное из первого объекта и остального перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AppendFirst``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Добавить перечисление объектов в начало основного перечисления</summary>
            <typeparam name="T">Тип объектов перечисления</typeparam>
            <param name="last_collection">Первая последовательность объектов</param>
            <param name="first_collection">Вторая последовательность объектов</param>
            <returns>Последовательность объектов, составленная из первой последовательности, за которой следует вторая последовательность</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.InsertAtPos``1(System.Collections.Generic.IEnumerable{``0},``0,System.Int32)">
            <summary>Вставить элемент в указанное положение в последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов, в которую требуется вставить новый элемент</param>
            <param name="obj">Элемент, добавляемый в последовательность</param>
            <param name="pos">Положение в которое требуется вставить элемент</param>
            <returns>Последовательность элементов, в указанной позиции которой будет размещён указанный элемент</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ConcatInverted``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Инверсная конкатинация перечислений</summary>
            <typeparam name="T">Тип элементов перечислений</typeparam>
            <param name="FirstCollection">Исходная последовательность, добавляемая в конец</param>
            <param name="SecondCollection">Вторичная последовательность, добавляемая в начало</param>
            <returns>Последовательность элементов, составленная из элементов вторичной последовательности и элементов первичной последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Sum(System.Collections.Generic.IEnumerable{MathService.Polynom})">
            <summary>Сумма перечисления полиномов</summary>
            <param name="P">Перечисление полиномов, которые надо сложить</param>
            <returns>Полином, являющийся суммой полиномов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Multyiply(System.Collections.Generic.IEnumerable{MathService.Polynom})">
            <summary>Произведение перечисления полиномов</summary>
            <param name="P">Перечисление полиномов, которые надо перемножить</param>
            <returns>Полином, являющийся произведеним полиномов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Decimate``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>Проредить последовательность</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Прореживаемая последовательность</param>
            <param name="N">Размер выборки > 0</param>
            <param name="k">Положение в выборке (от 0 до N-1)</param>
            <returns>Последовательность из N-ых элементов выборки, стоящих на k-ом месте</returns>
        </member>
        <member name="T:System.Threading.Tasks.NotifyTaskCompletion`1">
            <summary>Класс объектов, извещающих об завершении получения значения свйоства</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="E:System.Threading.Tasks.NotifyTaskCompletion`1.PropertyChanged">
            <summary>Событие возникает при изменении значения свйоства</summary>
        </member>
        <member name="F:System.Threading.Tasks.NotifyTaskCompletion`1._Task">
            <summary>Задача получения значения свйоства</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.Task">
            <summary>Задача получения значения свйоства</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.Result">
            <summary>Результат задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.Status">
            <summary>Статус задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.IsCompleted">
            <summary>Признак завершения задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.IsNotCompleted">
            <summary>Признак незавершённости задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.IsSuccessfullyCompleted">
            <summary>Признак успешного завершения задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.IsCanceled">
            <summary>Признак отмены задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.IsFaulted">
            <summary>Признак наличия ошибки при выполнении задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.Exception">
            <summary>Ошибки, полученные в результате выполнения задачи</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.InnerException">
            <summary>Ошибка, породившая основное исключение</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.InnerExceptions">
            <summary>Список произошедших исключений</summary>
        </member>
        <member name="P:System.Threading.Tasks.NotifyTaskCompletion`1.ErrorMessage">
            <summary>Сообщение об ошибке</summary>
        </member>
        <member name="M:System.Threading.Tasks.NotifyTaskCompletion`1.#ctor(System.Threading.Tasks.Task{`0})">
            <summary>Инициализация экземпляра объекта, следящего за выполнением задачи получения значений</summary>
            <param name="task">Задача получения значения</param>
        </member>
        <member name="M:System.Threading.Tasks.NotifyTaskCompletion`1.WatchTaskAsync(System.Threading.Tasks.Task)">
            <summary>Метод слежения за задачей</summary>
            <param name="task">Отслеживаемая задача получения значения</param>
            <returns>Задача отслеживания задачи полуения данных</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Select``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
            https://blogs.msdn.microsoft.com/pfxteam/2010/04/04/a-tour-of-parallelextensionsextras/
        </member>
        <member name="T:System.Threading.Tasks.TaskEx.OneElementGrouping`2">
            <summary>Represents a grouping of one element.</summary>
            <typeparam name="TKey">The type of the key for the element.</typeparam>
            <typeparam name="TElement">The type of the element.</typeparam>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ContinueWith(System.Threading.Tasks.Task,System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskFactory)">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="ContinuationAction">The continuation action.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ContinueWith``1(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskFactory)">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="ContinuationFunction">The continuation function.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ContinueWith``1(System.Threading.Tasks.Task{``0},System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskFactory{``0})">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="ContinuationAction">The continuation action.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ContinueWith``2(System.Threading.Tasks.Task{``0},System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskFactory{``0})">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="ContinuationFunction">The continuation function.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ToAsync(System.Threading.Tasks.Task,System.AsyncCallback,System.Object)">
            <summary>
            Creates a Task that represents the completion of another Task, and 
            that schedules an AsyncCallback to run upon completion.
            </summary>
            <param name="task">The antecedent Task.</param>
            <param name="callback">The AsyncCallback to run.</param>
            <param name="state">The object state to use with the AsyncCallback.</param>
            <returns>The new task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ToAsync``1(System.Threading.Tasks.Task{``0},System.AsyncCallback,System.Object)">
            <summary>
            Creates a Task that represents the completion of another Task, and 
            that schedules an AsyncCallback to run upon completion.
            </summary>
            <param name="task">The antecedent Task.</param>
            <param name="callback">The AsyncCallback to run.</param>
            <param name="state">The object state to use with the AsyncCallback.</param>
            <returns>The new task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.IgnoreExceptions(System.Threading.Tasks.Task)">
            <summary>Suppresses default exception handling of a Task that would otherwise reraise the exception on the finalizer thread.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.IgnoreExceptions``1(System.Threading.Tasks.Task{``0})">
            <summary>Suppresses default exception handling of a Task that would otherwise reraise the exception on the finalizer thread.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.FailFastOnException(System.Threading.Tasks.Task)">
            <summary>Fails immediately when an exception is encountered.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.FailFastOnException``1(System.Threading.Tasks.Task{``0})">
            <summary>Fails immediately when an exception is encountered.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.PropagateExceptions(System.Threading.Tasks.Task)">
            <summary>Propagates any exceptions that occurred on the specified task.</summary>
            <param name="task">The Task whose exceptions are to be propagated.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.PropagateExceptions(System.Threading.Tasks.Task[])">
            <summary>Propagates any exceptions that occurred on the specified tasks.</summary>
            <param name="tasks">The Tassk whose exceptions are to be propagated.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ToObservable``1(System.Threading.Tasks.Task{``0})">
            <summary>Creates an IObservable that represents the completion of a Task.</summary>
            <typeparam name="TResult">Specifies the type of data returned by the Task.</typeparam>
            <param name="task">The Task to be represented as an IObservable.</param>
            <returns>An IObservable that represents the completion of the Task.</returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskEx.TaskObservable`1">
            <summary>An implementation of IObservable that wraps a Task.</summary>
            <typeparam name="TResult">The type of data returned by the task.</typeparam>
        </member>
        <member name="T:System.Threading.Tasks.TaskEx.CancelOnDispose">
            <summary>Translate a call to IDisposable.Dispose to a CancellationTokenSource.Cancel.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.WithTimeout(System.Threading.Tasks.Task,System.TimeSpan@)">
            <summary>Creates a new Task that mirrors the supplied task but that will be canceled after the specified timeout.</summary>
            <param name="task">The task.</param>
            <param name="timeout">The timeout.</param>
            <returns>The new Task that may time out.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.WithTimeout``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
            <summary>Creates a new Task that mirrors the supplied task but that will be canceled after the specified timeout.</summary>
            <typeparam name="TResult">Specifies the type of data contained in the task.</typeparam>
            <param name="task">The task.</param>
            <param name="timeout">The timeout.</param>
            <returns>The new Task that may time out.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.AttachToParent(System.Threading.Tasks.Task)">
            <summary>
            Ensures that a parent task can't transition into a completed state
            until the specified task has also completed, even if it's not
            already a child task.
            </summary>
            <param name="task">The task to attach to the current task as a child.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.WaitForCompletionStatus(System.Threading.Tasks.Task)">
            <summary>Waits for the task to complete execution, returning the task's final status.</summary>
            <param name="task">The task for which to wait.</param>
            <returns>The completion status of the task.</returns>
            <remarks>Unlike Wait, this method will not throw an exception if the task ends in the Faulted or Canceled state.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then(System.Threading.Tasks.Task,System.Action)">
            <summary>Creates a task that represents the completion of a follow-up action when a task completes.</summary>
            <param name="task">The task.</param>
            <param name="next">The action to run when the task completes.</param>
            <returns>The task that represents the completion of both the task and the action.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``1(System.Threading.Tasks.Task,System.Func{``0})">
            <summary>Creates a task that represents the completion of a follow-up function when a task completes.</summary>
            <param name="task">The task.</param>
            <param name="next">The function to run when the task completes.</param>
            <returns>The task that represents the completion of both the task and the function.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``1(System.Threading.Tasks.Task{``0},System.Action{``0})">
            <summary>Creates a task that represents the completion of a follow-up action when a task completes.</summary>
            <param name="task">The task.</param>
            <param name="next">The action to run when the task completes.</param>
            <returns>The task that represents the completion of both the task and the action.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
            <summary>Creates a task that represents the completion of a follow-up function when a task completes.</summary>
            <param name="task">The task.</param>
            <param name="next">The function to run when the task completes.</param>
            <returns>The task that represents the completion of both the task and the function.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task})">
            <summary>Creates a task that represents the completion of a second task when a first task completes.</summary>
            <param name="task">The first task.</param>
            <param name="next">The function that produces the second task.</param>
            <returns>The task that represents the completion of both the first and second task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``1(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task})">
            <summary>Creates a task that represents the completion of a second task when a first task completes.</summary>
            <param name="task">The first task.</param>
            <param name="next">The function that produces the second task based on the result of the first task.</param>
            <returns>The task that represents the completion of both the first and second task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``1(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>Creates a task that represents the completion of a second task when a first task completes.</summary>
            <param name="task">The first task.</param>
            <param name="next">The function that produces the second task.</param>
            <returns>The task that represents the completion of both the first and second task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``2(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>Creates a task that represents the completion of a second task when a first task completes.</summary>
            <param name="task">The first task.</param>
            <param name="next">The function that produces the second task based on the result of the first.</param>
            <returns>The task that represents the completion of both the first and second task.</returns>
        </member>
        <member name="T:System.Threading.Tasks.CancellationTokenExtensions">
            <summary>Extension methods for CancellationToken.</summary>
        </member>
        <member name="M:System.Threading.Tasks.CancellationTokenExtensions.CancelAndThrow(System.Threading.CancellationTokenSource)">
            <summary>Cancels a CancellationTokenSource and throws a corresponding OperationCanceledException.</summary>
            <param name="source">The source to be canceled.</param>
        </member>
        <member name="M:System.Threading.Tasks.CancellationTokenExtensions.CreateLinkedSource(System.Threading.CancellationToken)">
            <summary>Creates a CancellationTokenSource that will be canceled when the specified token has cancellation requested.</summary>
            <param name="token">The token.</param>
            <returns>The created CancellationTokenSource.</returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskCompletionSourceExtensions">
            <summary>Extension methods for TaskCompletionSource.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSourceExtensions.SetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task)">
            <summary>Transfers the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="ResultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transfered.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSourceExtensions.SetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task{``0})">
            <summary>Transfers the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="ResultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transfered.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSourceExtensions.TrySetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task)">
            <summary>Attempts to transfer the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="ResultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transfered.</param>
            <returns>Whether the transfer could be completed.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSourceExtensions.TrySetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task{``0})">
            <summary>Attempts to transfer the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="ResultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transfered.</param>
            <returns>Whether the transfer could be completed.</returns>
        </member>
        <member name="T:System.ComponentModel.INotifyPropertyChangedExtensions">
            <summary>Класс методов-расширений интерфейса <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String)">
            <summary>Подписка на событие изменения указанного свйоства</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Name">Имя свйоства</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler_Disposable(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String)">
            <summary>Подписка на событие изменения указанного свйоства</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Name">Имя свйоства</param>
            <returns>Объект <see cref="T:System.IDisposable"/>, вызывающий отписку от события в случае своего уничтожения</returns>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String[])">
            <summary>Подписка на событие изменения указанных свйоств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свйоств</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler_Disposable(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String[])">
            <summary>Подписка на событие изменения указанных свйоств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свйоств</param>
            <returns>Объект <see cref="T:System.IDisposable"/>, вызывающий отписку от события в случае своего уничтожения</returns>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Подписка на событие изменения указанных свйоств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свйоств</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler_Disposable(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Подписка на событие изменения указанных свйоств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свйоств</param>
            <returns>Объект <see cref="T:System.IDisposable"/>, вызывающий отписку от события в случае своего уничтожения</returns>
        </member>
        <member name="T:System.ComponentModel.INotifyPropertyChangedExtensions.DependentPropertyChangedEventArgs">
            <summary>Аргумент события изменения зависимого свойства</summary>
        </member>
        <member name="P:System.ComponentModel.INotifyPropertyChangedExtensions.DependentPropertyChangedEventArgs.FromProperties">
            <summary>Перечень свойств, породивших изменение</summary>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.DependentPropertyChangedEventArgs.#ctor(System.String,System.String[])">
            <summary>Инициализация нового аргумента события изменения зависимого свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
            <param name="FromProperties">Список свойств, породивших изменение</param>
        </member>
        <member name="F:System.ComponentModel.INotifyPropertyChangedExtensions.__ObjectsSet">
            <summary>Перечень слабых ссылок на отслеживаемые объекты</summary>
        </member>
        <member name="F:System.ComponentModel.INotifyPropertyChangedExtensions.__RegistrationPool">
            <summary>Словарь описаний связей между свойствами типов</summary>
        </member>
        <member name="T:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo">
            <summary>Информация о связях между свойствами типов</summary>
        </member>
        <member name="F:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo._Dependences">
            <summary>Словарь связей имён свойств типа</summary>
        </member>
        <member name="F:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo._Handler">
            <summary>Обработчик события изменения свойства объекта</summary>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo.#ctor(System.Collections.Generic.Dictionary{System.String,System.String[]})">
            <summary>Инициализация нового экземпляра информации и связях между свойствами типа</summary>
            <param name="Dependences">Словарь имён свойст зависимостей</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo.Subscribe(System.ComponentModel.INotifyPropertyChanged,System.Action{System.ComponentModel.PropertyChangedEventArgs})">
            <summary>Метод установки обработчика событий обновления свойства объекта, генерирующего вторичные события обновления зависимых свойств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="OnPropertyChanged">Метод генерации события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> в объекте <paramref name="obj"/></param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo.UnSubscrige(System.ComponentModel.INotifyPropertyChanged)">
            <summary>Отписка от события обновления свойств объекта</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.OnGarbageCollected(System.Object,System.EventArgs)">
            <summary>Обработка событий слорки мусора в системе</summary>
            <param name="Sender">Источник события - не используется</param>
            <param name="e">Аргумент события - не используется</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.PropertyDependences_Register``1(``0,System.Action{System.ComponentModel.PropertyChangedEventArgs})">
            <summary>
            Создание связей между свойствами объекта на основе атрибутов <see cref="T:System.AffectsTheAttribute"/> и <see cref="T:System.DependencyOnAttribute"/>
            </summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="OnPropertyChanged">Метод генерации события обновления свойства</param>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.PropertyDependences_Register_Disposable``1(``0,System.Action{System.ComponentModel.PropertyChangedEventArgs})">
            <summary>
            Создание связей между свойствами объекта на основе атрибутов <see cref="T:System.AffectsTheAttribute"/> и <see cref="T:System.DependencyOnAttribute"/>
            </summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="OnPropertyChanged">Метод генерации события обновления свойства</param>
            <typeparam name="T">Тип объекта</typeparam>
            <returns></returns>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.PropertyDependences_Unregister``1(``0)">
            <summary>
            Разрушение связей между свойствами, созданными методом <see cref="M:System.ComponentModel.INotifyPropertyChangedExtensions.PropertyDependences_Register``1(``0,System.Action{System.ComponentModel.PropertyChangedEventArgs})"/>
            </summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.GetRegistrator(System.Type)">
            <summary>Метод получения информации о связях между свойствами объекта класса</summary>
            <param name="type">Тип рассматриваемого объекта</param>
            <returns>Информация о связях между свойствами объекта</returns>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.SubscribeTo``1(``0,System.String,System.ComponentModel.PropertyChangedEventHandler)">
            <summary>Подписаться на событие изменения свойства</summary>
            <typeparam name="T">Тип объекта, генерирующего событие</typeparam>
            <param name="obj">Объект, на событие изменения свойств которого производится подписка</param>
            <param name="PropertyName">Имя отслеживаемого свойства</param>
            <param name="Handler">ОБработчик события</param>
        </member>
        <member name="M:System.EnumExtensions.GetValueAttribute``1(System.Enum)">
            <exception cref="T:System.TypeLoadException">A custom attribute type cannot be loaded. </exception>
            <exception cref="T:System.InvalidOperationException">This member belongs to a type that is loaded into the reflection-only context. See How to: Load Assemblies into the Reflection-Only Context.</exception>
        </member>
        <member name="M:System.EnumExtensions.GetValueDescription(System.Enum)">
            <exception cref="T:System.TypeLoadException">A custom attribute type cannot be loaded. </exception>
        </member>
        <member name="T:System.EventHandlerTyped1Extension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.Start``2(System.EventHandler{``0,``1},``0,System.EventArgs{``1})">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.StartAsync``2(System.EventHandler{``0,``1},``0,System.EventArgs{``1},System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, Передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.FastStart``2(System.EventHandler{``0,``1},``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.FastStart``2(System.EventHandler{``0,``1},``0,System.EventArgs{``1})">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:System.EventHandlerTyped2Exsension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerTyped2Exsension.Start``3(System.EventHandler{``0,``1,``2},``0,System.EventArgs{``1,``2})">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerTyped2Exsension.StartAsync``3(System.EventHandler{``0,``1,``2},``0,System.EventArgs{``1,``2},System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, Передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerTyped2Exsension.FastStart``3(System.EventHandler{``0,``1,``2},``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerTyped2Exsension.FastStart``3(System.EventHandler{``0,``1,``2},``0,System.EventArgs{``1,``2})">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:System.EventHandlerTyped3Extension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.Start``4(System.EventHandler{``0,``1,``2,``3},``0,System.EventArgs{``1,``2,``3})">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.StartAsync``4(System.EventHandler{``0,``1,``2,``3},``0,System.EventArgs{``1,``2,``3},System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, Передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.FastStart``4(System.EventHandler{``0,``1,``2,``3},``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.FastStart``4(System.EventHandler{``0,``1,``2,``3},``0,System.EventArgs{``1,``2,``3})">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:System.IComparableExtensions">
            <summary>Класс методов-расширений для сравнимых объектов</summary>
        </member>
        <member name="M:System.IComparableExtensions.Search``1(``0[],System.Int32,System.Int32,``0)">
            <summary>Метод поиска элемента в упорядоченной коллекции половинным делением</summary>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <param name="Collection">Массив элементов, упорядоченный по возростанию</param>
            <param name="From">Начальный индекс поиска</param>
            <param name="To">КОнечный индекс поиска</param>
            <param name="Item">Искомый элемент</param>
            <returns>Индекс элемента в массиве</returns>
        </member>
        <member name="M:System.IO.StreamExtensions.GetBufferedStream(System.IO.Stream,System.Int32)">
            <summary>
            Создать буферизованный поток данных
            </summary>
            <param name="DataStream">Исходный поток данных</param>
            <param name="BufferSize">Размер буфера (по умолчанию 4096 байта)</param>
            <returns>Буферизованный поток данных</returns>
        </member>
        <member name="M:System.IO.BinaryReaderExtensions.IsEOF(System.IO.BinaryReader)">
            <summary>
            Признак конца потока
            </summary>
            <param name="reader">Объект чтения потока</param>
            <returns>Истина, если поток закончен</returns>
        </member>
        <member name="M:System.IO.BinaryReaderExtensions.GetByteBuffer(System.IO.BinaryReader,System.Int32)">
            <summary>
            Получить перечисление, содержащее массивы байт заданной длины из потока 
            </summary>
            <param name="reader">Объект чтения потока данных</param>
            <param name="BufferSize">Размер буфера</param>
            <returns>Перечислитель</returns>
        </member>
        <member name="T:System.IO.DirectoryInfoExsentions">
            <summary>Класс методов-расширений для объектов класса System.IO.DirectoryInfo</summary>
        </member>
        <member name="M:System.IO.DirectoryInfoExsentions.GetFilesCount(System.IO.DirectoryInfo)">
            <summary>Определить число всех вложенных файлов</summary>
            <param name="Directory">Исследуемая дирректория</param>
            <returns>Число файлов во всех вложенных поддиректориях</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExsentions.GetSize(System.IO.DirectoryInfo)">
            <summary>Определить объём всех вложенных файлов включая поддиректории</summary>
            <param name="Directory">Исследуемая дирректория</param>
            <returns>Число байт всех вложенных файлов</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExsentions.GetSubdirectoriesCount(System.IO.DirectoryInfo)">
            <summary>Определить число поддерикторий</summary>
            <param name="Directory">Исследуемая дирректория</param>
            <returns>Число элементов в дереве поддерикторий</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExsentions.IsEmpty(System.IO.DirectoryInfo)">
            <summary>Проверить - является ли дирректория пустой</summary>
            <param name="Directory">Проверяемая дирректория</param>
            <returns>Истина, если дирректория пуста</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExsentions.GetWacher(System.IO.DirectoryInfo,System.String)">
            <summary>Получить объект наблюдения за дирректорией</summary>
            <param name="directory">Наблюдаемая дирректория</param>
            <param name="filter">Фильтр файлов</param>
            <returns>Объект наблюдатель</returns>
        </member>
        <member name="T:System.IO.FileInfoExtensions">
            <summary>Класс методов расширений для объектов класса System.IO.FileInfo</summary>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.DirectoryInfo)">
            <summary>Скопировать файл в дирректорию</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationDirectory">Дирректория назначения</param>
            <returns>Файл копия</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.DirectoryInfo,System.Boolean)">
            <summary>Скопировать файл в дирректорию</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationDirectory">Дирректория назначения</param>
            <param name="Owerride">Перезаписать в случае наличия файла</param>
            <returns>Файл копия</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>Скопировать файл</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationFile">Файл копия</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.FileInfo,System.Boolean)">
            <summary>Скопировать файл</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationFile">Файл копия</param>
            <param name="Owerride">Перезаписать в случае наличия файла</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetFileNameWithoutExtension(System.IO.FileInfo)">
            <summary>Получить имя файла без расширения</summary>
            <param name="file">Файл</param>
            <returns>Имя файла без расширения</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetFullFileNameWithoutExtension(System.IO.FileInfo)">
            <summary>Получить имя файла без расширения</summary>
            <param name="file">Файл</param>
            <returns>Имя файла без расширения</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetFullFileNameWithNewExtension(System.IO.FileInfo,System.String)">
            <summary>Получить имя файла c новым расширением</summary>
            <param name="file">Файл</param>
            <param name="NewExt">Новое расширение файла в формате ".exe"</param>
            <returns>Имя файла без расширения</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.WriteAllBytes(System.IO.FileInfo,System.Byte[],System.Boolean)">
            <summary>Записать массив байт в файл</summary>
            <param name="file">Файл данных</param>
            <param name="Data">Данные</param>
            <param name="Append">Если истина, то данные будут добавлены в конец файла</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.WriteAllBytes(System.IO.FileInfo,System.IO.Stream,System.Int32,System.Boolean,System.Func{System.Int64,System.Byte[],System.Boolean},System.EventHandler{System.EventArgs{System.IO.FileInfo,System.IO.Stream}})">
            <summary>Записать все данные из потока в файл</summary>
            <param name="file">Файл данных</param>
            <param name="DataStream">Поток - источник данных</param>
            <param name="BufferSize">Размер буфера чтения по умолчанию 1024 байта</param>
            <param name="Append">Флаг добавления данных в конец файла</param>
            <param name="CompliteHandler">
            Обработчик текущего положения коретки чтения данных из потока. 
            Вызывается после чтения данных в буфер и до помещения их в файл.
            Должен вернуть истину, что бы данные были переданы в файл и процесс был продолжен.
            </param>
            <param name="OnComplite">Обработчик события завершения процесса записи данных</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetWatcher(System.IO.FileInfo)">
            <summary>Получить объект наблюдения за файлом</summary>
            <param name="file">Наблюдаемый файл</param>
            <returns>Объект наблюдатель</returns>
        </member>
        <member name="M:System.RandomExtensions.NextNormal(System.Random,System.Double,System.Double)">
            <summary>
            Generates normally distributed numbers. Each operation makes two Gaussians for the price of one, and apparently they can be cached or something for better performance, but who cares.
            </summary>
            <param name="rnd"></param>
            <param name="mu">Mean of the distribution</param>
            <param name="sigma">Standard deviation</param>
            <returns></returns>
        </member>
        <member name="M:System.RandomExtensions.NextTriangular(System.Random,System.Double,System.Double,System.Double)">
            <summary>Generates values from a triangular distribution.</summary>
            <remarks>
            See http://en.wikipedia.org/wiki/Triangular_distribution for a description of the triangular probability distribution and the algorithm for generating one.
            </remarks>
            <param name="rnd"></param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
            <param name="mode">Mode (most frequent value)</param>
            <returns></returns>
        </member>
        <member name="M:System.RandomExtensions.NextBoolean(System.Random)">
            <summary>
              Equally likely to return true or false. Uses <see cref="M:System.Random.Next"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.RandomExtensions.Shuffle(System.Random,System.Collections.IList)">
            <summary>
              Shuffles a list in O(n) time by using the Fisher-Yates/Knuth algorithm.
            </summary>
            <param name="rnd"></param>
            <param name = "list"></param>
        </member>
        <member name="M:System.RandomExtensions.Permutation(System.Random,System.Int32,System.Int32)">
            <summary>
            Returns n unique random numbers in the range [1, n], inclusive. 
            This is equivalent to getting the first n numbers of some random permutation of the sequential numbers from 1 to max. 
            Runs in O(k^2) time.
            </summary>
            <param name="rnd"></param>
            <param name="n">Maximum number possible.</param>
            <param name="k">How many numbers to return.</param>
            <returns></returns>
        </member>
        <member name="T:System.Xml.Serialization.IXmlSerializableAsync">
            <summary>Асинхронно сериализуемый в XML объект</summary>
        </member>
        <member name="M:System.Xml.Serialization.IXmlSerializableAsync.ReadXmlAsync(System.Xml.XmlReader)">
            <summary>Асинхронное чтение данных из XML</summary>
            <param name="reader">Источник данных XML</param>
            <returns>Задача процесса чтения данных</returns>
        </member>
        <member name="M:System.Xml.Serialization.IXmlSerializableAsync.WriteXmlAsync(System.Xml.XmlWriter)">
            <summary>Асинхронная запись данных в XML</summary>
            <param name="writer">Объект записи данных</param>
            <returns>Задача записи данных</returns>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializerExtentions">
            <summary>Класс методов-расширений для XML-сериализаторов</summary>
        </member>
        <member name="F:System.Xml.Serialization.XmlSerializerExtentions.__LockObject">
            <summary>Объект межпоточной блокировки доступа</summary>
        </member>
        <member name="F:System.Xml.Serialization.XmlSerializerExtentions.__XmlSerializersPool">
            <summary>Словарь типов - сериализаторов</summary>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerExtentions.GetXmlSerializer(System.Type)">
            <summary>Получить XML-сериализатор по указанному типу</summary>
            <param name="type">Тип XML-сериализатора</param>
            <returns>XML-сериализатор</returns>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerExtentions.GetXmlSerializer``1">
            <summary>Получить XML-сериализатор по указанному типу</summary>
            <param name="type">Тип XML-сериализатора</param>
            <returns>XML-сериализатор</returns>
        </member>
        <member name="M:System.Xml.XPath.ChildQuery.GetValue(System.Xml.XPath.XPathReader)">
            <exception cref="T:System.Xml.XPath.XPathReaderException">Can't get the child value</exception>
        </member>
        <member name="M:System.Xml.XPath.DescendantQuery.GetValue(System.Xml.XPath.XPathReader)">
            <exception cref="T:System.Xml.XPath.XPathReaderException">Can't get the decendent nodes value</exception>
        </member>
        <member name="M:System.Xml.XPath.FilterQuery.GetValue(System.Xml.XPath.XPathReader)">
            <exception cref="T:System.Xml.XPath.XPathReaderException">Can't get value</exception>
        </member>
        <member name="M:System.Xml.XPath.QueryBuilder.ProcessAxis(System.Xml.XPath.Axis,System.Xml.XPath.Query)">
            
        </member>
        <member name="T:System.Xml.XPath.XmlCaseOrder">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlCaseOrder.None">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlCaseOrder.UpperFirst">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlCaseOrder.LowerFirst">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XPath.XmlCharType">
            <internalonly />
            <devdoc>
            </devdoc>
        </member>
        <member name="T:System.Xml.XPath.XmlDataType">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlDataType.Text">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlDataType.Number">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathCollection.MatchesAny(System.Collections.ArrayList,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:System.Xml.XPath.XPathParser.ParseXPathExpresion(System.String)">
            <exception cref="T:System.Xml.XPath.XPathException"><see cref="P:System.Xml.XPath.XPathScanner.SourceText"/>  has an invalid token</exception>
        </member>
        <member name="M:System.Xml.XPath.XPathParser.ParseXPathPattern(System.String)">
            <exception cref="T:System.Xml.XPath.XPathException"><see cref="P:System.Xml.XPath.XPathScanner.SourceText"/>  has an invalid token</exception>
        </member>
        <member name="P:System.Xml.XPath.XPathQuery.GetXPathQueries">
            use can store this compiled expression to query other documents
        </member>
        <member name="P:System.Xml.XPath.XPathReader.NodeType">
            <devdoc>
                <para>
                    Gets the type of the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Name">
            <devdoc>
                <para>
                    Gets the name of
                    the current node, including the namespace prefix.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.LocalName">
            <devdoc>
                <para>
                    Gets the name of the current node without the namespace prefix.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.NamespaceURI">
            <devdoc>
                <para>
                    Gets the namespace URN (as defined in the W3C Namespace Specification) of the current namespace scope.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Prefix">
            <devdoc>
                <para>
                    Gets the namespace prefix associated with the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.HasValue">
            <devdoc>
                <para>
                    Gets a value indicating whether
                    <see cref='P:System.Xml.XPath.XPathReader.Value' /> has a value to return.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Value">
            <devdoc>
                <para>
                    Gets the text value of the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Depth">
            <devdoc>
                <para>
                    Gets the depth of the
                    current node in the XML element stack.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.BaseURI">
            <devdoc>
                <para>
                    Gets the base URI of the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.IsEmptyElement">
            <devdoc>
                <para>
                    Gets a value indicating whether
                    the current
                    node is an empty element (for example, &lt;MyElement/&gt;).
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.IsDefault">
            <devdoc>
                <para>
                    Gets a value indicating whether the current node is an
                    attribute that was generated from the default value defined
                    in the DTD or schema.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.QuoteChar">
            <devdoc>
                <para>
                    Gets the quotation mark character used to enclose the value of an attribute
                    node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.XmlSpace">
            <devdoc>
                <para>Gets the current xml:space scope.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.XmlLang">
            <devdoc>
                <para>Gets the current xml:lang scope.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.AttributeCount">
            <devdoc>
                <para> The number of attributes on the current node.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Item(System.Int32)">
            <devdoc>
                <para>Gets the value of the attribute with the specified index.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Item(System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the specified
                    <see cref='P:System.Xml.XPath.XPathReader.Name' /> .
                </para>
            </devdoc>
            <exception cref="T:System.InvalidOperationException">
                An <see cref="T:System.Xml.XmlReader" /> method was called before a
                previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" /> is thrown
                with the message “An asynchronous operation is already in progress.”
            </exception>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Item(System.String,System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the
                    specified <see cref='P:System.Xml.XPath.XPathReader.LocalName' /> and
                    <see cref='P:System.Xml.XPath.XPathReader.NamespaceURI' /> .
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.EOF">
            <devdoc>
                <para>
                    Gets
                    a value indicating whether XmlReader is positioned at the end of the
                    stream.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.ReadState">
            <devdoc>
                <para>
                    Returns
                    the read state of the stream.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.NameTable">
            <devdoc>
                <para>
                    Gets the XmlNameTable associated with this
                    implementation.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.Xml.XmlReader,System.Xml.XPath.XPathCollection)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.String,System.String)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.IO.TextReader,System.String)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.String,System.Xml.XPath.XPathCollection)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Match(System.Int32)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Match(System.String)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Match(System.Xml.XPath.XPathQuery)">
            <internalonly />
            <devdoc>
                <para>return true when the </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MatchesAny(System.Collections.ArrayList)">
            <internalonly />
            <devdoc>
                <para> return true if one of the queries matches with the XmlReader context. </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadUntilMatch">
            <internalonly />
            <devdoc>
                <para> return true if one of the queries matches with the XmlReader context. </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Read">
            <devdoc>
                <para>
                    Reads the next
                    node from the stream.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToAttribute(System.String)">
            <devdoc>
                <para>Moves to the attribute with the specified <see cref='P:System.Xml.XPath.XPathReader.Name' /> .</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToAttribute(System.String,System.String)">
            <devdoc>
                <para>
                    Moves to the attribute with the specified <see cref='P:System.Xml.XPath.XPathReader.LocalName' />
                    and <see cref='P:System.Xml.XPath.XPathReader.NamespaceURI' /> .
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToAttribute(System.Int32)">
            <devdoc>
                <para>Moves to the attribute with the specified index.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToFirstAttribute">
            <devdoc>
                <para>
                    Moves to the first attribute.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToNextAttribute">
            <devdoc>
                <para>
                    Moves to the next attribute.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToElement">
            <devdoc>
                <para>
                    Moves to the element that contains the current attribute node.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.GetAttribute(System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the specified
                    <see cref='P:System.Xml.XPath.XPathReader.Name' /> .
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.GetAttribute(System.String,System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the
                    specified <see cref='P:System.Xml.XPath.XPathReader.LocalName' /> and
                    <see cref='P:System.Xml.XPath.XPathReader.NamespaceURI' /> .
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.GetAttribute(System.Int32)">
            <devdoc>
                <para>Gets the value of the attribute with the specified index.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Close">
            <devdoc>
                <para>
                    Closes the stream, changes the <see cref='P:System.Xml.XPath.XPathReader.ReadState' />
                    to Closed, and sets all the properties back to zero.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadString">
            <devdoc>
                <para>Reads the contents of an element as a string.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.LookupNamespace(System.String)">
            <devdoc>
                <para>
                    Resolves a namespace prefix in the current element's scope.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ResolveEntity">
            <devdoc>
                <para>Resolves the entity reference for nodes of NodeType EntityReference.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadAttributeValue">
            <devdoc>
                <para>
                    Parses the attribute value into one or more Text and/or EntityReference node
                    types.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadInnerXml">
            <devdoc>
                <para>Reads all the content (including markup) as a string.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadOuterXml">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XmlReaderWrapper.Close">
            <inheritdoc />
        </member>
        <member name="T:System.Xml.XPath.XPathReaderException">
            <devdoc>
                <para>
                    Represents the exception that is thrown when there is error processing an
                    XPath expression.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Text.RegularExpressions.RegExExtentions.OrDefault(System.Text.RegularExpressions.Match,System.String)">
            <summary>Метод получения значения из результатов совпадения поиска</summary>
            <param name="match">Результат совпадения поиска</param>
            <param name="DefaultString">Значение по умолчанию</param>
            <returns>Результат поска, либо значение по умолчанию</returns>
        </member>
        <member name="T:System.LambdaDisposable">
            <summary>Объект, выполняющий указанное действие при сборке мусора</summary>
        </member>
        <member name="M:System.LambdaDisposable.#ctor(System.Action)">
            <summary>Инициализация нового уничтожаемого объекта с указанием действия при уничтожении</summary>
            <param name="DisposableAction">Дейтсвие, выполняемое при уничтожении объекта</param>
        </member>
        <member name="M:System.LambdaDisposable.Dispose">
            <summary>Метод уничтожения объекта, вызывающий указанное действие</summary>
        </member>
        <member name="M:System.LambdaDisposableObject`1.Dispose">
            <inheritdoc />
        </member>
        <member name="T:System.AxiomAttribute">
            <summary>Помеенное данным атрибутом не требует доказательств, или проверок</summary>
        </member>
        <member name="P:System.AxiomAttribute.Comment">
            <summary>Дополнительный комментарий</summary>
        </member>
        <member name="M:System.AxiomAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.AxiomAttribute"/></summary>
        </member>
        <member name="M:System.AxiomAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.AxiomAttribute"/></summary>
            <param name="Comment">Дополнительный комментарий</param>
        </member>
        <member name="M:System.AxiomAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.CopyrightAttribute">
            <summary>Сведения об автораских правах на участок кода</summary>
        </member>
        <member name="P:System.CopyrightAttribute.Copyright">
            <summary>Авторские права</summary>
        </member>
        <member name="P:System.CopyrightAttribute.url">
            <summary>Ссылка на источник</summary>
        </member>
        <member name="M:System.CopyrightAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.CopyrightAttribute"/></summary>
            <param name="Copyright">Авторские права</param>
        </member>
        <member name="M:System.CopyrightAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.ElementDescriptionAttribute">
            <summary>Описание</summary>
        </member>
        <member name="P:System.ElementDescriptionAttribute.Description">
            <summary>Описание</summary>
        </member>
        <member name="M:System.ElementDescriptionAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="!:"/></summary> 
        </member>
        <member name="M:System.ElementDescriptionAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="!:"/></summary>
            <param name="Description">Описание</param>
        </member>
        <member name="M:System.ElementDescriptionAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.ElementDescriptionAttribute.ContractInvariantMethod">
            <summary>Инвариант класса</summary>
        </member>
        <member name="T:System.HyperlinkAttribute">
            <summary>Ссылка</summary>
        </member>
        <member name="P:System.HyperlinkAttribute.Link">
            <summary>Ссылка</summary>
        </member>
        <member name="M:System.HyperlinkAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.HyperlinkAttribute"/></summary>
        </member>
        <member name="M:System.HyperlinkAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.HyperlinkAttribute"/></summary>
            <param name="Link">Текст ссылки</param>
        </member>
        <member name="M:System.HyperlinkAttribute.op_Implicit(System.HyperlinkAttribute)~System.Uri">
            <summary>Оператор неявного приведения типа <see cref="T:System.HyperlinkAttribute"/> к <see cref="T:System.Uri"/></summary>
            <param name="A">Атрибут ссылки, преобразуемый в <see cref="T:System.Uri"/></param>
        </member>
        <member name="T:System.NotImplementedAttribute">
            <summary>Атрибут признака нереализованности</summary>
        </member>
        <member name="P:System.NotImplementedAttribute.Message">
            <summary>Сообщение</summary>
        </member>
        <member name="M:System.NotImplementedAttribute.#ctor">
            <summary>Новый атрибут нереализованности</summary>
        </member>
        <member name="M:System.NotImplementedAttribute.#ctor(System.String)">
            <summary>Новый атрибут нереализованности</summary>
            <param name="Message">Сообщение (почему не раелизовано?)</param>
        </member>
        <member name="M:System.NotImplementedAttribute.IsDefaultAttribute">
            <summary>Признак атрибута "по умолчанию"</summary>
            <returns>Истина, если указан незаполненный атрибут</returns>
        </member>
        <member name="T:System.EventHandlerArgs`2">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgs">Тип аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandlerArgs`3">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TResult">Тип результата события</typeparam>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgs">Тип аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
            <returns>Результат события</returns>
        </member>
        <member name="T:System.EventHandler`2">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TEventParameter">Тип параметра аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`3">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TEventParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TEventParameter2">Тип параметра 2 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`4">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TEventParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TEventParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TEventParameter3">Тип параметра 3 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.ExceptionEventHandler`1">
            <summary>Обработчик событий генерации исключения</summary>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргументы события</param>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="T:System.ExceptionEventHandlerExtentions">
            <summary>Класс методов расширений для обработчика событий генерации исключений</summary>
        </member>
        <member name="M:System.ExceptionEventHandlerExtentions.Start``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0})">
            <summary>Генерация события обработки исключения</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="M:System.ExceptionEventHandlerExtentions.StartAsync``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0},System.AsyncCallback,System.Object)">
            <summary>Асинхронная генерация события обработки исключения</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <param name="CallBack">Делегат заврешения вызова события</param>
            <param name="State">ОБъект состояния, передаваемый в обработчик завершающего метода</param>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="M:System.ExceptionEventHandlerExtentions.FastStart``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0})">
            <summary>Быстрый запуск события без учёта многопоточных компонентов</summary>
            <param name="Handler">Обработчики события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <typeparam name="TException">Тип события</typeparam>
        </member>
        <member name="M:System.ExceptionEventHandlerExtentions.ThrowIfUnhandled``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0},System.Nullable{System.Boolean})">
            <summary>
            Вызвать <typeparamref name="TException">исключение</typeparamref>, 
            если обработчики его не обработали, либо если кто-либо из обработчиков принял решение вызвать исключение
            </summary>
            <param name="Handler">Обработчики событий</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <param name="IsHandledDefault">
            Если истина, то исключение считается обработанным до тех пор, пока обработчик обытия не укажет обратного
            Если ложь, то обработчики должны явно указать, что исключение обработано.
            По умолчанию значение не определено (= null) - при наличии обработчиков у события исключение считается обработанным. Иначе оно генерируется. 
            </param>
            <typeparam name="TException">Тип исключения</typeparam>
            <exception cref="T:System.Exception"><typeparamref name="TException">Исключение</typeparamref> генерируется при отсутствии обработки его обработчиками события</exception>
        </member>
        <member name="T:System.ExceptionEventHandlerArgs`1">
            <summary>Аргументы события исключения</summary>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="F:System.ExceptionEventHandlerArgs`1._Unhandled">
            <summary>Флаг необходимости генерации исключения</summary>
        </member>
        <member name="F:System.ExceptionEventHandlerArgs`1._IsHandled">
            <summary>Флаг признака обработки исключения обработчиками</summary>
        </member>
        <member name="P:System.ExceptionEventHandlerArgs`1.IsHandled">
            <summary>Исключение обработано</summary>
        </member>
        <member name="P:System.ExceptionEventHandlerArgs`1.NeedToThrow">
            <summary>Признак необходимости генерации исключения</summary>
        </member>
        <member name="M:System.ExceptionEventHandlerArgs`1.#ctor(`0)">
            <summary>Новый аргумент события генерации исключения</summary>
            <param name="Error">Исключение</param>
        </member>
        <member name="M:System.ExceptionEventHandlerArgs`1.Handled">
            <summary>Исключение обработано</summary>
        </member>
        <member name="M:System.ExceptionEventHandlerArgs`1.Unhandled">
            <summary>Исключение должно быть сгенерировано в любом случае</summary>
        </member>
        <member name="T:System.DecimalExtentions">
            <summary>Расширения для чисел двойной точности</summary>
        </member>
        <member name="M:System.DecimalExtentions.Sqrt(System.Decimal,System.Decimal)">
            <summary>Вычисление квадратного корня указанной точности последовательными приближениями</summary>
            <param name="x">Число, квадратный корень которого требуется вычислить</param>
            <param name="epsilon">Требуемая точность</param>
            <returns>Квадратный корень числа</returns>
        </member>
        <member name="M:System.DecimalExtentions.IsInt(System.Decimal)">
            <summary>Является ли число целым?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число целое</returns>
        </member>
        <member name="M:System.DecimalExtentions.GetInverse(System.Decimal)">
            <summary>Получить обратное число</summary>
            <param name="x">Инвертируемое число</param>
            <returns>Число, обратное к исходном</returns>
        </member>
        <member name="M:System.LambdaProcessor.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="T:System.Processor">
            <summary>Класс объектов, выполняющих некоторое циклическое действие в отдельном фоновом потоке</summary>
        </member>
        <member name="F:System.Processor.__AcyncException">
            <summary>Объект-ислюкение, передаваемое в качестве параметра события ошибки при рассинхронизации потока процессора</summary>
        </member>
        <member name="P:System.Processor.Now">
            <summary>Текущее время системы</summary>
        </member>
        <member name="E:System.Processor.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
            <summary>Событие изменения свойства объекта</summary>
        </member>
        <member name="M:System.Processor.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Вызов события изменения свойства объекта</summary>
             <param name="e">Параметры события изменения свойства объекта, содержашие имя свойства</param>
        </member>
        <member name="M:System.Processor.OnPropertyChanged(System.String)">
            <summary>Вызов собйтия изменения свойтсва объекта с указанием имени свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="E:System.Processor.EnableChanged">
            <summary>Событие изменения свойства активности процессора</summary>
        </member>
        <member name="M:System.Processor.OnEnableChanged(System.EventArgs)">
            <summary>Источник собйтия изменения свойства активности процессора</summary><param name="e">Параметры события</param>
        </member>
        <member name="E:System.Processor.ProcessStarted">
            <summary>Событие запуска процессора</summary>
        </member>
        <member name="M:System.Processor.OnProcessStarted(System.EventArgs)">
            <summary>Источник события запуска процессора</summary><param name="e">Параметры события</param>
        </member>
        <member name="E:System.Processor.ProcessComplited">
            <summary>Событие завершения работы процессора</summary>
        </member>
        <member name="M:System.Processor.OnProcessComplited(System.EventArgs)">
            <summary>Источник события завершения работы процессора</summary><param name="e">Параметры события</param>
        </member>
        <member name="E:System.Processor.Error">
            <summary>Событие, вознакающие при возникновении исключений в процессе работы процессора</summary>
        </member>
        <member name="M:System.Processor.OnError(System.ExceptionEventHandlerArgs{System.Exception})">
            <summary>Источник события возникновения исключительной ситуации в процессе работы процессора</summary>
            <param name="e">Аргумент события ошибки, содержащий объект исключения</param>
        </member>
        <member name="F:System.Processor._JoinThreadTimeout">
            <summary>
            Таймаут времени ожидания синхронизации потока обработки при его завершении, 
            после которого поток прерывается методом Abort()
            По умолчанию 100 мс.
            </summary>
        </member>
        <member name="F:System.Processor._Enabled">
            <summary>Флаг активности потока обработки. Пока значение флага "истина" - поток выполняется</summary>
        </member>
        <member name="F:System.Processor._StartStopSectionLocker">
            <summary>Объект синхронизации запуска/остановки процессора - только для чтения</summary>
        </member>
        <member name="F:System.Processor._MainWorkThread">
            <summary>Основной поток работы процессора</summary>
        </member>
        <member name="F:System.Processor._StartTime">
            <summary>Время запуска</summary>
        </member>
        <member name="F:System.Processor._StopTime">
            <summary>Время остановки</summary>
        </member>
        <member name="F:System.Processor._Monitor">
            <summary>Объект-наблюдатель за состоянием процессора</summary>
        </member>
        <member name="F:System.Processor._Priority">
            <summary>Базовый приоритет потока процессора</summary>
        </member>
        <member name="F:System.Processor._ActionTimeout">
            <summary>Таймаут выполнения между циклами процессора </summary>
        </member>
        <member name="F:System.Processor._Set_Timeout">
            <summary>Метод установки времени таймаута для работающего потока процессора</summary>
        </member>
        <member name="F:System.Processor._IsSychronus">
            <summary>Признак синхронной работы</summary>
        </member>
        <member name="F:System.Processor._ErrorIfAcync">
            <summary>Флаг, разрешающий вызов события ошибки в случае рассинхронизации потока</summary>
        </member>
        <member name="F:System.Processor._CyclesCount">
            <summary>Количество выполненных циклов обработки</summary>
        </member>
        <member name="F:System.Processor._NameForeNewMainThread">
            <summary>Имя для генерируемой потока выполнения процессора</summary>
        </member>
        <member name="F:System.Processor._Get_LastDeltaTime">
            <summary>Метод извлечения времени выполнения одного цикла основного метода процессора</summary>
        </member>
        <member name="F:System.Processor._StartWaitHandle">
            <summary>Объект синхрониации потоков по запуску процессора</summary>
        </member>
        <member name="F:System.Processor._StopWaitHandle">
            <summary>Объект синхрониации потоков по остановке процессора</summary>
        </member>
        <member name="P:System.Processor.Priority">
            <summary>Приоритет выполнения метода наблюдения</summary>
        </member>
        <member name="P:System.Processor.Enable">
            <summary>Признак активности процессора</summary>
        </member>
        <member name="P:System.Processor.MainThread">
            <summary>Основной поток работы процессора</summary>
        </member>
        <member name="P:System.Processor.JoinThreadTimeout">
            <summary>ТАймаут времени синхронизации основного потока процессора с потоком, завершившим его работу.</summary>
        </member>
        <member name="P:System.Processor.StartTime">
            <summary>Время запуска</summary>
        </member>
        <member name="P:System.Processor.StopTime">
            <summary>Время остановки</summary>
        </member>
        <member name="P:System.Processor.ElapsedTime">
            <summary>Время, прошедшее после запуска</summary>
        </member>
        <member name="P:System.Processor.Monitor">
            <summary>ОБъект-наблюдатель за состоянием процессора</summary>
        </member>
        <member name="P:System.Processor.ActionTimeout">
            <summary>ТАймаут основной циклической операции в миллисекундах</summary>
        </member>
        <member name="P:System.Processor.IsSynchronus">
            <summary>Признак синхронной работы</summary>
        </member>
        <member name="P:System.Processor.ErrorIfAsync">
            <summary>ГЕнерировать ошибку в случае рассинхронизации?</summary>
        </member>
        <member name="P:System.Processor.CyclesCount">
            <summary>Количество пройденных циклов</summary>
        </member>
        <member name="M:System.Processor.Start">
            <summary>Запуск обработки</summary>
        </member>
        <member name="M:System.Processor.Stop">
            <summary>Остановка обработки</summary>
        </member>
        <member name="M:System.Processor.WaitToStart(System.Nullable{System.TimeSpan})">
            <summary>Блокировать поток до запуска процессора</summary>
        </member>
        <member name="M:System.Processor.WaitToStop(System.Nullable{System.TimeSpan})">
            <summary>Блокировать пото до остановки процессора</summary>
        </member>
        <member name="M:System.Processor.ThreadMethod">
            <summary>Основной метод процессора, выполняемый в отдельном потоке </summary>
        </member>
        <member name="M:System.Processor.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="M:System.Processor.InitializeAction">
            <summary>Инициализация процесса</summary>
        </member>
        <member name="M:System.Processor.Initializer">
            <summary>
            Метод инициализации. Вызывается после запуска обработки перед началом основного цикла.
            По умолчанию вызывает генерацию события запуска процессора
            </summary>
        </member>
        <member name="M:System.Processor.Finalizer">
            <summary>
            Метод, завершающий процесс обработки. Вызывается после выхода процессора из основного цикла.
            По умолчанию вызывает генерацию события завершения работы процессора
            </summary>
        </member>
        <member name="M:System.Processor.FinalizeAction">
            <summary>Завершающее действие процесса</summary>
        </member>
        <member name="M:System.Processor.Dispose">
            <inheritdoc />
        </member>
        <member name="T:System.StreamingObjectReader`1">
            <summary>Класс поточного чтения объектов из потока данных</summary>
            <typeparam name="T">Тип читаемых объектов</typeparam>
        </member>
        <member name="E:System.StreamingObjectReader`1.Readed">
            <summary>Событие чтения нового объекта из потока данных</summary>
        </member>
        <member name="M:System.StreamingObjectReader`1.OnReaded(System.EventArgs{`0})">
            <summary>Источник события чтения объекта из потока данных</summary>
            <param name="e">Аргумент события, содержащий прочитанный объект</param>
        </member>
        <member name="M:System.StreamingObjectReader`1.OnReaded(`0)">
            <summary>Источник события чтения объекта из потока данных</summary>
            <param name="obj">Прочитанный объект</param>
        </member>
        <member name="F:System.StreamingObjectReader`1._DataStream">
            <summary>Потока данных</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.DataStream">
            <summary>Потока данных</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.Complited">
            <summary>Процент готовности</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.Speed">
            <summary>Скорость обработки данных</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.RemainingTime">
            <summary>Оставшееся время до окончания обработки</summary>
        </member>
        <member name="T:System.StringExtentions">
            <summary>Методы-расширения класса <see cref="T:System.String">строк</see></summary>
        </member>
        <member name="M:System.StringExtentions.FindBlock(System.String,System.String)">
            <summary>Перечисление подстрок, разделяемых указанным строковым шаблоном</summary>
            <param name="Str">Разбиваемая строка</param>
            <param name="EndPattern">Строковый шаблон разбиения</param>
            <returns>Перечисление подстрок</returns>
        </member>
        <member name="M:System.StringExtentions.GetBracketText(System.String,System.Int32@,System.String,System.String)">
            <summary>
            Выделение подстроки, ограниченной шаблоном начала и шаблоном окончания строки начиная с указанного смещения
            </summary>
            <param name="Str">Входная строка</param>
            <param name="Offset">
            Смещеине во входной строке начала поиска - в конце работы метода соответствует месту окончания поиска
            </param>
            <param name="Open">Шаблон начала подстроки</param>
            <param name="Close">Шаблон окончания подстроки</param>
            <returns>Подстрока, заключённая между указанными шаблонами начала и окончания</returns>
            <exception cref="T:System.FormatException">
            Если шаблон завершения строки на нейден, либо если количество шаблонов начала строки превышает 
            количество шаблонов окончания во входной строке
            </exception>
        </member>
        <member name="M:System.StringExtentions.IsNullOrEmpty(System.String)">
            <summary>Проверка строки на пустоту, либо нулевую ссылку</summary>
            <param name="Str">Проверяемая строка</param>
            <returns>Истина, если трока пуста, либо если передана нулевая ссылка</returns>
        </member>
        <member name="M:System.StringExtentions.IsNotNullOrEmpty(System.String)">
            <summary>Строка присутствует и не пуста</summary>
            <param name="Str">Проверяемая строка</param>
            <returns>Истина, если трокане  пуста, и если передана ненулевая ссылка</returns>
        </member>
        <member name="M:System.StringExtentions.ClerSymbolsAtBegin(System.String,System.Char[])">
            <summary>Удаление символов в начале строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <param name="symbols">Перечень удаляемых символов</param>
            <returns>Новая строка с удалёнными символами в начале</returns>
        </member>
        <member name="M:System.StringExtentions.ClerSymbolsAtEnd(System.String,System.Char[])">
            <summary>Удаление символов в конце строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <param name="symbols">Перечень удаляемых символов</param>
            <returns>Новая строка с удалёнными символами в конце</returns>
        </member>
        <member name="M:System.StringExtentions.ClearSymbolsAtBeginAndEnd(System.String,System.Char[])">
            <summary>Удаление символов в начале и конце строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <param name="symbols">Перечень удаляемых символов</param>
            <returns>Новая строка с удалёнными символами в начале и конце</returns>
        </member>
        <member name="M:System.StringExtentions.ClearSystemSymbolsAtBeginAndEnd(System.String)">
            <summary>Удаление служебных символов в начале и конце строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <returns>Новая строка с удалёнными служебными символами в началеи конце</returns>
        </member>
        <member name="T:System.IInitializable">
            <summary>Объект, поддерживающий инициализацию</summary>
        </member>
        <member name="M:System.IInitializable.Initialize">
            <summary>Инициализация</summary>
        </member>
        <member name="T:System.IInitializable`1">
            <summary>Объект, поддерживающий инициализацию с параметром</summary>
            <typeparam name="T">Тип параметра инициализации</typeparam>
        </member>
        <member name="M:System.IInitializable`1.Initialize(`0)">
            <summary>Инициализация</summary>
            <param name="t">Параметр</param>
        </member>
        <member name="T:System.IInitializable`2">
            <summary>Объект, поддерживающий инициализацию с двумя параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
        </member>
        <member name="M:System.IInitializable`2.Initialize(`0,`1)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
        </member>
        <member name="T:System.IInitializable`3">
            <summary>Объект, поддерживаюий инициализацию с тремя параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
            <typeparam name="T3">Тип третьего параметра</typeparam>
        </member>
        <member name="M:System.IInitializable`3.Initialize(`0,`1,`2)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
            <param name="t3">Третий параметр</param>
        </member>
        <member name="T:System.IInitializable`4">
            <summary>ОБъект, поддерживающий инициализацию с четырьмя параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
            <typeparam name="T3">Тип третьего параметра</typeparam>
            <typeparam name="T4">Тип четвёртого патаметра</typeparam>
        </member>
        <member name="M:System.IInitializable`4.Initialize(`0,`1,`2,`3)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
            <param name="t3">Третий параметр</param>
            <param name="t4">Четвёртый параметр</param>
        </member>
        <member name="T:System.IInitializable`5">
            <summary>ОБъект, поддерживающий инициализацию с пятью параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
            <typeparam name="T3">Тип третьего параметра</typeparam>
            <typeparam name="T4">Тип четвёртого патаметра</typeparam>
            <typeparam name="T5">Тип пятого патаметра</typeparam>
        </member>
        <member name="M:System.IInitializable`5.Initialize(`0,`1,`2,`3,`4)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
            <param name="t3">Третий параметр</param>
            <param name="t4">Четвёртый параметр</param>
            <param name="t5">Пятый параметр</param>
        </member>
        <member name="T:System.Month">
            <summary>Месяцы года</summary>
        </member>
        <member name="F:System.Month.January">
            <summary>Январь</summary>
        </member>
        <member name="F:System.Month.February">
            <summary>Февраль</summary>
        </member>
        <member name="F:System.Month.March">
            <summary>Март</summary>
        </member>
        <member name="F:System.Month.April">
            <summary>Апрель</summary>
        </member>
        <member name="F:System.Month.May">
            <summary>Май</summary>
        </member>
        <member name="F:System.Month.June">
            <summary>Июнь</summary>
        </member>
        <member name="F:System.Month.July">
            <summary>Июль</summary>
        </member>
        <member name="F:System.Month.August">
            <summary>Август</summary>
        </member>
        <member name="F:System.Month.September">
            <summary>Сентябрь</summary>
        </member>
        <member name="F:System.Month.October">
            <summary>Октябрь</summary>
        </member>
        <member name="F:System.Month.November">
            <summary>Ноябрь</summary>
        </member>
        <member name="F:System.Month.December">
            <summary>Декабрь</summary>
        </member>
        <member name="T:System.EventArgs`1">
            <summary>Аргумент события с типизированным параметром</summary>
            <typeparam name="TArgument">Тип параметра аргумента</typeparam>
        </member>
        <member name="P:System.EventArgs`1.Argument">
            <summary>Параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`1.#ctor(`0)">
            <summary>Новый аргумент события с типизированным параметром</summary>
            <param name="Argument">Параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`1.ToString">
            <summary>
            Возвращает объект <see cref="T:System.String"/>, который представляет текущий объект <see cref="T:System.Object"/>.
            </summary>
            <returns>Объект <see cref="T:System.String"/>, представляющий текущий объект <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:System.EventArgs`1.op_Implicit(System.EventArgs{`0})~`0">
            <summary>Оператор неявного преобразования аргумента события к типу содержащегося в нём значения </summary>
            <param name="Args">Аргумент события</param>
            <returns>Хранимый объект</returns>
        </member>
        <member name="M:System.EventArgs`1.op_Implicit(`0)~System.EventArgs{`0}">
            <summary>
            Оgератор неявного преобразования типа зранимого значения в обёртку из аргумента события, содержащего это значение
            </summary>
            <param name="Argument">Объект аргумента события</param>
            <returns>Аргумент события</returns>
        </member>
        <member name="T:System.EventArgs`2">
            <summary>Аргумент события с двумя типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип первого параметра</typeparam>
            <typeparam name="TArgument2">Тип второго параметра</typeparam>
        </member>
        <member name="P:System.EventArgs`2.Argument1">
            <summary>Первый аргумент</summary>
        </member>
        <member name="P:System.EventArgs`2.Argument2">
            <summary>Второй аргумент</summary>
        </member>
        <member name="M:System.EventArgs`2.#ctor">
            <summary>Новый аргумент события с двумя параметрами</summary>
        </member>
        <member name="M:System.EventArgs`2.#ctor(`0,`1)">
            <summary>Новый аргумент события с двумя параметрами</summary>
            <param name="Argument1">Первый аргумент события</param>
            <param name="Argument2">Второй аргумент события</param>
        </member>
        <member name="M:System.EventArgs`2.op_Implicit(System.EventArgs{`0,`1})~`0">
            <summary>Оператор неявного преобразования аргумента события к типу содержащегося в нём значения </summary>
            <param name="Args">Аргумент события</param>
            <returns>Хранимый объект</returns>
        </member>
        <member name="M:System.EventArgs`2.op_Implicit(System.EventArgs{`0,`1})~`1">
            <summary>Оператор неявного преобразования аргумента события к типу содержащегося в нём значения </summary>
            <param name="Args">Аргумент события</param>
            <returns>Хранимый объект</returns>
        </member>
        <member name="T:System.EventArgs`3">
            <summary>Аргумент события с двумя типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип первого параметра</typeparam>
            <typeparam name="TArgument2">Тип второго параметра</typeparam>
            <typeparam name="TArgument3">Тип третьего параметра</typeparam>
        </member>
        <member name="P:System.EventArgs`3.Argument1">
            <summary>Первый аргумент</summary>
        </member>
        <member name="P:System.EventArgs`3.Argument2">
            <summary>Второй аргумент</summary>
        </member>
        <member name="P:System.EventArgs`3.Argument3">
            <summary>Третий аргумент</summary>
        </member>
        <member name="M:System.EventArgs`3.#ctor">
            <summary>Новый аргумент события с тремя параметрами</summary>
        </member>
        <member name="M:System.EventArgs`3.#ctor(`0,`1,`2)">
            <summary>Новый аргумент события с тремя параметрами</summary>
            <param name="Argument1">Первый аргумент события</param>
            <param name="Argument2">Второй аргумент события</param>
            <param name="Argument3">Третий аргумент события</param>
        </member>
        <member name="T:System.EventSenderArgs`2">
            <summary>Аргумент события с типизированным параметром</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgument">Тип параметра аргумента</typeparam>
        </member>
        <member name="P:System.EventSenderArgs`2.Sender">
            <summary>Источник события</summary>
        </member>
        <member name="M:System.EventSenderArgs`2.#ctor(`0,`1)">
            <summary>Новый аргумент события с типизированным параметром</summary>
            <param name="Sender">Источник события</param>
            <param name="Argument">Параметр аргумента</param>
        </member>
        <member name="M:System.EventSenderArgs`2.ToString">
            <summary>
            Возвращает объект <see cref="T:System.String"/>, который представляет текущий объект <see cref="T:System.Object"/>.
            </summary>
            <returns>Объект <see cref="T:System.String"/>, представляющий текущий объект <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:System.EventSenderArgs`2.op_Implicit(System.EventSenderArgs{`0,`1})~`1">
            <summary>Оператор неявного преобразования аргумента события к типу содержащегося в нём значения </summary>
            <param name="Args">Аргумент события</param>
            <returns>Хранимый объект</returns>
        </member>
        <member name="T:System.EventSenderArgs`3">
            <summary>Аргумент события с двумя типизированными параметрами</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgument1">Тип первого параметра</typeparam>
            <typeparam name="TArgument2">Тип второго параметра</typeparam>
        </member>
        <member name="P:System.EventSenderArgs`3.Sender">
            <summary>Источник события</summary>
        </member>
        <member name="M:System.EventSenderArgs`3.#ctor">
            <summary>Новый аргумент события с двумя параметрами</summary>
        </member>
        <member name="M:System.EventSenderArgs`3.#ctor(`0,`1,`2)">
            <summary>Новый аргумент события с двумя параметрами</summary>
            <param name="Sender">Источник события</param>
            <param name="Argument1">Первый аргумент события</param>
            <param name="Argument2">Второй аргумент события</param>
        </member>
        <member name="T:System.EventSenderArgs`4">
            <summary>Аргумент события с двумя типизированными параметрами</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgument1">Тип первого параметра</typeparam>
            <typeparam name="TArgument2">Тип второго параметра</typeparam>
            <typeparam name="TArgument3">Тип третьего параметра</typeparam>
        </member>
        <member name="P:System.EventSenderArgs`4.Sender">
            <summary>Источник события</summary>
        </member>
        <member name="M:System.EventSenderArgs`4.#ctor">
            <summary>Новый аргумент события с тремя параметрами</summary>
        </member>
        <member name="M:System.EventSenderArgs`4.#ctor(`0,`1,`2,`3)">
            <summary>Новый аргумент события с тремя параметрами</summary>
            <param name="Sender">Источник события</param>
            <param name="Argument1">Первый аргумент события</param>
            <param name="Argument2">Второй аргумент события</param>
            <param name="Argument3">Третий аргумент события</param>
        </member>
        <member name="T:System.ArrayExtensions">
            <summary>Методы расширения для массивов</summary>
        </member>
        <member name="M:System.ArrayExtensions.Split``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Разделить входной массив на подмассивы указанным методом</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="array">Разделяемый массив</param>
            <param name="Splitter">Метод, возвращающий истину, когда надо начать новый подмассив</param>
            <returns>
            Массив подмассивов элементов исходного массива, разделённый выбранными указанным методом элементами.
            Выбранные элементы в результат не входят.
            </returns>
        </member>
        <member name="M:System.ArrayExtensions.qSort``1(``0[],System.Int32,System.Int32)">
            <summary>Быстрая сортировка Хоара</summary>
            <typeparam name="T">Тип сортируемых элементов</typeparam>
            <param name="A">Сортируемый массив элементов</param>
            <param name="low">Нижняя граница индекса сортировки</param>
            <param name="high">Верхняя граница индекса сортировки</param>
        </member>
        <member name="M:System.ArrayExtensions.qSort_t``1(``0[],System.Int32,System.Int32)">
            <summary>Быстрая сортировка Хоара</summary>
            <typeparam name="T">Тип сортируемых элементов</typeparam>
            <param name="A">Сортируемый массив элементов</param>
            <param name="low">Нижняя граница индекса сортировки</param>
            <param name="high">Верхняя граница индекса сортировки</param>
        </member>
        <member name="M:System.ArrayExtensions.GetComplexHashCode``1(``0[])">
            <summary>Рассчёт хеш-суммы всех элементов массива</summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="Objects">Массив элементов</param>
            <returns>Хеш-сумма элементов массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.Concatinate``1(``0[],``0[])">
            <summary>Объединение с массивом элементов</summary>
            <param name="A">Исходный массив</param>
            <param name="B">Присоединяемый массив</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <returns>Массив из объединёных элементов</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetSelectedValue``2(``0[],System.Func{``0,``1,``1})">
            <summary>Получить элемент массива</summary>
            <param name="A">Массив элементов</param>
            <param name="Selector">Метод выбора элемента массива</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TOut">Тип выходного элемента</typeparam>
            <returns>Выбранный элемент массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.ConvertTo``2(``0[],System.Converter{``0,``1})">
            <summary>Преобразовать тип элементов массива</summary>
            <param name="In">Исходный массив элементов</param>
            <param name="converter">Метод преобразования элемента массива</param>
            <typeparam name="TIn">Исходный тип элементов массива</typeparam>
            <typeparam name="TOut">Требуемый тип элементов массива</typeparam>
            <returns>Массив преобразованных элементов</returns>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``1(``0[],System.Action{``0})">
            <summary>Выполнение действия для всех элементов массива</summary>
            <param name="array">Массив элементов</param>
            <param name="action">Выполняемой действие</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``1(``0[],System.Action{``0},System.Func{System.Exception,System.Boolean})">
            <summary>Выполнение действия для всех элементов массива с обработкой исключений</summary>
            <param name="array">Массив элементов</param>
            <param name="action">Выполняемое действие</param>
            <param name="ErrorHandler">Обработчик исключения</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``2(``0[],System.Action{``0},System.Func{``1,System.Boolean})">
            <summary>Выполнение действия для всех элементов массива</summary>
            <param name="array">Массив элементов</param>
            <param name="action">ВЫполняемое действие</param>
            <param name="ErrorHandler">Обработчик исключений</param>
            <exception cref="T:System.ApplicationException">Возникает в случае если в методе action возникшее исключение не было обработано</exception>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TException">Тип исключений</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Function``2(``0[],System.Func{``0,``1})">
            <summary>Определение значения функции для всех элементов массива</summary>
            <param name="array">Массив элементов</param>
            <param name="f">Вычисляемая функция</param>
            <typeparam name="TIn">Тип элементов массива области определения</typeparam>
            <typeparam name="TOut">Тип элементов массива области значения</typeparam>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetReversed``1(``0[])">
            <summary>Получить массив, индексы элементов которого имеют обратный порядок</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="array">Переворачиваемый массив</param>
            <returns>Перевёрнутый массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``1(``0[],System.Func{System.Int32,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TArray">Тип элементов масива</typeparam>
            <param name="array">Инициализированный масив</param>
            <param name="Initializer">МЕтод инициализации</param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``1(``0[],``0)">
            <summary>Инициализация массива одинм значением</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="value">Значение, размещаемое во всех элементах массива</param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``2(``0[],``1,System.Func{System.Int32,``1,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TValue">Тип элементов масива</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <param name="array">Инициализированный масив</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="Initializer">Метод инициализации</param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``3(``0[],``1,``2,System.Func{System.Int32,``1,``2,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TValue">Тип элементов масива</typeparam>
            <typeparam name="TParameter1">Тип первого параметра инициализации</typeparam>
            <typeparam name="TParameter2">Тип второго параметра инициализации</typeparam>
            <param name="array">Инициализированный масив</param>
            <param name="parameter1">Первый параметр инициализации</param>
            <param name="parameter2">Второй параметр инициализации</param>
            <param name="Initializer">Метод инициализации</param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.SwapCols``1(``0[0:,0:],System.Int32,System.Int32)">
            <summary>Поменять местами два столбца двумерного массива</summary>
            <param name="array">Двумерный массив</param>
            <param name="j1">Номер первого столбца</param>
            <param name="j2">Номер второго столбца</param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.CreateSequence(System.Int32,System.Int32)">
            <summary>Создать массив последовательных значений длины <paramref name="length"/> начиная с <paramref name="offset"/></summary>
            <param name="length">Длина массива</param>
            <param name="offset">НАчальное значение</param>
            <returns>Массив чисел длины <paramref name="length"/> начиная с <paramref name="offset"/></returns>
        </member>
        <member name="M:System.ArrayExtensions.Mix``1(``0[])">
            <summary>Создать копию массива с перемешанным содержимым</summary>
            <param name="array">Исходный массив</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Копия исходного массива с перемешанным созержимым</returns>
        </member>
        <member name="M:System.ArrayExtensions.MixRef``1(``0[])">
            <summary>Перемешать массив</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="array">Перемешиваемый массив</param>
            <returns>Исходный массив с перемешанным содержимым</returns>
        </member>
        <member name="M:System.ArrayExtensions.MixRef``1(``0[],``0[])">
            <summary>Перемешать массив</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="array">Перемешиваемый массив</param>
            <returns>Исходный массив с перемешанным содержимым</returns>
        </member>
        <member name="M:System.ArrayExtensions.SetSubArrays``1(``0[],``0[][])">
            <summary>Последовательно скопировать набор массивов в буффер</summary>
            <param name="A">Буфферный массив соответствующей длины</param>
            <param name="B">Перечень устанавливаемых значений</param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="T:System.FuncExtentions">
            <summary>Класс методов-расширений для функции</summary>
        </member>
        <member name="M:System.FuncExtentions.ToEvulation``1(System.Func{``0},System.String)">
            <summary>Преобразование функции в вычисление</summary>
            <typeparam name="T">Тип возвращаемого функцией результата</typeparam>
            <param name="function">Преобразуемая функция</param>
            <param name="Name">Имя вычисления</param>
            <returns>Вычисление функции</returns>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_NewtonsMethod(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом Ньютона</summary>
            <param name="f">Исследуемая функция</param>
            <param name="df">Дифференциал исследуемой функции</param>
            <param name="x0">Начальное приближение</param>
            <param name="max_iterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_NewtonsMethodAsync(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом Ньютона</summary>
            <param name="f">Исследуемая функция</param>
            <param name="df">Дифференциал исследуемой функции</param>
            <param name="x0">Начальное приближение</param>
            <param name="max_iterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_BisectionMethod(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary> Поиск нуля функции методом бисекции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="max_iterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.ArithmeticException"><paramref name="f" /> is equal to <see cref="F:System.Double.NaN" />. </exception>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_BisectionMethodAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary> Поиск нуля функции методом бисекции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="max_iterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.ArithmeticException"><paramref name="f" /> is equal to <see cref="F:System.Double.NaN" />. </exception>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_GoldenSection(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Золотого сечения</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_GoldenSectionAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Золотого сечения</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_TernarySearch(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Троичного деления</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_TernarySearchAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Троичного деления</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_FalsiPositionMethod(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом False position</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="max_iterations">Максимальное допустимое число итераций метода</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_FalsiPositionMethodAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом False position</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="max_iterations">Максимальное допустимое число итераций метода</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_MethodOfChords(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом хорд</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.GetRoot_MethodOfChordsAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом хорд</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtentions.Carring``3(System.Func{``0,``1,``2})">
            <summary>Карирование функции двух параметров</summary>
            <typeparam name="TArg1">Тип значение первого параметра функции</typeparam>
            <typeparam name="TArg2">Тип значение второго параметра функции</typeparam>
            <typeparam name="TResult">Тип результата функции</typeparam>
            <param name="f">Карируемая функция</param>
        </member>
        <member name="M:System.FuncExtentions.Add(System.Func{System.Double,System.Double},System.Double)">
            <summary>Сложение функции с числом g(x) = f(x) + a</summary>
            <param name="f">Исходная функция</param>
            <param name="a">Прибавляемое число</param>
            <returns>Новая функция, значения которой равны значениям исходной функции плюс указанному числу</returns>
        </member>
        <member name="M:System.FuncExtentions.Add(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Сложение двух функций g(x) = f1(x) + f2(x)</summary>
            <param name="f1">Функция - первое слогаемое</param>
            <param name="f2">Функция - второе слогаемое</param>
            <returns>Функция, значения которой равны сумме значений двух исходных функций</returns>
        </member>
        <member name="M:System.FuncExtentions.ArgumentReverse(System.Func{System.Double,System.Double})">
            <summary>Изменение знака аргумента функции g(x) = f(-x)</summary>
            <param name="f">Исходная функция</param>
            <returns>Новая функция, значения аргумента которой отрицательны по отношению к аргументу исходной функци g(x) = f(-x)</returns>
        </member>
        <member name="M:System.FuncExtentions.ArgumentShift(System.Func{System.Double,System.Double},System.Double)">
            <summary>Смещение аргумента функции на указанное значение g(x) = f(x-a)</summary>
            <param name="f">Исходная функция</param>
            <param name="x0">Значение смещения аргумента</param>
            <returns>Новая функция со смещённым аргументом</returns>
        </member>
        <member name="M:System.FuncExtentions.ArgumentCompression(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Сжатие аргумента функци g(x) = f(k * x + b)</summary>
            <param name="f">Исходная функция</param>
            <param name="k">Коэффициент сжатия аргумента</param>
            <param name="b">Коэффициент смещения аргумента</param>
            <returns>Новая функция со сжатым и смещённым аргументом</returns>
        </member>
        <member name="M:System.FuncExtentions.Divade(System.Func{System.Double,System.Double},System.Double)">
            <summary>Деление функции на число g(x) = f(x) / a</summary>
            <param name="f">Делимая функция</param>
            <param name="a">Вещественный делитель</param>
            <returns>
            Функция, значния которой равны значениям исходной функции, делимые на вещественный делитель.
            Если вещественный делитель равен 0, то возвращается функция, значения которой равны +бесконечности если
            аргумент больше нуля, -бесконечности, если аргумент меньше нуля и NaN, если аргумент равен нулю.
            </returns>
        </member>
        <member name="M:System.FuncExtentions.Divade(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Деление функции на функцию g(x) = f1(x) / f2(x)</summary>
            <param name="f1">Функция - делимое</param>
            <param name="f2">Функция - делитель</param>
            <returns>Функция, значения которой равны отношению значений исходных функций</returns>
        </member>
        <member name="M:System.FuncExtentions.Func(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Функция от функци q(f(x))</summary>
            <param name="f">Внутренняя функция</param>
            <param name="q">Внешняя функция</param>
            <returns>ФУнкция q от функции f</returns>
        </member>
        <member name="M:System.FuncExtentions.FuncFrom``2(System.Func{``0,``1},System.Func{System.Func{``0,``1},System.Func{``0,``1}})">
            <summary>Функция от функции - функционал (преобразователь функции)</summary>
            <typeparam name="TIn">Тип аргумента функции</typeparam>
            <typeparam name="TOut">ТИп значения функции</typeparam>
            <param name="f">Исходная (преобразуемая) функция</param>
            <param name="q">Метод преобразования исходной функции, тип значения которого соответствует типу исходной функции</param>
            <returns>Новая функция, преобразованная указанным методом на основе исходной функции</returns>
        </member>
        <member name="M:System.FuncExtentions.FuncFor(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Функция от функции f(q(x))</summary>
            <param name="f">Внешняя функция</param>
            <param name="q">Внутренняя функция</param>
            <returns>Функция f от функции q</returns>
        </member>
        <member name="M:System.FuncExtentions.GetAkf(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>олучить автокорреляционную функцию от указанной функции</summary>
            <param name="f">Исходная функция</param>
            <param name="deltaX">Диапазон коореляции</param>
            <param name="x0">Смещение</param>
            <returns>Автокорреляционная функция</returns>
        </member>
        <member name="M:System.FuncExtentions.GetConvolution(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Функция корреляции между двумя функциями на указанному интервале корреляции с указанным смещеинем</summary>
            <param name="f">Первая функция</param>
            <param name="g">Вторая функция</param>
            <param name="deltaX">Интервал корреляции</param>
            <param name="x0">Смещение</param>
            <returns>Функция корреляции двух исходных функций</returns>
        </member>
        <member name="M:System.FuncExtentions.GetDifferencial(System.Func{System.Double,System.Double},System.Double,System.Int32)">
            <summary>Функция численного дифференцирования исходной функции</summary>
            <param name="f">Исходная функция</param>
            <param name="dx">Дифференциальный участок</param>
            <param name="n">Номер метода численного дифференцирования в пределах [0,4]</param>
            <returns>Функция численного дифференциала от исходной функции</returns>
        </member>
        <member name="M:System.FuncExtentions.GetDifferencialValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Определение значения численного дифференциала в указанной точке, с указанным шагом дифференцирования и номером метода</summary>
            <param name="f">Дифференцируемая функция</param>
            <param name="x">Точка дифференцирования</param>
            <param name="dx">Шаг дифференцирования</param>
            <param name="n">Номер метода</param>
            <returns>Численное значение дифференциала функции в указанной точке</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">Конечное значение интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValueAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">Конечное значение интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegral2Value(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Двойной определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">Конечное значение интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="f1">Начальное значение первой производной</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата двойного численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegral2ValueAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">КОнечное значение интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="f1">Начальное значение первой производной</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Интегрирование функции с модификацией ядра интеграла</summary>
            <param name="f">Подинтегральная функция f(x)</param>
            <param name="Core">Ядро интегрирования: Core(f(x),x)</param>
            <param name="x1">Начало интервала интегрирования</param>
            <param name="x2">Конец интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение определённого интеграла от ядра интегрирования методом тропеций</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValueAsync(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Расчитать интеграл функции асинхронно</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="Core">Ядро интегрирования</param>
            <param name="x1">Начало интервала интегрирования</param>
            <param name="x2">Конец интервала интегрирования</param>
            <param name="f0">Начальное значение функции (задача Коши)</param>
            <param name="dx">ШАг интегрирования</param>
            <returns>Задача расчёта значения интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegral2Value(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Интегрирование функции с модификацией ядра интеграла</summary>
            <param name="f">Подинтегральная функция f(x)</param>
            <param name="Core">Ядро интегрирования: Core(f(x),x)</param>
            <param name="x1">Начало интервала интегрирования</param>
            <param name="x2">Конец интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="f1">Начальное значение первой производной</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение определённого интеграла от ядра интегрирования методом тропеций</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegral2ValueAsync(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Асинхронный расчёт двойного интеграла функции</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="Core">Ядро интегрирования</param>
            <param name="x1">Начало интервала интегрирования</param>
            <param name="x2">Конец интервала интегрирования</param>
            <param name="f1">Начальное значение первой производной (задача Коши)</param>
            <param name="f0">Начальное значение функции (задача Коши)</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Задача численного расчёта второго интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_Simpson(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Численный расчёт определённого интеграла методом симпсона</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Число интервалов интегрирования N > 2</param>
            <returns>Интеграл функции на отрезке метдом Симпсона</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_Simpson(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Численный расчёт определённого интеграла методом симпсона</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="f0">Начально значение функции</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Интеграл функции на отрезке метдом Симпсона</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_SimpsonAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Численный расчёт определённого интеграла методом симпсона</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Число интервало интегрирования N > 2</param>
            <returns>Интеграл функции на отрезке метдом Симпсона</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_Adaptive(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Численный расчёт определённого интеграла методом адаптивного разбиения</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Начальное разбиение отрезка (по умолчанию 2 точки)</param>
            <param name="eps">Точность вычисления интеграла</param>
            <returns>Адаптивный интеграл функции</returns>
            <remarks>
            Функция рекурентно на каждом этапе расчитывает два численных интеграла (методом Симпсона): для указанного числа точек и для удвоенного.
            Если разница между расчитанными интегралами меньше указанной точности, то возвращается значение интеграла для удвоенного числа точек
            Иначе рекурентно расчитывается сумма двух интегралов (адаптивным методом) для правой и левой половины интервала интегрирования с удвоенным
            числом точек для каждого из них. Для каждой половины рекурентно повторяется проделанная процедура 
            </remarks>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_AdaptiveAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Численный расчёт определённого интеграла методом адаптивного разбиения</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Начальное разбиение отрезка</param>
            <param name="eps">Точность вычисления интеграла</param>
            <returns>Адаптивный интеграл функции</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_Spline(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Значение интеграла функции методом сплайнов</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начало отрезка интегрирования</param>
            <param name="x2">Конец отрезка интегрирования</param>
            <param name="N">Разбиение интервала интегрирования</param>
            <returns>Значение интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegralValue_SplineAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Значение интеграла функции методом сплайнов</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начало отрезка интегрирования</param>
            <param name="x2">Конец отрезка интегрирования</param>
            <param name="N">Разбиение интервала интегрирования</param>
            <returns>Значение интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtentions.GetIntegral(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Получить функцию-интеграл от функции</summary>
            <param name="f">Подинтегральная функция</param>
            <param name="x0">Начальное положение интегрирования</param>
            <param name="C">Константа интегрирования</param>
            <param name="eps">Точность интегрирования</param>
            <returns>Функция-интеграл от исходной функции</returns>
        </member>
        <member name="M:System.FuncExtentions.GetPeriodic(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Создать периодическую функцию на основе исходной</summary>
            <param name="f">Исходная функция</param>
            <param name="T">Период</param>
            <param name="x0">Смещение</param>
            <returns>Периодическая функция</returns>
        </member>
        <member name="M:System.FuncExtentions.GetPower(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Определить мощность функции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <returns>Значение интеграла от квадрата функции</returns>
        </member>
        <member name="M:System.FuncExtentions.Sampling``1(System.Func{System.Double,``0},System.Double,System.Double,System.Double)">
            <summary>Дискретизация функции</summary>
            <typeparam name="T">Тип значения функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">ШАг дискретизации</param>
            <returns>Перечисление дискретных значений функции</returns>
        </member>
        <member name="M:System.FuncExtentions.GetValues``2(System.Func{``0,``1},``0[])">
            <summary>Определение значений функции в дискретном перечне значений аргумента</summary>
            <typeparam name="TArgument">Тип аргумента</typeparam>
            <typeparam name="TResult">Тип значения функции</typeparam>
            <param name="f">ДИскретизируемая функция</param>
            <param name="args">Массив аргументов функции</param>
            <returns>Массив значений функции для указанных значений аргументов</returns>
        </member>
        <member name="M:System.FuncExtentions.GetValues``1(System.Func{System.Double,``0},System.Double,System.Double,System.Double)">
            <summary>Получить массив значений функции на указанном интервале с указанным шагом дискретизации</summary>
            <typeparam name="TResult">ТИп значений функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:System.FuncExtentions.Inverse(System.Func{System.Double,System.Double})">
            <summary>Получить функцию, значения которой обратны к значениям исходрной функции g(x) = 1 / f(x)</summary>
            <param name="f">Исходная функция</param>
            <returns>Функция, значения которой обратны по отношению исходной функции</returns>
        </member>
        <member name="M:System.FuncExtentions.Multiply(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Произведение двух функций g(x) = f1(x) * f2(x)</summary>
            <param name="f1">Фунция - первый сомножитель</param>
            <param name="f2">Функция - второй сомножитель</param>
            <returns>Функция - произведение двух функций</returns>
        </member>
        <member name="M:System.FuncExtentions.Multiply(System.Func{System.Double,System.Double},System.Double)">
            <summary>Произведение функции на число g(x) = f(x) * a</summary>
            <param name="f">Исходная функция</param>
            <param name="a">Число</param>
            <returns>Функция, значения которой равны произведению значений исходной функции на указанное число</returns>
        </member>
        <member name="M:System.FuncExtentions.Power(System.Func{System.Double,System.Double},System.Double)">
            <summary>Возведение функции в вещественную степень</summary>
            <param name="f">Исходная функция</param>
            <param name="a">Вещественная степень</param>
            <returns>Функция, значения которой равны возведению в указанную степень значений исходной функции</returns>
        </member>
        <member name="M:System.FuncExtentions.Reverse(System.Func{System.Double,System.Double})">
            <summary>Получение отрицательной функции</summary>
            <param name="f">Исходная функция</param>
            <returns>Функция, значения которой обратны по знаку к исходной функци</returns>
        </member>
        <member name="M:System.FuncExtentions.SetParameter(System.Func{System.Double,System.Double,System.Double},System.Double,System.Boolean)">
            <summary>Установка значения параметра функции двух переменных</summary>
            <param name="f">Исходная функция двух переменных</param>
            <param name="a">Устанавливаемое значение параметра</param>
            <param name="IsFirst">Параметром является первый аргумент функции? (по умолчанию - нет)</param>
            <returns>Функция одного переменного, получанная на основе исходной функции двух переменных устновкой одного в значение указанного параметра</returns>
        </member>
        <member name="M:System.FuncExtentions.Substract(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Вычитание одной функции из другой g(x) = f1(x) - f2(x)</summary>
            <param name="f1">Функция - уменьшаемое</param>
            <param name="f2">Функция - вычитаемое</param>
            <returns>Функция, значения которой численно равны разности значений двух исходных функций</returns>
        </member>
        <member name="M:System.FuncExtentions.Substract(System.Func{System.Double,System.Double},System.Double)">
            <summary>Вычитание из вункции числа g(x) = f(x) - a</summary>
            <param name="f">Исходная функция</param>
            <param name="a">вычитаемое из функции число</param>
            <returns>Функция, значения которой численно равны разности значений исходной функции и указанного числа</returns>
        </member>
        <member name="T:System.FuncExtentions.FuncCalculator`2">
            <summary>Вычислитель функции для распараллеливания процесса вычисления значений функции</summary>
            <typeparam name="TArgument">Тип аргумента функции</typeparam>
            <typeparam name="TResult">ТИп значения функции</typeparam>
        </member>
        <member name="T:System.FuncExtentions.FuncCalculator`2.func">
            <summary>Структура раезультата вычисления значения функции</summary>
        </member>
        <member name="F:System.FuncExtentions.FuncCalculator`2.func.x">
            <summary>Значение аргумента функции</summary>
        </member>
        <member name="F:System.FuncExtentions.FuncCalculator`2.func.f">
            <summary>Вычисляемая функция</summary>
        </member>
        <member name="F:System.FuncExtentions.FuncCalculator`2.Argument">
            <summary>Список аргументов функции</summary>
        </member>
        <member name="F:System.FuncExtentions.FuncCalculator`2.Result">
            <summary>Список значений функции</summary>
        </member>
        <member name="F:System.FuncExtentions.FuncCalculator`2._Complited">
            <summary>Число завершённых итераций рассчёта</summary>
        </member>
        <member name="F:System.FuncExtentions.FuncCalculator`2._Count">
            <summary>Общее количество итераций вычисления</summary>
        </member>
        <member name="M:System.FuncExtentions.FuncCalculator`2.#ctor">
            <summary>Инициализация нового вычислителя функции</summary>
        </member>
        <member name="E:System.FuncExtentions.FuncCalculator`2.OnComplited">
            <summary>Событие завершения процесса вычисления</summary>
        </member>
        <member name="M:System.FuncExtentions.FuncCalculator`2.Calculate(System.Object)">
            <summary>Расчёт значения функции в указанном узле</summary>
            <param name="State">Объект, созержащий структуру с значением аргумента и функции для расчёта значения</param>
        </member>
        <member name="M:System.FuncExtentions.FuncCalculator`2.Check">
            <summary>Процерка на завершение процесса вычисления значений функции - если число расчитанных итераций равно общему числу итераций, то расчёт завершён</summary>
        </member>
        <member name="M:System.FuncExtentions.FuncCalculator`2.SetCount(System.Int32)">
            <summary>Установка общего количества требуемых итераций расчёта</summary>
            <param name="Count">Требуемое количество итераций расчёта</param>
        </member>
        <member name="M:System.FuncExtentions.GetValuesParralel``2(System.Func{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>Вычислить значения функции параллельно</summary>
            <param name="f">Вычисляемая функция</param>
            <param name="Arguments">Область определения</param>
            <typeparam name="TArgument">Тип аргумента</typeparam>
            <typeparam name="TResult">Тип значения</typeparam>
            <returns>Массив значений функции</returns>
        </member>
        <member name="T:System.FuncExtentions.Integrator">
            <summary>Интегратор функции</summary>
        </member>
        <member name="F:System.FuncExtentions.Integrator._LockObject">
            <summary>Объект синхронизации потоков при доступе к параметрам интегратора</summary>
        </member>
        <member name="P:System.FuncExtentions.Integrator.C">
            <summary>Константа интегрирования</summary>
        </member>
        <member name="P:System.FuncExtentions.Integrator.x0">
            <summary>Начальное положение интегратора</summary>
        </member>
        <member name="P:System.FuncExtentions.Integrator.f">
            <summary>Интегрируемая функция</summary>
        </member>
        <member name="M:System.FuncExtentions.Integrator.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Инициализация нового интегратора функции</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x0">Начальное положение интегратора</param>
            <param name="C">Константа интегрирования</param>
        </member>
        <member name="M:System.FuncExtentions.Integrator.GetValue(System.Double,System.Double)">
            <summary>Метод расчёта интеграла от предыдущего положения интегратора до указанного</summary>
            <param name="x">Требуемое значение конца интервала интегрирования</param>
            <param name="eps">Точность процесса интегрирования</param>
            <returns>Значение численного интеграла на интервале от предыдущего положения интегратора до указанного</returns>
        </member>
        <member name="M:System.FuncExtentions.Integrator.GetIntegral(System.Double)">
            <summary>Получить функцию, равную интегралу от интегрируемой функции</summary>
            <param name="eps">Точность интегрирования</param>
            <returns>Интеграл функци</returns>
        </member>
        <member name="T:System.FuncExtentions.VectorAddDelegate">
            <summary>Делегат функции сложения двух векторов</summary>
            <param name="C">Вектор результата сложения</param>
            <param name="B">Вектор первого слогаемого</param>
            <param name="A">Вектор второго слогаемого</param>
            <param name="length">Длина векторов</param>
        </member>
        <member name="M:System.FuncExtentions.CreateFastFloatSummator">
            <summary>Метод генерации быстрого сумматора двух векторов вещественных чисел</summary>
            <returns>Метод сложения двух векторов вещественных чисел</returns>
        </member>
        <member name="T:System.FuncExtentions.SamplingResult`1">
            <summary>Результат дескритезации функции</summary>
            <typeparam name="TValue">Тип значений функции</typeparam>
        </member>
        <member name="T:System.FuncExtentions.SamplingResult`1.Result">
            <summary>Отсчёт функции</summary>
        </member>
        <member name="F:System.FuncExtentions.SamplingResult`1.Result.Argument">
            <summary>Значение аргумента отсчёта</summary>
        </member>
        <member name="F:System.FuncExtentions.SamplingResult`1.Result.Value">
            <summary>Значение функции</summary>
        </member>
        <member name="M:System.FuncExtentions.SamplingResult`1.Result.#ctor(System.Double,`0)">
            <summary>Инициализация нового отсчёта функции</summary>
            <param name="Argument">Значение аргумента функции</param>
            <param name="Value">Значение функции</param>
        </member>
        <member name="M:System.FuncExtentions.SamplingResult`1.Result.op_Implicit(System.FuncExtentions.SamplingResult{`0}.Result)~System.Tuple{System.Double,`0}">
            <summary>Оператор неявного приведения отсчёта функции к картежу двух элементов - значение отсчёта функции - значение функции</summary>
            <param name="result">Отсчёт функции</param>
        </member>
        <member name="P:System.FuncExtentions.SamplingResult`1.Values">
            <summary>Перечисление отсчётов функции</summary>
        </member>
        <member name="P:System.FuncExtentions.SamplingResult`1.Accuracy">
            <summary>Оценка точности дискретизации</summary>
        </member>
        <member name="M:System.FuncExtentions.SamplingResult`1.#ctor(System.Collections.Generic.IEnumerable{System.FuncExtentions.SamplingResult{`0}.Result},System.Double)">
            <summary>Инициализация нового результата дискретизации функции</summary>
            <param name="Values">Перечисление отсчётов функции</param>
            <param name="Accuracy">Оценка точности дискретизации</param>
        </member>
        <member name="T:System.FuncExtentions.SimpleSamplingResult">
            <summary>Результат дискретизации вещественной функции</summary>
        </member>
        <member name="M:System.FuncExtentions.SimpleSamplingResult.Sampling(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
            <returns>Кортеж, содержащий связанный список дискретов функции и оценку точности дискретизации</returns>
        </member>
        <member name="F:System.FuncExtentions.SimpleSamplingResult._F">
            <summary>Дискретизируемая функция</summary>
        </member>
        <member name="F:System.FuncExtentions.SimpleSamplingResult._List">
            <summary>Связанный список отсчётов функции</summary>
        </member>
        <member name="M:System.FuncExtentions.SimpleSamplingResult.#ctor(System.Tuple{System.Collections.Generic.LinkedList{System.FuncExtentions.SamplingResult{System.Double}.Result},System.Double})">
            <summary>Инициализация нового результата дискретизации по кортежу дискретов функции и оценки точности дискретизации</summary>
            <param name="SamplingResult">Кортеж дискретов функции и оценки точности дскретизации</param>
        </member>
        <member name="M:System.FuncExtentions.SimpleSamplingResult.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового результата дискретизации</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Окончание интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
        </member>
        <member name="M:System.FuncExtentions.SimpleSamplingResult.ClarifySampling(System.Double)">
            <summary>Уточнение результата дискретизации</summary>
            <param name="accuracy">Требуемая точность</param>
            <returns>Истина, если требуемая точность достигнута</returns>
        </member>
        <member name="M:System.FuncExtentions.SimpleSamplingResult.GetValues">
            <summary>Метод получения отсчётов функции</summary>
            <returns>Массив отсчётов функции</returns>
        </member>
        <member name="M:System.FuncExtentions.SimpleSamplingResult.op_Implicit(System.FuncExtentions.SimpleSamplingResult)~System.FuncExtentions.SamplingResult{System.Double}.Result[]">
            <summary>Оператор неявного приведения типа результата дискретизации к типу массива отсчётов функции</summary>
            <param name="result">Результат дискретизации</param>
        </member>
        <member name="M:System.FuncExtentions.SamplingAdaptive(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Адаптивный метод дискретизации вещественной функции</summary>
            <param name="f">Дискретизируемая вещественная функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Окончание интервала дискретизации</param>
            <param name="eps">Точность дискретизации</param>
            <returns>Результат дискретизации вещественной функции</returns>
        </member>
        <member name="M:System.FuncExtentions.SamplingAdaptive``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Адаптивный метод дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Конвертер преобразования значения функции в вещественное число для оценки точности дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Окончание интервала дискретизации</param>
            <param name="eps">Точность дискретизации</param>
            <returns>Результат дискретизации функции</returns>
        </member>
        <member name="T:System.FuncExtentions.AdaptiveSamplingResult`1">
            <summary>Результат адаптивной дискретизации</summary>
            <typeparam name="T">Тип значения дискретизируемой функци</typeparam>
        </member>
        <member name="M:System.FuncExtentions.AdaptiveSamplingResult`1.Sampling(System.Func{System.Double,`0},System.Func{`0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественное число для оценки точности дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">НАчальный шаг дискретизации</param>
            <returns>Кортеж со списком значений функции и вещественным число, оценивающим точность дискретизации</returns>
        </member>
        <member name="F:System.FuncExtentions.AdaptiveSamplingResult`1._List">
            <summary>СВязанный список с дискретами функции</summary>
        </member>
        <member name="F:System.FuncExtentions.AdaptiveSamplingResult`1._F">
            <summary>Дискретизируемая функция</summary>
        </member>
        <member name="F:System.FuncExtentions.AdaptiveSamplingResult`1._Converter">
            <summary>Метод преобразования значений функции в вещественное число для оценки качества дискретизации</summary>
        </member>
        <member name="M:System.FuncExtentions.AdaptiveSamplingResult`1.#ctor(System.Tuple{System.Collections.Generic.LinkedList{System.FuncExtentions.SamplingResult{`0}.Result},System.Double})">
            <summary>Инициализация нового адаптивного дискретизацтора</summary>
            <param name="SamplingResult">Список отсчётов дискретизации функции и оценка точности дискретизации</param>
        </member>
        <member name="M:System.FuncExtentions.AdaptiveSamplingResult`1.#ctor(System.Func{System.Double,`0},System.Func{`0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового адаптивного дискретизацтора</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественное число для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
        </member>
        <member name="M:System.FuncExtentions.AdaptiveSamplingResult`1.ClarifySampling(System.Double)">
            <summary>Точная дискретизации</summary>
            <param name="accuracy">Требуемая точность</param>
            <returns>Полученная точность дискретизации</returns>
        </member>
        <member name="M:System.FuncExtentions.AdaptiveSamplingResult`1.GetValues">
            <summary>Получить отсчёты функции в виде массива значений</summary>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:System.FuncExtentions.AdaptiveSamplingResult`1.op_Implicit(System.FuncExtentions.AdaptiveSamplingResult{`0})~System.FuncExtentions.SamplingResult{`0}.Result[]">
            <summary>Оператор неявного преобразования результатов адаптивной дискретизации функции в массив её значений</summary>
            <param name="result">Результаты адаптивной дискретизации функции</param>
        </member>
        <member name="T:System.FuncExtentions.SamplingResultOneWay">
            <summary>Результаты дискретизации функции адаптивным однопроходным методом</summary>
        </member>
        <member name="M:System.FuncExtentions.SamplingResultOneWay.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Инициализация нового результата адаптивной дискретизации однопроходным методом</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="eps">Требуемая точность дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
        </member>
        <member name="M:System.FuncExtentions.SamplingAdaptive_OneWay(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Однопроходный адаптивный метод дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="eps">Требуемая точность дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <returns>Результат дискретизации</returns>
        </member>
        <member name="M:System.FuncExtentions.SamplingAdaptive_OneWay_(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Action{System.Double})">
            <summary>Метод однопроходной адаптивной дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="eps">Требуемая точность дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <param name="UpdateAccuracy">Метод обновления значения точности дискретизации в процесс самой дискретизации</param>
            <returns>Перечисление результатов дискретизации</returns>
        </member>
        <member name="T:System.FuncExtentions.SamplingResultOneWayT`1">
            <summary>Результаты адаптивной однопроходной дискретизации функции значений указанного типа</summary>
            <typeparam name="T">ТИп значений функции</typeparam>
        </member>
        <member name="M:System.FuncExtentions.SamplingAdaptive_OneWay``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Адаптивная дискретизация функции в один проход</summary>
            <typeparam name="T">Тип значений функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="eps">Требуемая точность дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <returns>Результат дискретизации функции</returns>
        </member>
        <member name="M:System.FuncExtentions.SamplingAdaptive_OneWayT_``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double,System.Double,System.Action{System.Double})">
            <summary>МЕтод последовательной дискретизации функции с адаптивным шагом</summary>
            <typeparam name="T">Тип значений функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="eps">Требуемая точность</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <param name="UpdateAccuracy">Метод обновления значения текущего уровня точности дискретизации</param>
            <returns>Перечисление отсчётов функции</returns>
        </member>
        <member name="T:System.FuncExtentions.SamplingResultHalfDivision">
            <summary>Результат дискретизации методом половинного деления</summary>
        </member>
        <member name="M:System.FuncExtentions.SamplingResultHalfDivision.#ctor(System.Tuple{System.FuncExtentions.SamplingResult{System.Double}.Result[],System.Double})">
            <summary>Инициализация нового экземпляра результата дискретизации методом половинного деления</summary>
            <param name="Result">Результаты дискретизации, содержащие массив отсчётов функции и значение точности</param>
        </member>
        <member name="M:System.FuncExtentions.SamplingResultHalfDivision.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового экземпляра результата дискретизации функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="eps">Требуемая точность</param>
        </member>
        <member name="M:System.FuncExtentions.SamplingAdaptive_HalfDivision(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Дискретизациия функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="eps">Требуемая точность</param>
            <returns>Результат дискретизации функции методом половинного деления</returns>
        </member>
        <member name="M:System.FuncExtentions.SamplingAdaptive_HalfDivision_(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации функции методом половиноного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="eps">Требуемая точность</param>
            <returns>Результаты дискретизации</returns>
        </member>
        <member name="T:System.FuncExtentions.SamplingResultHalfDivisionT`1">
            <summary>Результат дискретизации методом половинного деления</summary>
            <typeparam name="T">Тип значений функции</typeparam>
        </member>
        <member name="M:System.FuncExtentions.SamplingResultHalfDivisionT`1.#ctor(System.Tuple{System.FuncExtentions.SamplingResult{`0}.Result[],System.Double})">
            <summary>Инициализация нового экземпляра результата дискретизации методом половинного деления</summary>
            <param name="Result">Результаты дискретизации, содержащие массив отсчётов функции и значение точности</param>
        </member>
        <member name="M:System.FuncExtentions.SamplingResultHalfDivisionT`1.#ctor(System.Func{System.Double,`0},System.Func{`0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового экземпляра результата дискретизации функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="eps">Требуемая точность</param>
        </member>
        <member name="M:System.FuncExtentions.SamplingAdaptive_HalfDivision``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Дискретизациия функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="eps">Требуемая точность</param>
            <returns>Результат дискретизации функции методом половинного деления</returns>
        </member>
        <member name="M:System.FuncExtentions.SamplingAdaptive_HalfDivision_``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации функции методом половиноного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="eps">Требуемая точность</param>
            <returns>Результаты дискретизации</returns>
        </member>
        <member name="M:System.ByteExtentions.IsPowerOf2(System.Byte)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.ByteExtentions.BitCount(System.Byte)">
            <summary>Число бит числа</summary>
            <param name="x">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.ByteExtentions.BitReversing(System.Byte,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит [ = 16 ]</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.ByteExtentions.IsOdd(System.Byte)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.ByteExtentions.IsEven(System.Byte)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="T:System.DoubleExtentions">
            <summary>Расширения для чисел двойной точности</summary>
        </member>
        <member name="M:System.DoubleExtentions.Sqrt(System.Double)">
            <summary>Квадратный корень</summary>
            <param name="x">Число из которого извлекается квадратный корень</param>
            <returns>Квадратный корень числа</returns>
        </member>
        <member name="M:System.DoubleExtentions.IsInt(System.Double)">
            <summary>Является ли число целым?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число целое</returns>
        </member>
        <member name="M:System.DoubleExtentions.IsNaN(System.Double)">
            <summary>Является ли значение "не числом"?</summary>
            <param name="x">Проверяемое значение</param>
            <returns>Истина, если значение - не число</returns>
        </member>
        <member name="M:System.DoubleExtentions.Round(System.Double,System.Int32)">
            <summary>Округление числа до указанного количества знаков после запятой </summary>
            <param name="x">Округляемое число</param>
            <param name="n">Количество знаков после запятой при n >= 0 и до запятой при n меньше 0</param>
            <returns>Число, округлённое до указанной точности</returns>
        </member>
        <member name="M:System.DoubleExtentions.RoundAdaptive(System.Double,System.Int32)">
            <summary>Адаптивное округление</summary>
            <param name="x">Округляемая величина</param>
            <param name="n">Количество значащих разрядов</param>
            <returns>Число с указанным количеством значащих разрядов</returns>
        </member>
        <member name="M:System.DoubleExtentions.GetInverse(System.Double)">
            <summary>Получить обратное число</summary>
            <param name="x">Инвертируемое число</param>
            <returns>Число, обратное к исходном</returns>
        </member>
        <member name="M:System.DoubleExtentions.GetAbsMod(System.Double,System.Double)">
            <summary>Число по модулю</summary>
            <param name="x">Исходное число</param>
            <param name="mod">Модуль</param>
            <returns>Число по модулю</returns>
        </member>
        <member name="M:System.DoubleExtentions.GetAbs(System.Double)">
            <summary>Модуль числа</summary>
            <param name="x">Действительное вещественное число</param>
            <returns>Модуль числа</returns>
        </member>
        <member name="M:System.DoubleExtentions.Power(System.Double,System.Int32)">
            <summary>Возведение в целую степень</summary>
            <param name="x">Действительное число</param>
            <param name="n">Целочисленный показатель степени</param>
            <returns>x^n</returns>
        </member>
        <member name="M:System.DoubleExtentions.Power(System.Double,System.Double)">
            <summary>Возведение числа в действительную степень</summary>
            <param name="x">ОСнование</param><param name="y">Действительный показатель степени</param>
            <returns>Действительное число x возведённое в степень y: x^y</returns>
        </member>
        <member name="M:System.DoubleExtentions.Power(System.Double,MathService.Complex)">
            <summary>Возведение числа в комплексную степень</summary>
            <param name="x">Основание</param><param name="z">Комплексный показатель степень</param>
            <returns>Значение x^z, где x - действительное, z - комплексное</returns>
        </member>
        <member name="M:System.DoubleExtentions.In_dB(System.Double)">
            <summary>Преобразование в децебеллы по амплитуде</summary>
            <param name="x">Амплитудное значение 20*lg(x)</param>
            <returns>Значение в децебеллах</returns>
        </member>
        <member name="M:System.DoubleExtentions.In_dB_byPower(System.Double)">
            <summary>Преобразование в децебеллы по мощности</summary>
            <param name="x">Значение мощности 10*lg(x)</param>
            <returns>Значение в децебеллах</returns>
        </member>
        <member name="M:System.DoubleExtentions.From_dB(System.Double)">
            <summary>Преобразование из децебеллов в разы по значению (амплитуде)</summary>
            <param name="db">Значение в децебеллах 10^(x/20)</param>
            <returns>Значение в разах по амплитуде</returns>
        </member>
        <member name="M:System.DoubleExtentions.From_dB_byPower(System.Double)">
            <summary>Преобразование из децебеллов в разы по мощности</summary>
            <param name="db">Значение в децебеллах 10^(x/10)</param>
            <returns>Значение в разах по мощности</returns>
        </member>
        <member name="M:System.DoubleExtentions.ToRad(System.Double)">
            <summary>Преобразование значения в радианы</summary>
            <param name="deg">Значение в градусах</param>
            <returns>Значение в радианах</returns>
        </member>
        <member name="M:System.DoubleExtentions.ToDeg(System.Double)">
            <summary>Преобразование значения в градусы</summary>
            <param name="rad">Значение в радианах</param>
            <returns>Значение в градусах</returns>
        </member>
        <member name="M:System.LongExtentions.IsPowerOf2(System.Int64)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.LongExtentions.BitCount(System.Int64)">
            <summary>Число бит числа</summary>
            <param name="x">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.LongExtentions.BitReversing(System.Int64,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.LongExtentions.BitReversing(System.Int64)">
            <summary>Реверсирование всех 64 бит числа</summary>
            <param name="x">исходное число</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.LongExtentions.IsOdd(System.Int64)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.LongExtentions.IsEven(System.Int64)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="M:System.ShortExtentions.IsPowerOf2(System.Int16)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.ShortExtentions.BitCount(System.Int16)">
            <summary>Число бит числа</summary>
            <param name="x">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.ShortExtentions.BitReversing(System.Int16,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.ShortExtentions.BitReversing(System.Int16)">
            <summary>Реверсирование всех 16 бит числа</summary>
            <param name="x">исходное число</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.ShortExtentions.IsOdd(System.Int16)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.ShortExtentions.IsEven(System.Int16)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="T:System.EventHandlerExtension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.Collections.Specialized.NotifyCollectionChangedEventHandler,System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.ComponentModel.PropertyChangedEventHandler,System.Object,System.String)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.ComponentModel.PropertyChangedEventHandler,System.Object,System.String[])">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="PropertyName">Имена изменившихся свойств</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.ComponentModel.PropertyChangedEventHandler,System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.EventHandler,System.Object,System.EventArgs)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerExtension.StartAsync(System.EventHandler,System.Object,System.EventArgs,System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, Передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerExtension.FastStart(System.EventHandler,System.Object)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerExtension.FastStart(System.EventHandler,System.Object,System.EventArgs)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:System.EventHandlerExtension.FastStart``1(System.EventHandler{``0},System.Object,``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start``1(System.EventHandler{``0},System.Object,``0)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:System.EventHandlerExtension.StartAsync``1(System.EventHandler{``0},System.Object,``0,System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхроная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <param name="e">Аргументы события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, Передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start``3(System.EventHandler{``0,``1,``2},``1,``2)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TArgs">Тип аргумента события</typeparam>
            <param name="Args">Аргументы события</param>
            <typeparam name="TResult">Тип результата обработки события</typeparam>
            <typeparam name="TSender">Тип источника события</typeparam>
            <returns>Массив результатов обработки события</returns>
        </member>
        <member name="T:System.ObjectExtentions">
            <summary>Класс методов-расширений для объекта</summary>
        </member>
        <member name="M:System.ObjectExtentions.AsEnumerable``1(``0,System.Func{``0,``0},System.Boolean)">
            <summary>Преобразование объекта в бесконечное перечисление</summary>
            <typeparam name="T">Тип элементов генерируемого перечисления</typeparam>
            <param name="obj">Объект, на основе которого создаётся перечисление</param>
            <param name="NextObject">Метод, генерирующий новый объект последовательности</param>
            <param name="TakeFirst">Выдать в последовательность исходный элемент</param>
            <returns>Бесконечная последовательность элементов, генерируемая указанным методом</returns>
        </member>
        <member name="T:System.ObjectExtentions.ObjectSelector`2">
            <summary>Селектор элементов</summary>
            <typeparam name="TSource">Тип объекта-источника</typeparam>
            <typeparam name="TResult">Тип объекта-значения</typeparam>
        </member>
        <member name="P:System.ObjectExtentions.ObjectSelector`2.Continue">
            <summary>Продолжать выборку?</summary>
        </member>
        <member name="P:System.ObjectExtentions.ObjectSelector`2.Object">
            <summary>Объект-источник</summary>
        </member>
        <member name="P:System.ObjectExtentions.ObjectSelector`2.Result">
            <summary>Объект-значение</summary>
        </member>
        <member name="P:System.ObjectExtentions.ObjectSelector`2.Iteration">
            <summary>Номер итерации</summary>
        </member>
        <member name="M:System.ObjectExtentions.ObjectSelector`2.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.ObjectExtentions.ObjectSelector`2"/></summary>
        </member>
        <member name="M:System.ObjectExtentions.ObjectSelector`2.Next(`1,System.Boolean)">
            <summary>Переход к следующей итерации</summary>
            <param name="result">Результат итерации</param>
            <param name="continue">Продолжать выборку</param>
        </member>
        <member name="M:System.ObjectExtentions.SelectObj``2(``0,System.Action{System.ObjectExtentions.ObjectSelector{``0,``1}})">
            <summary>Генерация последовательности значений на основе алгоритма выборки</summary>
            <typeparam name="TSource">Тип объекта-источника</typeparam>
            <typeparam name="TResult">Тип объекта-значения последовательности</typeparam>
            <param name="source">Источник последовательности</param>
            <param name="Selector">Метод выборки элементов из источника</param>
            <returns>Последовательность объектов, генерируемых на основе объекта-источника</returns>
        </member>
        <member name="M:System.ObjectExtentions.SelectObject``2(``0,System.Func{``0,``1})">
            <summary>Метод преобразования объекта</summary>
            <typeparam name="TSource">Тип источника объекта</typeparam>
            <typeparam name="TResult">Тип результата</typeparam>
            <param name="source">Объект-источник</param>
            <param name="Selector">Метод генерации значения</param>
            <returns>Значение, определяемое на основе объекта-источника указанным методом</returns>
        </member>
        <member name="M:System.ObjectExtentions.ToFormattedString(System.Object,System.String)">
            <summary>Преобразование объекта в форматированную строку</summary>
            <param name="obj">Преобразуемый объект</param>
            <param name="Format">Строка форматирования</param>
            <returns>Форматированная строка текстового представления объекта</returns>
        </member>
        <member name="M:System.ObjectExtentions.ToFormattedString(System.Object,System.String,System.Object[])">
            <summary>Преобразование объекта в форматированную строку</summary>
            <param name="obj">Преобразуемый объект (идущий нулевым аргументом)</param>
            <param name="Format">Строка форматирования</param>
            <param name="args">Массив аргументов, доавбляемых к объекту для создание форматированной строки</param>
            <returns>Форматированная строка текстового представления объекта</returns>
        </member>
        <member name="M:System.ObjectExtentions.ToString``1(``0,System.Func{``0,System.String})">
            <summary>Метод преобразования объекта в строку</summary>
            <typeparam name="T">Тип исходного объекта</typeparam>
            <param name="t">Преобразуемый объект</param>
            <param name="converter">Метод преобразвоания объекта в строку</param>
            <returns>Сгенерированная строка указанным методом на основе указанного объекта</returns>
        </member>
        <member name="M:System.ObjectExtentions.GetHashCode(System.Object[])">
            <summary>Расчёт хеш-кода массива объектов</summary>
            <param name="Objects">Массив объектов, хеш-код которых надо расчитать</param>
            <returns>Хеш-код массива объектов</returns>
        </member>
        <member name="M:System.ObjectExtentions.GetComplexHashCode(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Расчёт хеш-кода перечисления объектов</summary>
            <param name="Objects">Перечисление объектов, хеш-код которых надо расчитать</param>
            <returns>Хеш-код перечисления объектов</returns>
        </member>
        <member name="M:System.ObjectExtentions.GetObjectAttribute``1(System.Object,System.Boolean)">
            <summary>Извлечение атрибута метаданных объекта</summary>
            <typeparam name="TAttribute">Тип извлекаемого атрибута</typeparam>
            <param name="o">Объект, атрибут которого требуется получить</param>
            <param name="Inherited">Искать в цепочке наследования</param>
            <returns>Искомый атрибут в случае его наличия, либо null, если атрибут не определён</returns>
        </member>
        <member name="M:System.ObjectExtentions.GetObjectAttributes``1(System.Object,System.Boolean)">
            <summary>Извлечение всех атрибутов указанного типа для объекта</summary>
            <typeparam name="TAttribute">Тип извлекаемого атрибута</typeparam>
            <param name="o">Объект, атрибуты которого требуется получить</param>
            <param name="Inherited">Искать в цепочке наследования</param>
            <returns>Массив атрибутов указанного типа, определённых для объекта</returns>
        </member>
        <member name="M:System.ObjectExtentions.IsNotNull(System.Object)">
            <summary>Ссылка на объект не равна null</summary>
            <param name="o">Проверяемый объект</param>
            <returns>Истина, если проверяемый объект не null</returns>
        </member>
        <member name="M:System.ObjectExtentions.IsNull(System.Object)">
            <summary>Ссылка на объект равна null</summary>
            <param name="o">Проверяемый объект</param>
            <returns>Истина, если проверяемый объект null</returns>
        </member>
        <member name="M:System.ObjectExtentions.GetAttributes``2(``1,System.Boolean)">
            <summary>Получение списка атрибутов указанного типа для типа переданного объекта</summary>
            <typeparam name="TAttribute">Тип извлекаемого атрибута</typeparam>
            <typeparam name="TObject">Тип исходного объекта</typeparam>
            <param name="o">Объект, атрибуты которого требуется получить</param>
            <param name="Inherited">Искать в цепочке наследования</param>
            <returns>ассив атрибутов указанного типа, определённых для типа объекта</returns>
        </member>
        <member name="M:System.ObjectExtentions.InitializeObject``1(``0,System.Action{``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="Initializator">Действие инициализации</param>
            <returns>Инициализированный объект</returns>
        </member>
        <member name="M:System.ObjectExtentions.InitializeObject``2(``0,``1,System.Action{``0,``1})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="Initializator">Действие инициализации</param>
            <returns>Инициализированный объект</returns>
        </member>
        <member name="M:System.ObjectExtentions.InitializeObject``1(``0,System.Func{``0,``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="Initializator">Функция инициализации, определяющая значение конечного объекта</param>
            <returns>Объект, возвращённый функцией инициализации</returns>
        </member>
        <member name="M:System.ObjectExtentions.InitializeObject``2(``0,``1,System.Func{``0,``1,``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="Initializator">Функция инициализации, определяющая значение конечного объекта</param>
            <returns>Объект, возвращённый функцией инициализации</returns>
        </member>
        <member name="M:System.ObjectExtentions.ToConsole``1(``0)">
            <summary>Печать объекта на консоли без переноса строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
        </member>
        <member name="M:System.ObjectExtentions.ToConsole``1(``0,System.String,System.Object[])">
            <summary>Печать объекта на консоли в указанному формате без переноса строки в конце</summary>
            <typeparam name="TObject">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
            <param name="Format">Строка форматирования результата</param>
            <param name="args">Дополнительные аргументы строки форматирования</param>
        </member>
        <member name="M:System.ObjectExtentions.ToConsoleLN``1(``0)">
            <summary>Печать объекта на консоли с переносом строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
        </member>
        <member name="M:System.ObjectExtentions.ToConsoleLN``1(``0,System.String,System.Object[])">
            <summary>Печать объекта на консоли в указанному формате с переносом строки в конце</summary>
            <typeparam name="TObject">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
            <param name="Format">Строка форматирования результата</param>
            <param name="args">Дополнительные аргументы строки форматирования</param>
        </member>
        <member name="M:System.ObjectExtentions.ToDubugOut``1(``0)">
            <summary>Печать объекта в отладочной информации без переноса строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
        </member>
        <member name="M:System.ObjectExtentions.ToDubugOut``1(``0,System.Boolean)">
            <summary>Печать объекта в отладочной информации без переноса строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
            <param name="Condition">Условие (если истина, то объект печатается в отладочный вывод)</param>
        </member>
        <member name="M:System.ObjectExtentions.ToDubugOutLN``1(``0)">
            <summary>Печать объекта в отладочной информации с переносом строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
        </member>
        <member name="M:System.ObjectExtentions.ToDubugOutLN``1(``0,System.Boolean)">
            <summary>Печать объекта в отладочной информации с переносом строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
            <param name="Condition">Условие (если истина, то объект печатается в отладочный вывод)</param>
        </member>
        <member name="M:System.ObjectExtentions.ToByteArray``1(``0)">
            <summary>Преобразование структуры в массив байт</summary>
            <typeparam name="T">Тип преобразуемой структуры</typeparam>
            <param name="value">Значение преобразуемой структуры</param>
            <returns>Массив байт, представляющий указанную структуру</returns>
        </member>
        <member name="M:System.ObjectExtentions.ToStructure``1(System.Byte[],System.Int32)">
            <summary>Преобразование массива байт в структуру</summary>
            <typeparam name="T">Тип структуры</typeparam>
            <param name="data">Массив байт</param>
            <param name="offset">Смещение в массиве байт</param>
        </member>
        <member name="M:System.ObjectExtentions.Switch(System.Object,System.Actions,System.Action{System.Object})">
            <summary>Выбор действия для объекта</summary>
            <param name="obj">ОБъект, на котором выполняется выбор действия</param>
            <param name="actions">Словарь возможных действий над объектом</param>
            <param name="Default">Действие по умолчанию</param>
        </member>
        <member name="T:System.ObjectExtentions.StructureReader`1">
            <summary>Метод чтения структуры данных из массива байт</summary>
            <typeparam name="T">Тип структуры</typeparam>
            <param name="data">Массив байт</param>
            <param name="offset">Смещение в массиве байт</param>
            <param name="value">Прочитанная структура</param>
        </member>
        <member name="F:System.ObjectExtentions.StructureReadersPool`1.__Reader">
            <summary>Делегат чтения структуры данных</summary>
        </member>
        <member name="P:System.ObjectExtentions.StructureReadersPool`1.Reader">
            <summary>Делегат чтения структуры данных</summary>
        </member>
        <member name="M:System.ObjectExtentions.StructureReadersPool`1.CreateDelegate">
            <summary>Создать делегат чтения структуры данных</summary>
            <returns>Делегат, читающий структуру из массива данных</returns>
        </member>
        <member name="M:System.ObjectExtentions.GetStructReader``1">
            <summary>Получить метод чтения структур указанного типа из массива байт</summary>
            <typeparam name="T">Тип структуры данных</typeparam>
            <returns>Делегат чтения структуры данных из массива байт</returns>
        </member>
        <member name="M:System.ObjectExtentions.ReadPointerLCG``1(System.Byte[],System.Int32,``0@)">
            <summary>Чтение структуры данных из массива байт</summary>
            <typeparam name="T">Тип структуры данных</typeparam>
            <param name="data">Массив байт</param>
            <param name="offset">Смещение в массиве байт</param>
            <param name="value">Значение, прочитанное из структуры данных</param>
        </member>
        <member name="M:System.ObjectExtentions.ToEvulation``1(``0)">
            <summary>Преобразование объекта в вычисление</summary>
            <typeparam name="T">Тип исходного элемента</typeparam>
            <param name="obj">Оборачиваемый объект</param>
            <returns>Вычисление, возвращающее указанный объект</returns>
        </member>
        <member name="M:System.ObjectExtentions.ToEvulation``1(``0,System.String)">
            <summary>Преобразование объекта в именованное вычисление</summary>
            <typeparam name="T">Тип исходного элемента</typeparam>
            <param name="obj">Оборачиваемый объект</param>
            <param name="Name">Имя вычисления</param>
            <returns>Вычисление, возвращающее указанный объект</returns>
        </member>
        <member name="M:System.ObjectExtentions.ToExpression(System.Object)">
            <summary>Преобразование объекта в выражение-константу</summary>
            <param name="obj">Преобразуемый объект</param>
            <returns>Выражение-константа</returns>
        </member>
        <member name="M:System.ObjectExtentions.GetCallExpression(System.Object,System.Delegate,System.Linq.Expressions.Expression[])">
            <summary>Получить выражение вызова метода объекта</summary>
            <param name="obj">Объект, метод которого надо вызвать</param>
            <param name="d">Делегат метода</param>
            <param name="p">Параметры метода</param>
            <returns>Выражение вызова метода</returns>
        </member>
        <member name="M:System.ObjectExtentions.GetCallExpression(System.Object,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
            <summary>Получить выражение вызова метода объекта</summary>
            <param name="obj">Объект, метод которого надо вызвать</param>
            <param name="d">Описание методаа</param>
            <param name="p">Параметры метода</param>
            <returns>Выражение вызова метода</returns>
        </member>
        <member name="M:System.ObjectExtentions.GetCallExpression(System.Object,System.String,System.Linq.Expressions.Expression[])">
            <summary>Получить выражение вызова метода объекта</summary>
            <param name="obj">Объект, метод которого надо вызвать</param>
            <param name="MethodName">Имя метода</param>
            <param name="p">Параметры метода</param>
            <returns>Выражение вызова метода</returns>
        </member>
        <member name="T:System.Actions">
            <summary>Словарь действий</summary>
        </member>
        <member name="T:System.Tags.TagExtentions">
            <summary>Класс методов-расширений для реализации функциональности добавления объектов, которые могут быть приложенны к другим объектам</summary>
        </member>
        <member name="M:System.Tags.TagExtentions.GetTag``1(System.Object)">
            <summary>Получить объект-метку у казанного типа из целевого объекта</summary>
            <typeparam name="TTag">Тип объекта-метки</typeparam>
            <param name="o">Целевой объект</param>
            <returns>Объект метка, если он существует в указанном объекте</returns>
        </member>
        <member name="M:System.Tags.TagExtentions.SetTag``1(System.Object,``0)">
            <summary>Установить объект-метку для указанного объекта</summary>
            <typeparam name="TTag">Тип объекта-метки</typeparam>
            <param name="o">Целевой объект</param>
            <param name="Tag">Объект-метка, прикладываемый к целевому объекту</param>
        </member>
        <member name="T:System.Tags.TagExtentions.TagPool">
            <summary>Пул меток</summary>
        </member>
        <member name="F:System.Tags.TagExtentions.TagPool.__Lock">
            <summary>Объект межпотоковой синхронизации</summary>
        </member>
        <member name="F:System.Tags.TagExtentions.TagPool.__Tags">
            <summary>Словарь меток</summary>
        </member>
        <member name="M:System.Tags.TagExtentions.TagPool.SetTag(System.Object,System.Object)">
            <summary>Установить метку указанному объекту</summary>
            <param name="o">Целевой объект</param>
            <param name="Tag">Добавляемая метка</param>
        </member>
        <member name="M:System.Tags.TagExtentions.TagPool.Tag``1(System.Object)">
            <summary>Получить метку указанного типа для указанного объекта</summary>
            <typeparam name="TTagType">Тип объекта-метки</typeparam>
            <param name="o">Целевой объект</param>
            <returns>Объект-метка</returns>
        </member>
        <member name="M:System.TypeExtentions.GetTypeConverter(System.Type)">
            <summary>Получить конвертер значений для указанного типа данных</summary>
            <param name="type">Тип, для которого требуется получить конвертер</param>
            <returns>Конвертер указанного типа данных</returns>
        </member>
        <member name="M:System.TypeExtentions.GetType(System.String)">
            <summary>Получить тип по его имени из всех загруженных сборок</summary>
            <param name="TypeName">Имя типа</param>
            <returns>Тип</returns>
        </member>
        <member name="M:System.TypeExtentions.GetCustomAttributes``1(System.Type)">
            <summary>Получить все атрибуты типа указанного типа</summary>
            <typeparam name="TAttribute">Тип требуемых атрибутов</typeparam>
            <param name="T">Тип, атрибуты которого требуется получить</param>
            <returns>Массив атрибутов типа указанного типа</returns>
        </member>
        <member name="T:System.IntExtentions">
            <summary>Класс методов-расширений для класса целых 4-х-байтовых чисел со знаком</summary>
        </member>
        <member name="M:System.IntExtentions.Power(System.Int32,System.Int32)">
            <summary>Возведение целого числа в целую степень</summary>
            <param name="x">Целое основание</param>
            <param name="N">Целый показатель степени</param>
            <returns>Результат возведения целого основания в целую степень</returns>
        </member>
        <member name="M:System.IntExtentions.Power(System.Int32,System.Double)">
            <summary>Возведение целого числа в вещественную степень</summary>
            <param name="x">Целое основание</param>
            <param name="q">Вещественный показатель степени</param>
            <returns>Результат возведения целого основания в вещественную степень</returns>
        </member>
        <member name="M:System.IntExtentions.Power(System.Int32,MathService.Complex)">
            <summary>Возведение целого числа в комплексную степень</summary>
            <param name="x">Целое основание</param>
            <param name="z">Комплексный показатель степени</param>
            <returns>Результат возведения целого основания в комплексную степень</returns>
        </member>
        <member name="M:System.IntExtentions.FactorizationEnum(System.Int32)">
            <summary>Факторизация целого числа</summary>
            <param name="n">Раскладываемое число</param>
            <returns>Последовательность простых чисел составляющих раскладываемое число</returns>
        </member>
        <member name="M:System.IntExtentions.FactorizationList(System.Int32)">
            <summary>Разложение числа на простые множетили</summary>
            <param name="n">Раскладываемое число</param>
            <returns>Массив простых множителей</returns>
        </member>
        <member name="M:System.IntExtentions.Factorization(System.Int32)">
            <summary>Разложение числа на простые множители</summary>
            <param name="n">Раскладываемое число</param>
            <returns>Словарь с делителями числа - значение элементов словаря - кратность делителя</returns>
        </member>
        <member name="M:System.IntExtentions.IsPrime(System.Int32)">
            <summary>Проверка - является ли число простым?</summary>
            <param name="n">Проверяемое число</param>
            <returns>Истина, если число простое</returns>
        </member>
        <member name="M:System.IntExtentions.IsPowerOf2(System.Int32)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="n">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.IntExtentions.BitCount(System.Int32)">
            <summary>Число бит числа</summary>
            <param name="n">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.IntExtentions.GetNumberOfDigits(System.Int32,System.Int32)">
            <summary>Получить число разрядов в указаной системе счисления</summary>
            <param name="n">Рассматриваемое число</param>
            <param name="Base">Основание системы счисления. По умолчанию = 10</param>
            <returns>Количество разрядов в указанной системе счисления</returns>
        </member>
        <member name="M:System.IntExtentions.GetBitArray(System.Int32,System.Int32)">
            <summary>Получить битовый массив из числа</summary>
            <param name="Value">Преобразуемое число</param>
            <param name="Length">Длина результирующего массива бит. По умолчанию = 32 битам</param>
            <returns>Битовый массив числа</returns>
        </member>
        <member name="M:System.IntExtentions.BitReversing(System.Int32,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.IntExtentions.BitReversing(System.Int32)">
            <summary>Реверсирование всех 32 бит числа</summary>
            <param name="x">исходное число</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.IntExtentions.IsDevidedTo(System.Int32,System.Int32)">
            <summary>Проверка делимости числа на делитель</summary>
            <param name="x">Делимое</param>
            <param name="y">Делитель</param>
            <returns>Истина, если остаток от целочисленного деления равен 0</returns>
        </member>
        <member name="M:System.IntExtentions.GetAbsMod(System.Int32,System.Int32)">
            <summary>Положительный остаток от деления</summary>
            <param name="x">Делимое</param>
            <param name="mod">Модуль</param>
            <returns>Остаток от деления</returns>
        </member>
        <member name="M:System.IntExtentions.GetAbs(System.Int32)">
            <summary>Получить абсолютное значение числа</summary>
            <param name="x">Вещественное число</param>
            <returns>Модуль числа</returns>
        </member>
        <member name="M:System.IntExtentions.GetNOD(System.Int32,System.Int32)">
            <summary>Наибольший общий делитель</summary>
            <param name="Y">Первое число</param>
            <param name="X">Второе число</param>
            <returns>Наибольший общий делитель</returns>
        </member>
        <member name="M:System.IntExtentions.IsOdd(System.Int32)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.IntExtentions.IsEven(System.Int32)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="M:System.IntExtentions.Factorial(System.Int32)">
            <summary>Факториал целого числа >= 0 и значение Г-функции для отрицательных значений</summary>
            <param name="n">Исходное число</param>
            <returns>Факториал числа</returns>
        </member>
        <member name="M:System.IntExtentions.ToOctBase(System.Int32)">
            <summary>Приведение целого числа в 10 системе счисления к виду системы счисления по основанию 8</summary>
            <param name="n">Число в 10-ой системе счисления</param>
            <returns>Представление числа в 8-ричной системе счисления</returns>
        </member>
        <member name="M:System.IntExtentions.FromOctalBase(System.Int32)">
            <summary>Приведение целого числа в 8 системе счисления к виду системы счисления по основанию 10</summary>
            <param name="x">Число в 8-ой системе счисления</param>
            <returns>Представление числа в 10-ричной системе счисления</returns>
        </member>
        <member name="T:System.Cycle">
            <summary>Цыклы алгоритмы</summary>
        </member>
        <member name="M:System.Cycle.ForParallel(System.Action{System.Int32,System.Int32},System.Int32,System.Boolean)">
            <summary>Циклическое выполнение действия в параллельном режиме</summary>
            <param name="cycle">Выполняемое действие</param>
            <param name="N">Число повторений</param>
            <param name="Whait">Оиждать давершения цикла?</param>
        </member>
        <member name="M:System.Cycle.ForLinear(System.Action{System.Int32,System.Int32},System.Int32)">
            <summary>Циклическое выполнение действия в последовательном режиме</summary>
            <param name="cycle">Выполняемое действие</param><param name="N">Число повторений</param>
        </member>
        <member name="T:System.Reflection.Event`2">
            <summary>Событие</summary>
            <typeparam name="TObject">Тип объекта-источника события</typeparam>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
        </member>
        <member name="E:System.Reflection.Event`2.EventHandler">
            <summary>Событие</summary>
        </member>
        <member name="F:System.Reflection.Event`2._EventInfo">
            <summary>Описание события</summary>
        </member>
        <member name="F:System.Reflection.Event`2._Object">
            <summary>Объект-источник</summary>
        </member>
        <member name="M:System.Reflection.Event`2.#ctor(`0,System.String,System.Boolean)">
            <summary>Событие</summary>
            <param name="o">Объект-источник события</param>
            <param name="Name">Название события</param>
            <param name="Private">Приватность описания события в классе объекта</param>
        </member>
        <member name="T:System.Reflection.Property`2">
            <summary>"Свойство" позднего связывания</summary>
            <typeparam name="TObject">Тип объекта, для которого определяется свойство</typeparam>
            <typeparam name="TValue">Тип значения свойства</typeparam>
        </member>
        <member name="F:System.Reflection.Property`2._PropertyInfo">
            <summary>Информация о свойстве</summary>
        </member>
        <member name="F:System.Reflection.Property`2._Name">
            <summary>Имя свйоства</summary>
        </member>
        <member name="F:System.Reflection.Property`2._Object">
            <summary>Объект, которому принадлежит свйоство</summary>
        </member>
        <member name="F:System.Reflection.Property`2._Private">
            <summary>Флаг приватности свйоства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.PropertyType">
            <summary>
            Тип значения свойства
            </summary>
        </member>
        <member name="P:System.Reflection.Property`2.Name">
            <summary>Имя свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Object">
            <summary>Объект, определяющий свойтсво</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Private">
            <summary>Признак - является ли свойство пиватным</summary>
        </member>
        <member name="P:System.Reflection.Property`2.IsExist">
            <summary>Признак </summary>
        </member>
        <member name="P:System.Reflection.Property`2.Value">
            <summary>Значение свйоства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.CanRead">
            <summary>Признак возможности читать значение</summary>
        </member>
        <member name="P:System.Reflection.Property`2.CanWrite">
            <summary>Признак возможности устанавливать значение</summary>
        </member>
        <member name="P:System.Reflection.Property`2.SupportsChangeEvents">
            <summary>
            Поддерживает генерацию событий изменения значения
            </summary>
        </member>
        <member name="P:System.Reflection.Property`2.Attributes">
            <summary>Атрибуты свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Descriptor">
            <summary>
            Дескриптор свйоства объекта
            </summary>
        </member>
        <member name="M:System.Reflection.Property`2.#ctor(System.String,System.Boolean)">
            <summary>Новый объект "Свойство" для позднего связывания</summary>
            <param name="Name">Имя свйосвта</param>
            <param name="Private">Является ли свойство скрытым</param>
        </member>
        <member name="M:System.Reflection.Property`2.#ctor(`0,System.String,System.Boolean)">
            <summary>Новый объект "Свойство" для позднего связывания</summary>
            <param name="o">Объект, для которого определяется свойство</param>
            <param name="Name">Имя свйосвта</param>
            <param name="Private">Является ли свойство скрытым</param>
        </member>
    </members>
</doc>
